

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Credits: addendum for version 6.1 &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="language/gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="language/coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="language/cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="language/module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="addendum/extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="addendum/universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Credits: addendum for version 6.1</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/credits-contents.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<p>Coq is a proof assistant for higher-order logic, allowing the
development of computer programs consistent with their formal
specification. It is the result of about ten years of research of the
Coq project. We shall briefly survey here three main aspects: the
<em>logical language</em> in which we write our axiomatizations and
specifications, the <em>proof assistant</em> which allows the development of
verified mathematical proofs, and the <em>program extractor</em> which
synthesizes computer programs obeying their formal specifications,
written as logical assertions in the language.</p>
<p>The logical language used by <span class="smallcaps">Coq</span> is a variety of type theory, called the
<em>Calculus of Inductive Constructions</em>. Without going back to Leibniz and
Boole, we can date the creation of what is now called mathematical logic
to the work of Frege and Peano at the turn of the century. The discovery
of antinomies in the free use of predicates or comprehension principles
prompted Russell to restrict predicate calculus with a stratification of
<em>types</em>. This effort culminated with <em>Principia Mathematica</em>, the first
systematic attempt at a formal foundation of mathematics. A
simplification of this system along the lines of simply typed
<span class="math notranslate">\(\lambda\)</span>-calculus occurred with Church’s <em>Simple Theory of
Types</em>. The <span class="math notranslate">\(\lambda\)</span>-calculus notation, originally used for
expressing functionality, could also be used as an encoding of natural
deduction proofs. This Curry-Howard isomorphism was used by N. de Bruijn
in the <em>Automath</em> project, the first full-scale attempt to develop and
mechanically verify mathematical proofs. This effort culminated with
Jutting’s verification of Landau’s <em>Grundlagen</em> in the 1970’s.
Exploiting this Curry-Howard isomorphism, notable achievements in proof
theory saw the emergence of two type-theoretic frameworks; the first
one, Martin-Löf’s <em>Intuitionistic Theory of Types</em>, attempts a new
foundation of mathematics on constructive principles. The second one,
Girard’s polymorphic <span class="math notranslate">\(\lambda\)</span>-calculus <span class="math notranslate">\(F_\omega\)</span>, is a
very strong functional system in which we may represent higher-order
logic proof structures. Combining both systems in a higher-order
extension of the Automath language, T. Coquand presented in 1985 the
first version of the <em>Calculus of Constructions</em>, CoC. This strong
logical system allowed powerful axiomatizations, but direct inductive
definitions were not possible, and inductive notions had to be defined
indirectly through functional encodings, which introduced inefficiencies
and awkwardness. The formalism was extended in 1989 by T. Coquand and C.
Paulin with primitive inductive definitions, leading to the current
<em>Calculus of Inductive Constructions</em>. This extended formalism is not
rigorously defined here. Rather, numerous concrete examples are
discussed. We refer the interested reader to relevant research papers
for more information about the formalism, its meta-theoretic properties,
and semantics. However, it should not be necessary to understand this
theoretical material in order to write specifications. It is possible to
understand the Calculus of Inductive Constructions at a higher level, as
a mixture of predicate calculus, inductive predicate definitions
presented as typed PROLOG, and recursive function definitions close to
the language ML.</p>
<p>Automated theorem-proving was pioneered in the 1960’s by Davis and
Putnam in propositional calculus. A complete mechanization (in the sense
of a semidecision procedure) of classical first-order logic was
proposed in 1965 by J.A. Robinson, with a single uniform inference rule
called <em>resolution</em>. Resolution relies on solving equations in free
algebras (i.e. term structures), using the <em>unification algorithm</em>. Many
refinements of resolution were studied in the 1970’s, but few convincing
implementations were realized, except of course that PROLOG is in some
sense issued from this effort. A less ambitious approach to proof
development is computer-aided proof-checking. The most notable
proof-checkers developed in the 1970’s were LCF, designed by R. Milner
and his colleagues at U. Edinburgh, specialized in proving properties
about denotational semantics recursion equations, and the Boyer and
Moore theorem-prover, an automation of primitive recursion over
inductive data types. While the Boyer-Moore theorem-prover attempted to
synthesize proofs by a combination of automated methods, LCF constructed
its proofs through the programming of <em>tactics</em>, written in a high-level
functional meta-language, ML.</p>
<p>The salient feature which clearly distinguishes our proof assistant from
say LCF or Boyer and Moore’s, is its possibility to extract programs
from the constructive contents of proofs. This computational
interpretation of proof objects, in the tradition of Bishop’s
constructive mathematics, is based on a realizability interpretation, in
the sense of Kleene, due to C. Paulin. The user must just mark his
intention by separating in the logical statements the assertions stating
the existence of a computational object from the logical assertions
which specify its properties, but which may be considered as just
comments in the corresponding program. Given this information, the
system automatically extracts a functional term from a consistency proof
of its specifications. This functional term may be in turn compiled into
an actual computer program. This methodology of extracting programs from
proofs is a revolutionary paradigm for software engineering. Program
synthesis has long been a theme of research in artificial intelligence,
pioneered by R. Waldinger. The Tablog system of Z. Manna and R.
Waldinger allows the deductive synthesis of functional programs from
proofs in tableau form of their specifications, written in a variety of
first-order logic. Development of a systematic <em>programming logic</em>,
based on extensions of Martin-Löf’s type theory, was undertaken at
Cornell U. by the Nuprl team, headed by R. Constable. The first actual
program extractor, PX, was designed and implemented around 1985 by S.
Hayashi from Kyoto University. It allows the extraction of a LISP
program from a proof in a logical system inspired by the logical
formalisms of S. Feferman. Interest in this methodology is growing in
the theoretical computer science community. We can foresee the day when
actual computer systems used in applications will contain certified
modules, automatically generated from a consistency proof of their
formal specifications. We are however still far from being able to use
this methodology in a smooth interaction with the standard tools from
software engineering, i.e. compilers, linkers, run-time systems taking
advantage of special hardware, debuggers, and the like. We hope that <span class="smallcaps">Coq</span>
can be of use to researchers interested in experimenting with this new
methodology.</p>
<p>A first implementation of CoC was started in 1984 by G. Huet and T.
Coquand. Its implementation language was CAML, a functional programming
language from the ML family designed at INRIA in Rocquencourt. The core
of this system was a proof-checker for CoC seen as a typed
<span class="math notranslate">\(\lambda\)</span>-calculus, called the <em>Constructive Engine</em>. This engine
was operated through a high-level notation permitting the declaration of
axioms and parameters, the definition of mathematical types and objects,
and the explicit construction of proof objects encoded as
<span class="math notranslate">\(\lambda\)</span>-terms. A section mechanism, designed and implemented by
G. Dowek, allowed hierarchical developments of mathematical theories.
This high-level language was called the <em>Mathematical Vernacular</em>.
Furthermore, an interactive <em>Theorem Prover</em> permitted the incremental
construction of proof trees in a top-down manner, subgoaling recursively
and backtracking from dead-alleys. The theorem prover executed tactics
written in CAML, in the LCF fashion. A basic set of tactics was
predefined, which the user could extend by his own specific tactics.
This system (Version 4.10) was released in 1989. Then, the system was
extended to deal with the new calculus with inductive types by C.
Paulin, with corresponding new tactics for proofs by induction. A new
standard set of tactics was streamlined, and the vernacular extended for
tactics execution. A package to compile programs extracted from proofs
to actual computer programs in CAML or some other functional language
was designed and implemented by B. Werner. A new user-interface, relying
on a CAML-X interface by D. de Rauglaudre, was designed and implemented
by A. Felty. It allowed operation of the theorem-prover through the
manipulation of windows, menus, mouse-sensitive buttons, and other
widgets. This system (Version 5.6) was released in 1991.</p>
<p>Coq was ported to the new implementation Caml-light of X. Leroy and D.
Doligez by D. de Rauglaudre (Version 5.7) in 1992. A new version of <span class="smallcaps">Coq</span>
was then coordinated by C. Murthy, with new tools designed by C. Parent
to prove properties of ML programs (this methodology is dual to program
extraction) and a new user-interaction loop. This system (Version 5.8)
was released in May 1993. A Centaur interface CTCoq was then developed
by Y. Bertot from the Croap project from INRIA-Sophia-Antipolis.</p>
<p>In parallel, G. Dowek and H. Herbelin developed a new proof engine,
allowing the general manipulation of existential variables consistently
with dependent types in an experimental version of <span class="smallcaps">Coq</span> (V5.9).</p>
<p>The version V5.10 of <span class="smallcaps">Coq</span> is based on a generic system for manipulating
terms with binding operators due to Chet Murthy. A new proof engine
allows the parallel development of partial proofs for independent
subgoals. The structure of these proof trees is a mixed representation
of derivation trees for the Calculus of Inductive Constructions with
abstract syntax trees for the tactics scripts, allowing the navigation
in a proof at various levels of details. The proof engine allows generic
environment items managed in an object-oriented way. This new
architecture, due to C. Murthy, supports several new facilities which
make the system easier to extend and to scale up:</p>
<ul class="simple">
<li>User-programmable tactics are allowed</li>
<li>It is possible to separately verify development modules, and to load
their compiled images without verifying them again - a quick
relocation process allows their fast loading</li>
<li>A generic parsing scheme allows user-definable notations, with a
symmetric table-driven pretty-printer</li>
<li>Syntactic definitions allow convenient abbreviations</li>
<li>A limited facility of meta-variables allows the automatic synthesis
of certain type expressions, allowing generic notations for e.g.
equality, pairing, and existential quantification.</li>
</ul>
<p>In the Fall of 1994, C. Paulin-Mohring replaced the structure of
inductively defined types and families by a new structure, allowing the
mutually recursive definitions. P. Manoury implemented a translation of
recursive definitions into the primitive recursive style imposed by the
internal recursion operators, in the style of the ProPre system. C.
Muñoz implemented a decision procedure for intuitionistic propositional
logic, based on results of R. Dyckhoff. J.C. Filliâtre implemented a
decision procedure for first-order logic without contraction, based on
results of J. Ketonen and R. Weyhrauch. Finally C. Murthy implemented a
library of inversion tactics, relieving the user from tedious
definitions of “inversion predicates”.</p>
<div class="line-block">
<div class="line">Rocquencourt, Feb. 1st 1995</div>
<div class="line">Gérard Huet</div>
<div class="line"><br /></div>
</div>
<div class="section" id="credits-addendum-for-version-6-1">
<h1>Credits: addendum for version 6.1<a class="headerlink" href="#credits-addendum-for-version-6-1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>The present version 6.1 of <span class="smallcaps">Coq</span> is based on the V5.10 architecture. It
was ported to the new language Objective Caml by Bruno Barras. The
underlying framework has slightly changed and allows more conversions
between sorts.</p>
<p>The new version provides powerful tools for easier developments.</p>
<p>Cristina Cornes designed an extension of the <span class="smallcaps">Coq</span> syntax to allow
definition of terms using a powerful pattern matching analysis in the
style of ML programs.</p>
<p>Amokrane Saïbi wrote a mechanism to simulate inheritance between types
families extending a proposal by Peter Aczel. He also developed a
mechanism to automatically compute which arguments of a constant may be
inferred by the system and consequently do not need to be explicitly
written.</p>
<p>Yann Coscoy designed a command which explains a proof term using natural
language. Pierre Crégut built a new tactic which solves problems in
quantifier-free Presburger Arithmetic. Both functionalities have been
integrated to the <span class="smallcaps">Coq</span> system by Hugo Herbelin.</p>
<p>Samuel Boutin designed a tactic for simplification of commutative rings
using a canonical set of rewriting rules and equality modulo
associativity and commutativity.</p>
<p>Finally the organisation of the <span class="smallcaps">Coq</span> distribution has been supervised by
Jean-Christophe Filliâtre with the help of Judicaël Courant and Bruno
Barras.</p>
<div class="line-block">
<div class="line">Lyon, Nov. 18th 1996</div>
<div class="line">Christine Paulin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-addendum-for-version-6-2">
<h1>Credits: addendum for version 6.2<a class="headerlink" href="#credits-addendum-for-version-6-2" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>In version 6.2 of <span class="smallcaps">Coq</span>, the parsing is done using camlp4, a preprocessor
and pretty-printer for CAML designed by Daniel de Rauglaudre at INRIA.
Daniel de Rauglaudre made the first adaptation of <span class="smallcaps">Coq</span> for camlp4, this
work was continued by Bruno Barras who also changed the structure of <span class="smallcaps">Coq</span>
abstract syntax trees and the primitives to manipulate them. The result
of these changes is a faster parsing procedure with greatly improved
syntax-error messages. The user-interface to introduce grammar or
pretty-printing rules has also changed.</p>
<p>Eduardo Giménez redesigned the internal tactic libraries, giving uniform
names to Caml functions corresponding to <span class="smallcaps">Coq</span> tactic names.</p>
<p>Bruno Barras wrote new, more efficient reduction functions.</p>
<p>Hugo Herbelin introduced more uniform notations in the <span class="smallcaps">Coq</span> specification
language: the definitions by fixpoints and pattern matching have a more
readable syntax. Patrick Loiseleur introduced user-friendly notations
for arithmetic expressions.</p>
<p>New tactics were introduced: Eduardo Giménez improved the mechanism to
introduce macros for tactics, and designed special tactics for
(co)inductive definitions; Patrick Loiseleur designed a tactic to
simplify polynomial expressions in an arbitrary commutative ring which
generalizes the previous tactic implemented by Samuel Boutin.
Jean-Christophe Filliâtre introduced a tactic for refining a goal, using
a proof term with holes as a proof scheme.</p>
<p>David Delahaye designed the tool to search an object in the library
given its type (up to isomorphism).</p>
<p>Henri Laulhère produced the <span class="smallcaps">Coq</span> distribution for the Windows
environment.</p>
<p>Finally, Hugo Herbelin was the main coordinator of the <span class="smallcaps">Coq</span> documentation
with principal contributions by Bruno Barras, David Delahaye,
Jean-Christophe Filliâtre, Eduardo Giménez, Hugo Herbelin and Patrick
Loiseleur.</p>
<div class="line-block">
<div class="line">Orsay, May 4th 1998</div>
<div class="line">Christine Paulin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-addendum-for-version-6-3">
<h1>Credits: addendum for version 6.3<a class="headerlink" href="#credits-addendum-for-version-6-3" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>The main changes in version V6.3 were the introduction of a few new
tactics and the extension of the guard condition for fixpoint
definitions.</p>
<p>B. Barras extended the unification algorithm to complete partial terms
and fixed various tricky bugs related to universes.</p>
<p>D. Delahaye developed the <code class="docutils literal notranslate"><span class="pre">AutoRewrite</span></code> tactic. He also designed the
new behavior of <code class="docutils literal notranslate"><span class="pre">Intro</span></code> and provided the tacticals <code class="docutils literal notranslate"><span class="pre">First</span></code> and
<code class="docutils literal notranslate"><span class="pre">Solve</span></code>.</p>
<p>J.-C. Filliâtre developed the <code class="docutils literal notranslate"><span class="pre">Correctness</span></code> tactic.</p>
<p>E. Giménez extended the guard condition in fixpoints.</p>
<p>H. Herbelin designed the new syntax for definitions and extended the
<code class="docutils literal notranslate"><span class="pre">Induction</span></code> tactic.</p>
<p>P. Loiseleur developed the <code class="docutils literal notranslate"><span class="pre">Quote</span></code> tactic and the new design of the
<code class="docutils literal notranslate"><span class="pre">Auto</span></code> tactic, he also introduced the index of errors in the
documentation.</p>
<p>C. Paulin wrote the <code class="docutils literal notranslate"><span class="pre">Focus</span></code> command and introduced the reduction
functions in definitions, this last feature was proposed by J.-F.
Monin from CNET Lannion.</p>
<div class="line-block">
<div class="line">Orsay, Dec. 1999</div>
<div class="line">Christine Paulin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-versions-7">
<h1>Credits: versions 7<a class="headerlink" href="#credits-versions-7" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>The version V7 is a new implementation started in September 1999 by
Jean-Christophe Filliâtre. This is a major revision with respect to the
internal architecture of the system. The <span class="smallcaps">Coq</span> version 7.0 was distributed
in March 2001, version 7.1 in September 2001, version 7.2 in January
2002, version 7.3 in May 2002 and version 7.4 in February 2003.</p>
<p>Jean-Christophe Filliâtre designed the architecture of the new system.
He introduced a new representation for environments and wrote a new
kernel for type checking terms. His approach was to use functional
data-structures in order to get more sharing, to prepare the addition of
modules and also to get closer to a certified kernel.</p>
<p>Hugo Herbelin introduced a new structure of terms with local
definitions. He introduced “qualified” names, wrote a new
pattern matching compilation algorithm and designed a more compact
algorithm for checking the logical consistency of universes. He
contributed to the simplification of <span class="smallcaps">Coq</span> internal structures and the
optimisation of the system. He added basic tactics for forward reasoning
and coercions in patterns.</p>
<p>David Delahaye introduced a new language for tactics. General tactics
using pattern matching on goals and context can directly be written from
the <span class="smallcaps">Coq</span> toplevel. He also provided primitives for the design of
user-defined tactics in Caml.</p>
<p>Micaela Mayero contributed the library on real numbers. Olivier
Desmettre extended this library with axiomatic trigonometric functions,
square, square roots, finite sums, Chasles property and basic plane
geometry.</p>
<p>Jean-Christophe Filliâtre and Pierre Letouzey redesigned a new
extraction procedure from <span class="smallcaps">Coq</span> terms to Caml or Haskell programs. This
new extraction procedure, unlike the one implemented in previous version
of <span class="smallcaps">Coq</span> is able to handle all terms in the Calculus of Inductive
Constructions, even involving universes and strong elimination. P.
Letouzey adapted user contributions to extract ML programs when it was
sensible. Jean-Christophe Filliâtre wrote <code class="docutils literal notranslate"><span class="pre">coqdoc</span></code>, a documentation
tool for <span class="smallcaps">Coq</span> libraries usable from version 7.2.</p>
<p>Bruno Barras improved the efficiency of the reduction algorithm and the
confidence level in the correctness of <span class="smallcaps">Coq</span> critical type checking
algorithm.</p>
<p>Yves Bertot designed the <code class="docutils literal notranslate"><span class="pre">SearchPattern</span></code> and <code class="docutils literal notranslate"><span class="pre">SearchRewrite</span></code> tools
and the support for the pcoq interface
(<a class="reference external" href="http://www-sop.inria.fr/lemme/pcoq/">http://www-sop.inria.fr/lemme/pcoq/</a>).</p>
<p>Micaela Mayero and David Delahaye introduced Field, a decision tactic
for commutative fields.</p>
<p>Christine Paulin changed the elimination rules for empty and singleton
propositional inductive types.</p>
<p>Loïc Pottier developed Fourier, a tactic solving linear inequalities on
real numbers.</p>
<p>Pierre Crégut developed a new, reflection-based version of the Omega
decision procedure.</p>
<p>Claudio Sacerdoti Coen designed an XML output for the <span class="smallcaps">Coq</span> modules to be
used in the Hypertextual Electronic Library of Mathematics (HELM cf
<a class="reference external" href="http://www.cs.unibo.it/helm">http://www.cs.unibo.it/helm</a>).</p>
<p>A library for efficient representation of finite maps using binary trees
contributed by Jean Goubault was integrated in the basic theories.</p>
<p>Pierre Courtieu developed a command and a tactic to reason on the
inductive structure of recursively defined functions.</p>
<p>Jacek Chrząszcz designed and implemented the module system of <span class="smallcaps">Coq</span> whose
foundations are in Judicaël Courant’s PhD thesis.</p>
<p>The development was coordinated by C. Paulin.</p>
<p>Many discussions within the Démons team and the LogiCal project
influenced significantly the design of <span class="smallcaps">Coq</span> especially with J. Courant,
J. Duprat, J. Goubault, A. Miquel, C. Marché, B. Monate and B. Werner.</p>
<p>Intensive users suggested improvements of the system : Y. Bertot, L.
Pottier, L. Théry, P. Zimmerman from INRIA, C. Alvarado, P. Crégut,
J.-F. Monin from France Telecom R &amp; D.</p>
<div class="line-block">
<div class="line">Orsay, May. 2002</div>
<div class="line">Hugo Herbelin &amp; Christine Paulin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-0">
<h1>Credits: version 8.0<a class="headerlink" href="#credits-version-8-0" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Coq version 8 is a major revision of the <span class="smallcaps">Coq</span> proof assistant. First, the
underlying logic is slightly different. The so-called <em>impredicativity</em>
of the sort Set has been dropped. The main reason is that it is
inconsistent with the principle of description which is quite a useful
principle for formalizing mathematics within classical logic. Moreover,
even in an constructive setting, the impredicativity of Set does not add
so much in practice and is even subject of criticism from a large part
of the intuitionistic mathematician community. Nevertheless, the
impredicativity of Set remains optional for users interested in
investigating mathematical developments which rely on it.</p>
<p>Secondly, the concrete syntax of terms has been completely revised. The
main motivations were</p>
<ul class="simple">
<li>a more uniform, purified style: all constructions are now lowercase,
with a functional programming perfume (e.g. abstraction is now
written fun), and more directly accessible to the novice (e.g.
dependent product is now written forall and allows omission of
types). Also, parentheses are no longer mandatory for function
application.</li>
<li>extensibility: some standard notations (e.g. “&lt;” and “&gt;”) were
incompatible with the previous syntax. Now all standard arithmetic
notations (=, +, *, /, &lt;, &lt;=, ... and more) are directly part of the
syntax.</li>
</ul>
<p>Together with the revision of the concrete syntax, a new mechanism of
<em>interpretation scopes</em> permits to reuse the same symbols (typically +,
-, *, /, &lt;, &lt;=) in various mathematical theories without any
ambiguities for <span class="smallcaps">Coq</span>, leading to a largely improved readability of <span class="smallcaps">Coq</span>
scripts. New commands to easily add new symbols are also provided.</p>
<p>Coming with the new syntax of terms, a slight reform of the tactic
language and of the language of commands has been carried out. The
purpose here is a better uniformity making the tactics and commands
easier to use and to remember.</p>
<p>Thirdly, a restructuring and uniformization of the standard library of
Coq has been performed. There is now just one Leibniz equality usable
for all the different kinds of <span class="smallcaps">Coq</span> objects. Also, the set of real
numbers now lies at the same level as the sets of natural and integer
numbers. Finally, the names of the standard properties of numbers now
follow a standard pattern and the symbolic notations for the standard
definitions as well.</p>
<p>The fourth point is the release of <span class="smallcaps">CoqIDE</span>, a new graphical gtk2-based
interface fully integrated with <span class="smallcaps">Coq</span>. Close in style to the Proof General
Emacs interface, it is faster and its integration with <span class="smallcaps">Coq</span> makes
interactive developments more friendly. All mathematical Unicode symbols
are usable within <span class="smallcaps">CoqIDE</span>.</p>
<p>Finally, the module system of <span class="smallcaps">Coq</span> completes the picture of <span class="smallcaps">Coq</span> version
8.0. Though released with an experimental status in the previous version
7.4, it should be considered as a salient feature of the new version.</p>
<p>Besides, <span class="smallcaps">Coq</span> comes with its load of novelties and improvements: new or
improved tactics (including a new tactic for solving first-order
statements), new management commands, extended libraries.</p>
<p>Bruno Barras and Hugo Herbelin have been the main contributors of the
reflection and the implementation of the new syntax. The smart automatic
translator from old to new syntax released with <span class="smallcaps">Coq</span> is also their work
with contributions by Olivier Desmettre.</p>
<p>Hugo Herbelin is the main designer and implementer of the notion of
interpretation scopes and of the commands for easily adding new
notations.</p>
<p>Hugo Herbelin is the main implementer of the restructured standard library.</p>
<p>Pierre Corbineau is the main designer and implementer of the new tactic
for solving first-order statements in presence of inductive types. He is
also the maintainer of the non-domain specific automation tactics.</p>
<p>Benjamin Monate is the developer of the <span class="smallcaps">CoqIDE</span> graphical interface with
contributions by Jean-Christophe Filliâtre, Pierre Letouzey, Claude
Marché and Bruno Barras.</p>
<p>Claude Marché coordinated the edition of the Reference Manual for <span class="smallcaps">Coq</span>
V8.0.</p>
<p>Pierre Letouzey and Jacek Chrząszcz respectively maintained the
extraction tool and module system of <span class="smallcaps">Coq</span>.</p>
<p>Jean-Christophe Filliâtre, Pierre Letouzey, Hugo Herbelin and other
contributors from Sophia-Antipolis and Nijmegen participated in
extending the library.</p>
<p>Julien Narboux built a NSIS-based automatic <span class="smallcaps">Coq</span> installation tool for
the Windows platform.</p>
<p>Hugo Herbelin and Christine Paulin coordinated the development which was
under the responsibility of Christine Paulin.</p>
<div class="line-block">
<div class="line">Palaiseau &amp; Orsay, Apr. 2004</div>
<div class="line">Hugo Herbelin &amp; Christine Paulin</div>
<div class="line">(updated Apr. 2006)</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-1">
<h1>Credits: version 8.1<a class="headerlink" href="#credits-version-8-1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Coq version 8.1 adds various new functionalities.</p>
<p>Benjamin Grégoire implemented an alternative algorithm to check the
convertibility of terms in the <span class="smallcaps">Coq</span> type checker. This alternative
algorithm works by compilation to an efficient bytecode that is
interpreted in an abstract machine similar to Xavier Leroy’s ZINC
machine. Convertibility is performed by comparing the normal forms. This
alternative algorithm is specifically interesting for proofs by
reflection. More generally, it is convenient in case of intensive
computations.</p>
<p>Christine Paulin implemented an extension of inductive types allowing
recursively non uniform parameters. Hugo Herbelin implemented
sort-polymorphism for inductive types (now called template polymorphism).</p>
<p>Claudio Sacerdoti Coen improved the tactics for rewriting on arbitrary
compatible equivalence relations. He also generalized rewriting to
arbitrary transition systems.</p>
<p>Claudio Sacerdoti Coen added new features to the module system.</p>
<p>Benjamin Grégoire, Assia Mahboubi and Bruno Barras developed a new, more
efficient and more general simplification algorithm for rings and
semirings.</p>
<p>Laurent Théry and Bruno Barras developed a new, significantly more
efficient simplification algorithm for fields.</p>
<p>Hugo Herbelin, Pierre Letouzey, Julien Forest, Julien Narboux and
Claudio Sacerdoti Coen added new tactic features.</p>
<p>Hugo Herbelin implemented matching on disjunctive patterns.</p>
<p>New mechanisms made easier the communication between <span class="smallcaps">Coq</span> and external
provers. Nicolas Ayache and Jean-Christophe Filliâtre implemented
connections with the provers cvcl, Simplify and zenon. Hugo Herbelin
implemented an experimental protocol for calling external tools from the
tactic language.</p>
<p>Matthieu Sozeau developed Russell, an experimental language to specify
the behavior of programs with subtypes.</p>
<p>A mechanism to automatically use some specific tactic to solve
unresolved implicit has been implemented by Hugo Herbelin.</p>
<p>Laurent Théry’s contribution on strings and Pierre Letouzey and
Jean-Christophe Filliâtre’s contribution on finite maps have been
integrated to the <span class="smallcaps">Coq</span> standard library. Pierre Letouzey developed a
library about finite sets “à la Objective Caml”. With Jean-Marc Notin,
he extended the library on lists. Pierre Letouzey’s contribution on
rational numbers has been integrated and extended.</p>
<p>Pierre Corbineau extended his tactic for solving first-order statements.
He wrote a reflection-based intuitionistic tautology solver.</p>
<p>Pierre Courtieu, Julien Forest and Yves Bertot added extra support to
reason on the inductive structure of recursively defined functions.</p>
<p>Jean-Marc Notin significantly contributed to the general maintenance of
the system. He also took care of <cite>coqdoc</cite>.</p>
<p>Pierre Castéran contributed to the documentation of (co-)inductive types
and suggested improvements to the libraries.</p>
<p>Pierre Corbineau implemented a declarative mathematical proof language,
usable in combination with the tactic-based style of proof.</p>
<p>Finally, many users suggested improvements of the system through the
Coq-Club mailing list and bug-tracker systems, especially user groups
from INRIA Rocquencourt, Radboud University, University of Pennsylvania
and Yale University.</p>
<div class="line-block">
<div class="line">Palaiseau, July 2006</div>
<div class="line">Hugo Herbelin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-2">
<h1>Credits: version 8.2<a class="headerlink" href="#credits-version-8-2" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Coq version 8.2 adds new features, new libraries and improves on many
various aspects.</p>
<p>Regarding the language of <span class="smallcaps">Coq</span>, the main novelty is the introduction by
Matthieu Sozeau of a package of commands providing Haskell-style typeclasses.
Typeclasses, which come with a few convenient features such as
type-based resolution of implicit arguments, play a new landmark role
in the architecture of <span class="smallcaps">Coq</span> with respect to automation. For
instance, thanks to typeclass support, Matthieu Sozeau could
implement a new resolution-based version of the tactics dedicated to
rewriting on arbitrary transitive relations.</p>
<p>Another major improvement of <span class="smallcaps">Coq</span> 8.2 is the evolution of the arithmetic
libraries and of the tools associated to them. Benjamin Grégoire and
Laurent Théry contributed a modular library for building arbitrarily
large integers from bounded integers while Evgeny Makarov contributed a
modular library of abstract natural and integer arithmetic together
with a few convenient tactics. On his side, Pierre Letouzey made
numerous extensions to the arithmetic libraries on <span class="math notranslate">\(\mathbb{Z}\)</span>
and <span class="math notranslate">\(\mathbb{Q}\)</span>, including extra support for automation in
presence of various number-theory concepts.</p>
<p>Frédéric Besson contributed a reflective tactic based on Krivine-Stengle
Positivstellensatz (the easy way) for validating provability of systems
of inequalities. The platform is flexible enough to support the
validation of any algorithm able to produce a “certificate” for the
Positivstellensatz and this covers the case of Fourier-Motzkin (for
linear systems in <span class="math notranslate">\(\mathbb{Q}\)</span> and <span class="math notranslate">\(\mathbb{R}\)</span>),
Fourier-Motzkin with cutting planes (for linear systems in
<span class="math notranslate">\(\mathbb{Z}\)</span>) and sum-of-squares (for non-linear systems). Evgeny
Makarov made the platform generic over arbitrary ordered rings.</p>
<p>Arnaud Spiwack developed a library of 31-bits machine integers and,
relying on Benjamin Grégoire and Laurent Théry’s library, delivered a
library of unbounded integers in base <span class="math notranslate">\(2^{31}\)</span>. As importantly, he
developed a notion of “retro-knowledge” so as to safely extend the
kernel-located bytecode-based efficient evaluation algorithm of <span class="smallcaps">Coq</span>
version 8.1 to use 31-bits machine arithmetic for efficiently computing
with the library of integers he developed.</p>
<p>Beside the libraries, various improvements were contributed to provide a more
comfortable end-user language and more expressive tactic language. Hugo
Herbelin and Matthieu Sozeau improved the pattern matching compilation
algorithm (detection of impossible clauses in pattern matching,
automatic inference of the return type). Hugo Herbelin, Pierre Letouzey
and Matthieu Sozeau contributed various new convenient syntactic
constructs and new tactics or tactic features: more inference of
redundant information, better unification, better support for proof or
definition by fixpoint, more expressive rewriting tactics, better
support for meta-variables, more convenient notations...</p>
<p>Élie Soubiran improved the module system, adding new features (such as
an “include” command) and making it more flexible and more general. He
and Pierre Letouzey improved the support for modules in the extraction
mechanism.</p>
<p>Matthieu Sozeau extended the Russell language, ending in an convenient
way to write programs of given specifications, Pierre Corbineau extended
the Mathematical Proof Language and the automation tools that
accompany it, Pierre Letouzey supervised and extended various parts of the
standard library, Stéphane Glondu contributed a few tactics and
improvements, Jean-Marc Notin provided help in debugging, general
maintenance and coqdoc support, Vincent Siles contributed extensions of
the Scheme command and of injection.</p>
<p>Bruno Barras implemented the <cite>coqchk</cite> tool: this is a stand-alone
type checker that can be used to certify .vo files. Especially, as this
verifier runs in a separate process, it is granted not to be “hijacked”
by virtually malicious extensions added to <span class="smallcaps">Coq</span>.</p>
<p>Yves Bertot, Jean-Christophe Filliâtre, Pierre Courtieu and Julien
Forest acted as maintainers of features they implemented in previous
versions of <span class="smallcaps">Coq</span>.</p>
<p>Julien Narboux contributed to <span class="smallcaps">CoqIDE</span>. Nicolas Tabareau made the
adaptation of the interface of the old “setoid rewrite” tactic to the
new version. Lionel Mamane worked on the interaction between <span class="smallcaps">Coq</span> and its
external interfaces. With Samuel Mimram, he also helped making <span class="smallcaps">Coq</span>
compatible with recent software tools. Russell O’Connor, Cezary
Kaliszyk, Milad Niqui contributed to improve the libraries of integers,
rational, and real numbers. We also thank many users and partners for
suggestions and feedback, in particular Pierre Castéran and Arthur
Charguéraud, the INRIA Marelle team, Georges Gonthier and the
INRIA-Microsoft Mathematical Components team, the Foundations group at
Radboud university in Nijmegen, reporters of bugs and participants to
the Coq-Club mailing list.</p>
<div class="line-block">
<div class="line">Palaiseau, June 2008</div>
<div class="line">Hugo Herbelin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-3">
<h1>Credits: version 8.3<a class="headerlink" href="#credits-version-8-3" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Coq version 8.3 is before all a transition version with refinements or
extensions of the existing features and libraries and a new tactic nsatz
based on Hilbert’s Nullstellensatz for deciding systems of equations
over rings.</p>
<p>With respect to libraries, the main evolutions are due to Pierre
Letouzey with a rewriting of the library of finite sets FSets and a new
round of evolutions in the modular development of arithmetic (library
Numbers). The reason for making FSets evolve is that the computational
and logical contents were quite intertwined in the original
implementation, leading in some cases to longer computations than
expected and this problem is solved in the new MSets implementation. As
for the modular arithmetic library, it was only dealing with the basic
arithmetic operators in the former version and its current extension
adds the standard theory of the division, min and max functions, all
made available for free to any implementation of <span class="math notranslate">\(\mathbb{N}\)</span>,
<span class="math notranslate">\(\mathbb{Z}\)</span> or <span class="math notranslate">\(\mathbb{Z}/n\mathbb{Z}\)</span>.</p>
<p>The main other evolutions of the library are due to Hugo Herbelin who
made a revision of the sorting library (including a certified
merge-sort) and to Guillaume Melquiond who slightly revised and cleaned
up the library of reals.</p>
<p>The module system evolved significantly. Besides the resolution of some
efficiency issues and a more flexible construction of module types, Élie
Soubiran brought a new model of name equivalence, the
<span class="math notranslate">\(\Delta\)</span>-equivalence, which respects as much as possible the names
given by the users. He also designed with Pierre Letouzey a new,
convenient operator <code class="docutils literal notranslate"><span class="pre">&lt;+</span></code> for nesting functor application that
provides a light notation for inheriting the properties of cascading
modules.</p>
<p>The new tactic nsatz is due to Loïc Pottier. It works by computing
Gröbner bases. Regarding the existing tactics, various improvements have
been done by Matthieu Sozeau, Hugo Herbelin and Pierre Letouzey.</p>
<p>Matthieu Sozeau extended and refined the typeclasses and Program
features (the Russell language). Pierre Letouzey maintained and improved
the extraction mechanism. Bruno Barras and Élie Soubiran maintained the
Coq checker, Julien Forest maintained the Function mechanism for
reasoning over recursively defined functions. Matthieu Sozeau, Hugo
Herbelin and Jean-Marc Notin maintained coqdoc. Frédéric Besson
maintained the Micromega platform for deciding systems of inequalities.
Pierre Courtieu maintained the support for the Proof General Emacs
interface. Claude Marché maintained the plugin for calling external
provers (dp). Yves Bertot made some improvements to the libraries of
lists and integers. Matthias Puech improved the search functions.
Guillaume Melquiond usefully contributed here and there. Yann
Régis-Gianas grounded the support for Unicode on a more standard and
more robust basis.</p>
<p>Though invisible from outside, Arnaud Spiwack improved the general
process of management of existential variables. Pierre Letouzey and
Stéphane Glondu improved the compilation scheme of the <span class="smallcaps">Coq</span> archive.
Vincent Gross provided support to <span class="smallcaps">CoqIDE</span>. Jean-Marc Notin provided
support for benchmarking and archiving.</p>
<p>Many users helped by reporting problems, providing patches, suggesting
improvements or making useful comments, either on the bug tracker or on
the Coq-Club mailing list. This includes but not exhaustively Cédric
Auger, Arthur Charguéraud, François Garillot, Georges Gonthier, Robin
Green, Stéphane Lescuyer, Eelis van der Weegen,&nbsp;...</p>
<p>Though not directly related to the implementation, special thanks are
going to Yves Bertot, Pierre Castéran, Adam Chlipala, and Benjamin
Pierce for the excellent teaching materials they provided.</p>
<div class="line-block">
<div class="line">Paris, April 2010</div>
<div class="line">Hugo Herbelin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-4">
<h1>Credits: version 8.4<a class="headerlink" href="#credits-version-8-4" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Coq version 8.4 contains the result of three long-term projects: a new
modular library of arithmetic by Pierre Letouzey, a new proof engine by
Arnaud Spiwack and a new communication protocol for <span class="smallcaps">CoqIDE</span> by Vincent
Gross.</p>
<p>The new modular library of arithmetic extends, generalizes and unifies
the existing libraries on Peano arithmetic (types nat, N and BigN),
positive arithmetic (type positive), integer arithmetic (Z and BigZ) and
machine word arithmetic (type Int31). It provides with unified notations
(e.g. systematic use of add and mul for denoting the addition and
multiplication operators), systematic and generic development of
operators and properties of these operators for all the types mentioned
above, including gcd, pcm, power, square root, base 2 logarithm,
division, modulo, bitwise operations, logical shifts, comparisons,
iterators, ...</p>
<p>The most visible feature of the new proof engine is the support for
structured scripts (bullets and proof brackets) but, even if yet not
user-available, the new engine also provides the basis for refining
existential variables using tactics, for applying tactics to several
goals simultaneously, for reordering goals, all features which are
planned for the next release. The new proof engine forced Pierre Letouzey
to reimplement info and Show Script differently.</p>
<p>Before version 8.4, <span class="smallcaps">CoqIDE</span> was linked to <span class="smallcaps">Coq</span> with the graphical
interface living in a separate thread. From version 8.4, <span class="smallcaps">CoqIDE</span> is a
separate process communicating with <span class="smallcaps">Coq</span> through a textual channel. This
allows for a more robust interfacing, the ability to interrupt <span class="smallcaps">Coq</span>
without interrupting the interface, and the ability to manage several
sessions in parallel. Relying on the infrastructure work made by Vincent
Gross, Pierre Letouzey, Pierre Boutillier and Pierre-Marie Pédrot
contributed many various refinements of <span class="smallcaps">CoqIDE</span>.</p>
<p>Coq 8.4 also comes with a bunch of various smaller-scale changes
and improvements regarding the different components of the system.</p>
<p>The underlying logic has been extended with <span class="math notranslate">\(\eta\)</span>-conversion
thanks to Hugo Herbelin, Stéphane Glondu and Benjamin Grégoire. The
addition of <span class="math notranslate">\(\eta\)</span>-conversion is justified by the confidence that
the formulation of the Calculus of Inductive Constructions based on
typed equality (such as the one considered in Lee and Werner to build a
set-theoretic model of CIC&nbsp;<a class="reference internal" href="zebibliography.html#leewerner11" id="id1">[LW11]</a>) is
applicable to the concrete implementation of <span class="smallcaps">Coq</span>.</p>
<p>The underlying logic benefited also from a refinement of the guard
condition for fixpoints by Pierre Boutillier, the point being that it is
safe to propagate the information about structurally smaller arguments
through <span class="math notranslate">\(\beta\)</span>-redexes that are blocked by the “match”
construction (blocked commutative cuts).</p>
<p>Relying on the added permissiveness of the guard condition, Hugo
Herbelin could extend the pattern matching compilation algorithm so that
matching over a sequence of terms involving dependencies of a term or of
the indices of the type of a term in the type of other terms is
systematically supported.</p>
<p>Regarding the high-level specification language, Pierre Boutillier
introduced the ability to give implicit arguments to anonymous
functions, Hugo Herbelin introduced the ability to define notations with
several binders (e.g. <code class="docutils literal notranslate"><span class="pre">exists</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z,</span> <span class="pre">P</span></code>), Matthieu Sozeau made the
typeclass inference mechanism more robust and predictable, Enrico
Tassi introduced a command Arguments that generalizes Implicit Arguments
and Arguments Scope for assigning various properties to arguments of
constants. Various improvements in the type inference algorithm were
provided by Matthieu Sozeau and Hugo Herbelin with contributions from
Enrico Tassi.</p>
<p>Regarding tactics, Hugo Herbelin introduced support for referring to
expressions occurring in the goal by pattern in tactics such as set or
destruct. Hugo Herbelin also relied on ideas from Chung-Kil Hur’s Heq
plugin to introduce automatic computation of occurrences to generalize
when using destruct and induction on types with indices. Stéphane Glondu
introduced new tactics constr_eq, is_evar and has_evar to be used
when writing complex tactics. Enrico Tassi added support to fine-tuning
the behavior of simpl. Enrico Tassi added the ability to specify over
which variables of a section a lemma has to be exactly generalized.
Pierre Letouzey added a tactic timeout and the interruptibility of
vm_compute. Bug fixes and miscellaneous improvements of the tactic
language came from Hugo Herbelin, Pierre Letouzey and Matthieu Sozeau.</p>
<p>Regarding decision tactics, Loïc Pottier maintained nsatz, moving in
particular to a typeclass based reification of goals while Frédéric
Besson maintained Micromega, adding in particular support for division.</p>
<p>Regarding vernacular commands, Stéphane Glondu provided new commands to
analyze the structure of type universes.</p>
<p>Regarding libraries, a new library about lists of a given length (called
vectors) has been provided by Pierre Boutillier. A new instance of
finite sets based on Red-Black trees and provided by Andrew Appel has
been adapted for the standard library by Pierre Letouzey. In the library
of real analysis, Yves Bertot changed the definition of <span class="math notranslate">\(\pi\)</span> and
provided a proof of the long-standing fact yet remaining unproved in
this library, namely that <span class="math notranslate">\(sin \frac{\pi}{2} =
1\)</span>.</p>
<p>Pierre Corbineau maintained the Mathematical Proof Language (C-zar).</p>
<p>Bruno Barras and Benjamin Grégoire maintained the call-by-value
reduction machines.</p>
<p>The extraction mechanism benefited from several improvements provided by
Pierre Letouzey.</p>
<p>Pierre Letouzey maintained the module system, with contributions from
Élie Soubiran.</p>
<p>Julien Forest maintained the Function command.</p>
<p>Matthieu Sozeau maintained the setoid rewriting mechanism.</p>
<p>Coq related tools have been upgraded too. In particular, coq_makefile
has been largely revised by Pierre Boutillier. Also, patches from Adam
Chlipala for coqdoc have been integrated by Pierre Boutillier.</p>
<p>Bruno Barras and Pierre Letouzey maintained the <cite>coqchk</cite> checker.</p>
<p>Pierre Courtieu and Arnaud Spiwack contributed new features for using
Coq through Proof General.</p>
<p>The Dp plugin has been removed. Use the plugin provided with Why 3
instead (<a class="reference external" href="http://why3.lri.fr">http://why3.lri.fr</a>).</p>
<p>Under the hood, the <span class="smallcaps">Coq</span> architecture benefited from improvements in
terms of efficiency and robustness, especially regarding universes
management and existential variables management, thanks to Pierre
Letouzey and Yann Régis-Gianas with contributions from Stéphane Glondu
and Matthias Puech. The build system is maintained by Pierre Letouzey
with contributions from Stéphane Glondu and Pierre Boutillier.</p>
<p>A new backtracking mechanism simplifying the task of external interfaces
has been designed by Pierre Letouzey.</p>
<p>The general maintenance was done by Pierre Letouzey, Hugo Herbelin,
Pierre Boutillier, Matthieu Sozeau and Stéphane Glondu with also
specific contributions from Guillaume Melquiond, Julien Narboux and
Pierre-Marie Pédrot.</p>
<p>Packaging tools were provided by Pierre Letouzey (Windows), Pierre
Boutillier (MacOS), Stéphane Glondu (Debian). Releasing, testing and
benchmarking support was provided by Jean-Marc Notin.</p>
<p>Many suggestions for improvements were motivated by feedback from users,
on either the bug tracker or the Coq-Club mailing list. Special thanks
are going to the users who contributed patches, starting with Tom
Prince. Other patch contributors include Cédric Auger, David Baelde, Dan
Grayson, Paolo Herms, Robbert Krebbers, Marc Lasson, Hendrik Tews and
Eelis van der Weegen.</p>
<div class="line-block">
<div class="line">Paris, December 2011</div>
<div class="line">Hugo Herbelin</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-5">
<h1>Credits: version 8.5<a class="headerlink" href="#credits-version-8-5" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Coq version 8.5 contains the result of five specific long-term projects:</p>
<ul class="simple">
<li>A new asynchronous evaluation and compilation mode by Enrico Tassi
with help from Bruno Barras and Carst Tankink.</li>
<li>Full integration of the new proof engine by Arnaud Spiwack helped by
Pierre-Marie Pédrot,</li>
<li>Addition of conversion and reduction based on native compilation by
Maxime Dénès and Benjamin Grégoire.</li>
<li>Full universe polymorphism for definitions and inductive types by
Matthieu Sozeau.</li>
<li>An implementation of primitive projections with
<span class="math notranslate">\(\eta\)</span>-conversion bringing significant performance improvements
when using records by Matthieu Sozeau.</li>
</ul>
<p>The full integration of the proof engine, by Arnaud Spiwack and
Pierre-Marie Pédrot, brings to primitive tactics and the user level Ltac
language dependent subgoals, deep backtracking and multiple goal
handling, along with miscellaneous features and an improved potential
for future modifications. Dependent subgoals allow statements in a goal
to mention the proof of another. Proofs of unsolved subgoals appear as
existential variables. Primitive backtracking makes it possible to write
a tactic with several possible outcomes which are tried successively
when subsequent tactics fail. Primitives are also available to control
the backtracking behavior of tactics. Multiple goal handling paves the
way for smarter automation tactics. It is currently used for simple goal
manipulation such as goal reordering.</p>
<p>The way <span class="smallcaps">Coq</span> processes a document in batch and interactive mode has been
redesigned by Enrico Tassi with help from Bruno Barras. Opaque proofs,
the text between Proof and Qed, can be processed asynchronously,
decoupling the checking of definitions and statements from the checking
of proofs. It improves the responsiveness of interactive development,
since proofs can be processed in the background. Similarly, compilation
of a file can be split into two phases: the first one checking only
definitions and statements and the second one checking proofs. A file
resulting from the first phase&nbsp;–&nbsp;with the .vio extension&nbsp;–&nbsp;can be
already Required. All .vio files can be turned into complete .vo files
in parallel. The same infrastructure also allows terminating tactics to
be run in parallel on a set of goals via the <code class="docutils literal notranslate"><span class="pre">par:</span></code> goal selector.</p>
<p><span class="smallcaps">CoqIDE</span> was modified to cope with asynchronous checking of the document.
Its source code was also made separate from that of <span class="smallcaps">Coq</span>, so that <span class="smallcaps">CoqIDE</span>
no longer has a special status among user interfaces, paving the way for
decoupling its release cycle from that of <span class="smallcaps">Coq</span> in the future.</p>
<p>Carst Tankink developed a <span class="smallcaps">Coq</span> back-end for user interfaces built on
Makarius Wenzel’s Prover IDE framework (PIDE), like PIDE/jEdit (with
help from Makarius Wenzel) or PIDE/Coqoon (with help from Alexander
Faithfull and Jesper Bengtson). The development of such features was
funded by the Paral-ITP French ANR project.</p>
<p>The full universe polymorphism extension was designed by Matthieu
Sozeau. It conservatively extends the universes system and core calculus
with definitions and inductive declarations parameterized by universes
and constraints. It is based on a modification of the kernel
architecture to handle constraint checking only, leaving the generation
of constraints to the refinement/type inference engine. Accordingly,
tactics are now fully universe aware, resulting in more localized error
messages in case of inconsistencies and allowing higher-level algorithms
like unification to be entirely type safe. The internal representation
of universes has been modified but this is invisible to the user.</p>
<p>The underlying logic has been extended with <span class="math notranslate">\(\eta\)</span>-conversion for
records defined with primitive projections by Matthieu Sozeau. This
additional form of <span class="math notranslate">\(\eta\)</span>-conversion is justified using the same
principle than the previously added <span class="math notranslate">\(\eta\)</span>-conversion for function
types, based on formulations of the Calculus of Inductive Constructions
with typed equality. Primitive projections, which do not carry the
parameters of the record and are rigid names (not defined as a
pattern matching construct), make working with nested records more
manageable in terms of time and space consumption. This extension and
universe polymorphism were carried out partly while Matthieu Sozeau was
working at the IAS in Princeton.</p>
<p>The guard condition has been made compliant with extensional equality
principles such as propositional extensionality and univalence, thanks
to Maxime Dénès and Bruno Barras. To ensure compatibility with the
univalence axiom, a new flag “-indices-matter” has been implemented,
taking into account the universe levels of indices when computing the
levels of inductive types. This supports using <span class="smallcaps">Coq</span> as a tool to explore
the relations between homotopy theory and type theory.</p>
<p>Maxime Dénès and Benjamin Grégoire developed an implementation of
conversion test and normal form computation using the OCaml native
compiler. It complements the virtual machine conversion offering much
faster computation for expensive functions.</p>
<p>Coq 8.5 also comes with a bunch of many various smaller-scale changes
and improvements regarding the different components of the system. We
shall only list a few of them.</p>
<p>Pierre Boutillier developed an improved tactic for simplification of
expressions called cbn.</p>
<p>Maxime Dénès maintained the bytecode-based reduction machine. Pierre
Letouzey maintained the extraction mechanism.</p>
<p>Pierre-Marie Pédrot has extended the syntax of terms to, experimentally,
allow holes in terms to be solved by a locally specified tactic.</p>
<p>Existential variables are referred to by identifiers rather than mere
numbers, thanks to Hugo Herbelin who also improved the tactic language
here and there.</p>
<p>Error messages for universe inconsistencies have been improved by
Matthieu Sozeau. Error messages for unification and type inference
failures have been improved by Hugo Herbelin, Pierre-Marie Pédrot and
Arnaud Spiwack.</p>
<p>Pierre Courtieu contributed new features for using <span class="smallcaps">Coq</span> through Proof
General and for better interactive experience (bullets, Search, etc).</p>
<p>The efficiency of the whole system has been significantly improved
thanks to contributions from Pierre-Marie Pédrot.</p>
<p>A distribution channel for <span class="smallcaps">Coq</span> packages using the OPAM tool has been
initiated by Thomas Braibant and developed by Guillaume Claret, with
contributions by Enrico Tassi and feedback from Hugo Herbelin.</p>
<p>Packaging tools were provided by Pierre Letouzey and Enrico Tassi
(Windows), Pierre Boutillier, Matthieu Sozeau and Maxime Dénès (MacOS
X). Maxime Dénès improved significantly the testing and benchmarking
support.</p>
<p>Many power users helped to improve the design of the new features via
the bug tracker, the coq development mailing list or the Coq-Club
mailing list. Special thanks are going to the users who contributed
patches and intensive brain-storming, starting with Jason Gross,
Jonathan Leivent, Greg Malecha, Clément Pit-Claudel, Marc Lasson, Lionel
Rieg. It would however be impossible to mention with precision all names
of people who to some extent influenced the development.</p>
<p>Version 8.5 is one of the most important releases of <span class="smallcaps">Coq</span>. Its development
spanned over about 3 years and a half with about one year of
beta-testing. General maintenance during part or whole of this period
has been done by Pierre Boutillier, Pierre Courtieu, Maxime Dénès, Hugo
Herbelin, Pierre Letouzey, Guillaume Melquiond, Pierre-Marie Pédrot,
Matthieu Sozeau, Arnaud Spiwack, Enrico Tassi as well as Bruno Barras,
Yves Bertot, Frédéric Besson, Xavier Clerc, Pierre Corbineau,
Jean-Christophe Filliâtre, Julien Forest, Sébastien Hinderer, Assia
Mahboubi, Jean-Marc Notin, Yann Régis-Gianas, François Ripault, Carst
Tankink. Maxime Dénès coordinated the release process.</p>
<div class="line-block">
<div class="line">Paris, January 2015, revised December 2015,</div>
<div class="line">Hugo Herbelin, Matthieu Sozeau and the <span class="smallcaps">Coq</span> development team</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-6">
<h1>Credits: version 8.6<a class="headerlink" href="#credits-version-8-6" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Coq version 8.6 contains the result of refinements, stabilization of
8.5’s features and cleanups of the internals of the system. Over the
year of (now time-based) development, about 450 bugs were resolved and
over 100 contributions integrated. The main user visible changes are:</p>
<ul class="simple">
<li>A new, faster state-of-the-art universe constraint checker, by
Jacques-Henri Jourdan.</li>
<li>In <span class="smallcaps">CoqIDE</span> and other asynchronous interfaces, more fine-grained
asynchronous processing and error reporting by Enrico Tassi, making
<span class="smallcaps">Coq</span> capable of recovering from errors and continue processing the
document.</li>
<li>More access to the proof engine features from Ltac: goal management
primitives, range selectors and a <code class="docutils literal notranslate"><span class="pre">typeclasses</span> <span class="pre">eauto</span></code> engine handling
multiple goals and multiple successes, by Cyprien Mangin, Matthieu
Sozeau and Arnaud Spiwack.</li>
<li>Tactic behavior uniformization and specification, generalization of
intro-patterns by Hugo Herbelin and others.</li>
<li>A brand new warning system allowing to control warnings, turn them
into errors or ignore them selectively by Maxime Dénès, Guillaume
Melquiond, Pierre-Marie Pédrot and others.</li>
<li>Irrefutable patterns in abstractions, by Daniel de Rauglaudre.</li>
<li>The ssreflect subterm selection algorithm by Georges Gonthier and
Enrico Tassi is now accessible to tactic writers through the
ssrmatching plugin.</li>
<li>Integration of LtacProf, a profiler for Ltac by Jason Gross, Paul
Steckler, Enrico Tassi and Tobias Tebbi.</li>
</ul>
<p>Coq 8.6 also comes with a bunch of smaller-scale changes and
improvements regarding the different components of the system. We shall
only list a few of them.</p>
<p>The iota reduction flag is now a shorthand for match, fix and cofix
flags controlling the corresponding reduction rules (by Hugo Herbelin
and Maxime Dénès).</p>
<p>Maxime Dénès maintained the native compilation machinery.</p>
<p>Pierre-Marie Pédrot separated the Ltac code from general purpose
tactics, and generalized and rationalized the handling of generic
arguments, allowing to create new versions of Ltac more easily in the
future.</p>
<p>In patterns and terms, &#64;, abbreviations and notations are now
interpreted the same way, by Hugo Herbelin.</p>
<p>Name handling for universes has been improved by Pierre-Marie Pédrot and
Matthieu Sozeau. The minimization algorithm has been improved by
Matthieu Sozeau.</p>
<p>The unifier has been improved by Hugo Herbelin and Matthieu Sozeau,
fixing some incompatibilities introduced in <span class="smallcaps">Coq</span> 8.5. Unification
constraints can now be left floating around and be seen by the user
thanks to a new option. The Keyed Unification mode has been improved by
Matthieu Sozeau.</p>
<p>The typeclass resolution engine and associated proof-search tactic have
been reimplemented on top of the proof-engine monad, providing better
integration in tactics, and new options have been introduced to control
it, by Matthieu Sozeau with help from Théo Zimmermann.</p>
<p>The efficiency of the whole system has been significantly improved
thanks to contributions from Pierre-Marie Pédrot, Maxime Dénès and
Matthieu Sozeau and performance issue tracking by Jason Gross and Paul
Steckler.</p>
<p>Standard library improvements by Jason Gross, Sébastien Hinderer, Pierre
Letouzey and others.</p>
<p>Emilio Jesús Gallego Arias contributed many cleanups and refactorings of
the pretty-printing and user interface communication components.</p>
<p>Frédéric Besson maintained the micromega tactic.</p>
<p>The OPAM repository for <span class="smallcaps">Coq</span> packages has been maintained by Guillaume
Claret, Guillaume Melquiond, Matthieu Sozeau, Enrico Tassi and others. A
list of packages is now available at <a class="reference external" href="https://coq.inria.fr/opam/www/">https://coq.inria.fr/opam/www/</a>.</p>
<p>Packaging tools and software development kits were prepared by Michael
Soegtrop with the help of Maxime Dénès and Enrico Tassi for Windows, and
Maxime Dénès and Matthieu Sozeau for MacOS X. Packages are now regularly
built on the continuous integration server. <span class="smallcaps">Coq</span> now comes with a META
file usable with ocamlfind, contributed by Emilio Jesús Gallego Arias,
Gregory Malecha, and Matthieu Sozeau.</p>
<p>Matej Košík maintained and greatly improved the continuous integration
setup and the testing of <span class="smallcaps">Coq</span> contributions. He also contributed many API
improvements and code cleanups throughout the system.</p>
<p>The contributors for this version are Bruno Barras, C.J. Bell, Yves
Bertot, Frédéric Besson, Pierre Boutillier, Tej Chajed, Guillaume
Claret, Xavier Clerc, Pierre Corbineau, Pierre Courtieu, Maxime Dénès,
Ricky Elrod, Emilio Jesús Gallego Arias, Jason Gross, Hugo Herbelin,
Sébastien Hinderer, Jacques-Henri Jourdan, Matej Košík, Xavier Leroy,
Pierre Letouzey, Gregory Malecha, Cyprien Mangin, Erik Martin-Dorel,
Guillaume Melquiond, Clément Pit–Claudel, Pierre-Marie Pédrot, Daniel de
Rauglaudre, Lionel Rieg, Gabriel Scherer, Thomas Sibut-Pinote, Matthieu
Sozeau, Arnaud Spiwack, Paul Steckler, Enrico Tassi, Laurent Théry,
Nickolai Zeldovich and Théo Zimmermann. The development process was
coordinated by Hugo Herbelin and Matthieu Sozeau with the help of Maxime
Dénès, who was also in charge of the release process.</p>
<p>Many power users helped to improve the design of the new features via
the bug tracker, the pull request system, the <span class="smallcaps">Coq</span> development mailing
list or the Coq-Club mailing list. Special thanks to the users who
contributed patches and intensive brain-storming and code reviews,
starting with Cyril Cohen, Jason Gross, Robbert Krebbers, Jonathan
Leivent, Xavier Leroy, Gregory Malecha, Clément Pit–Claudel, Gabriel
Scherer and Beta Ziliani. It would however be impossible to mention
exhaustively the names of everybody who to some extent influenced the
development.</p>
<p>Version 8.6 is the first release of <span class="smallcaps">Coq</span> developed on a time-based
development cycle. Its development spanned 10 months from the release of
Coq 8.5 and was based on a public roadmap. To date, it contains more
external contributions than any previous <span class="smallcaps">Coq</span> system. Code reviews were
systematically done before integration of new features, with an
important focus given to compatibility and performance issues, resulting
in a hopefully more robust release than <span class="smallcaps">Coq</span> 8.5.</p>
<p>Coq Enhancement Proposals (CEPs for short) were introduced by Enrico
Tassi to provide more visibility and a discussion period on new
features, they are publicly available <a class="reference external" href="https://github.com/coq/ceps">https://github.com/coq/ceps</a>.</p>
<p>Started during this period, an effort is led by Yves Bertot and Maxime
Dénès to put together a <span class="smallcaps">Coq</span> consortium.</p>
<div class="line-block">
<div class="line">Paris, November 2016,</div>
<div class="line">Matthieu Sozeau and the <span class="smallcaps">Coq</span> development team</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-7">
<h1>Credits: version 8.7<a class="headerlink" href="#credits-version-8-7" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><span class="smallcaps">Coq</span> version 8.7 contains the result of refinements, stabilization of features
and cleanups of the internals of the system along with a few new features. The
main user visible changes are:</p>
<ul class="simple">
<li>New tactics: variants of tactics supporting existential variables eassert,
eenough, etc... by Hugo Herbelin. Tactics extensionality in H and
inversion_sigma by Jason Gross, specialize with ... accepting partial bindings
by Pierre Courtieu.</li>
<li>Cumulative Polymorphic Inductive Types, allowing cumulativity of universes to
go through applied inductive types, by Amin Timany and Matthieu Sozeau.</li>
<li>Integration of the SSReflect plugin and its documentation in the reference
manual, by Enrico Tassi, Assia Mahboubi and Maxime Dénès.</li>
<li>The coq_makefile tool was completely redesigned to improve its maintainability
and the extensibility of generated Makefiles, and to make <cite>_CoqProject</cite> files
more palatable to IDEs by Enrico Tassi.</li>
</ul>
<p><span class="smallcaps">Coq</span> 8.7 involved a large amount of work on cleaning and speeding up the code
base, notably the work of Pierre-Marie Pédrot on making the tactic-level system
insensitive to existential variable expansion, providing a safer API to plugin
writers and making the code more robust. The <cite>dev/doc/changes.txt</cite> file
documents the numerous changes to the implementation and improvements of
interfaces. An effort to provide an official, streamlined API to plugin writers
is in progress, thanks to the work of Matej Košík.</p>
<p>Version 8.7 also comes with a bunch of smaller-scale changes and improvements
regarding the different components of the system. We shall only list a few of
them.</p>
<p>The efficiency of the whole system has been significantly improved thanks to
contributions from Pierre-Marie Pédrot, Maxime Dénès and Matthieu Sozeau and
performance issue tracking by Jason Gross and Paul Steckler.</p>
<p>Thomas Sibut-Pinote and Hugo Herbelin added support for side effect hooks in
cbv, cbn and simpl. The side effects are provided via a plugin available at
<a class="reference external" href="https://github.com/herbelin/reduction-effects/">https://github.com/herbelin/reduction-effects/</a>.</p>
<p>The BigN, BigZ, BigQ libraries are no longer part of the <span class="smallcaps">Coq</span> standard library,
they are now provided by a separate repository <a class="reference external" href="https://github.com/coq/bignums">https://github.com/coq/bignums</a>,
maintained by Pierre Letouzey.</p>
<p>In the Reals library, <cite>IZR</cite> has been changed to produce a compact representation
of integers and real constants are now represented using <cite>IZR</cite> (work by
Guillaume Melquiond).</p>
<p>Standard library additions and improvements by Jason Gross, Pierre Letouzey and
others, documented in the <cite>CHANGES</cite> file.</p>
<p>The mathematical proof language/declarative mode plugin was removed from the
archive.</p>
<p>The OPAM repository for <span class="smallcaps">Coq</span> packages has been maintained by Guillaume Melquiond,
Matthieu Sozeau, Enrico Tassi with contributions from many users. A list of
packages is available at <a class="reference external" href="https://coq.inria.fr/opam/www/">https://coq.inria.fr/opam/www/</a>.</p>
<p>Packaging tools and software development kits were prepared by Michael Soegtrop
with the help of Maxime Dénès and Enrico Tassi for Windows, and Maxime Dénès for
MacOS X. Packages are regularly built on the Travis continuous integration
server.</p>
<p>The contributors for this version are Abhishek Anand, C.J. Bell, Yves Bertot,
Frédéric Besson, Tej Chajed, Pierre Courtieu, Maxime Dénès, Julien Forest,
Gaëtan Gilbert, Jason Gross, Hugo Herbelin, Emilio Jesús Gallego Arias, Ralf
Jung, Matej Košík, Xavier Leroy, Pierre Letouzey, Assia Mahboubi, Cyprien
Mangin, Erik Martin-Dorel, Olivier Marty, Guillaume Melquiond, Sam Pablo Kuper,
Benjamin Pierce, Pierre-Marie Pédrot, Lars Rasmusson, Lionel Rieg, Valentin
Robert, Yann Régis-Gianas, Thomas Sibut-Pinote, Michael Soegtrop, Matthieu
Sozeau, Arnaud Spiwack, Paul Steckler, George Stelle, Pierre-Yves Strub, Enrico
Tassi, Hendrik Tews, Amin Timany, Laurent Théry, Vadim Zaliva and Théo
Zimmermann.</p>
<p>The development process was coordinated by Matthieu Sozeau with the help of
Maxime Dénès, who was also in charge of the release process. Théo Zimmermann is
the maintainer of this release.</p>
<p>Many power users helped to improve the design of the new features via the bug
tracker, the pull request system, the <span class="smallcaps">Coq</span> development mailing list or the
Coq-Club mailing list. Special thanks to the users who contributed patches and
intensive brain-storming and code reviews, starting with Jason Gross, Ralf Jung,
Robbert Krebbers, Xavier Leroy, Clément Pit–Claudel and Gabriel Scherer. It
would however be impossible to mention exhaustively the names of everybody who
to some extent influenced the development.</p>
<p>Version 8.7 is the second release of <span class="smallcaps">Coq</span> developed on a time-based development
cycle. Its development spanned 9 months from the release of <span class="smallcaps">Coq</span> 8.6 and was
based on a public road-map. It attracted many external contributions. Code
reviews and continuous integration testing were systematically used before
integration of new features, with an important focus given to compatibility and
performance issues, resulting in a hopefully more robust release than <span class="smallcaps">Coq</span> 8.6
while maintaining compatibility.</p>
<p><span class="smallcaps">Coq</span> Enhancement Proposals (CEPs for short) and open pull request discussions
were used to discuss publicly the new features.</p>
<p>The <span class="smallcaps">Coq</span> consortium, an organization directed towards users and supporters of the
system, is now upcoming and will rely on Inria’s newly created Foundation.</p>
<div class="line-block">
<div class="line">Paris, August 2017,</div>
<div class="line">Matthieu Sozeau and the <span class="smallcaps">Coq</span> development team</div>
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="credits-version-8-8">
<h1>Credits: version 8.8<a class="headerlink" href="#credits-version-8-8" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p><span class="smallcaps">Coq</span> version 8.8 contains the result of refinements and stabilization of
features and deprecations, cleanups of the internals of the system along
with a few new features. The main user visible changes are:</p>
<ul class="simple">
<li>Kernel: fix a subject reduction failure due to allowing fixpoints
on non-recursive values, by Matthieu Sozeau.
Handling of evars in the VM (the kernel still does not accept evars)
by Pierre-Marie Pédrot.</li>
<li>Notations: many improvements on recursive notations and support for
destructuring patterns in the syntax of notations by Hugo Herbelin.</li>
<li>Proof language: tacticals for profiling, timing and checking success
or failure of tactics by Jason Gross. The focusing bracket <code class="docutils literal notranslate"><span class="pre">{</span></code>
supports single-numbered goal selectors, e.g. <code class="docutils literal notranslate"><span class="pre">2:{</span></code>, by Théo
Zimmermann.</li>
<li>Vernacular: deprecation of commands and more uniform handling of the
<code class="docutils literal notranslate"><span class="pre">Local</span></code> flag, by Vincent Laporte and Maxime Dénès, part of a larger
attribute system overhaul. Experimental <code class="docutils literal notranslate"><span class="pre">Show</span> <span class="pre">Extraction</span></code> command by
Pierre Letouzey. Coercion now accepts <code class="docutils literal notranslate"><span class="pre">Prop</span></code> or <code class="docutils literal notranslate"><span class="pre">Type</span></code> as a source
by Arthur Charguéraud. <code class="docutils literal notranslate"><span class="pre">Export</span></code> modifier for options allowing to
export the option to modules that <code class="docutils literal notranslate"><span class="pre">Import</span></code> and not only <code class="docutils literal notranslate"><span class="pre">Require</span></code>
a module, by Pierre-Marie Pédrot.</li>
<li>Universes: many user-level and API level enhancements: qualified
naming and printing, variance annotations for cumulative inductive
types, more general constraints and enhancements of the minimization
heuristics, interaction with modules by Gaëtan Gilbert, Pierre-Marie
Pédrot and Matthieu Sozeau.</li>
<li>Library: Decimal Numbers library by Pierre Letouzey and various small
improvements.</li>
<li>Documentation: a large community effort resulted in the migration
of the reference manual to the Sphinx documentation tool. The result
is this manual. The new documentation infrastructure (based on Sphinx)
is by Clément Pit-Claudel. The migration was coordinated by Maxime Dénès
and Paul Steckler, with some help of Théo Zimmermann during the
final integration phase. The 14 people who ported the manual are
Calvin Beck, Heiko Becker, Yves Bertot, Maxime Dénès, Richard Ford,
Pierre Letouzey, Assia Mahboubi, Clément Pit-Claudel,
Laurence Rideau, Matthieu Sozeau, Paul Steckler, Enrico Tassi,
Laurent Théry, Nikita Zyuzin.</li>
<li>Tools: experimental <code class="docutils literal notranslate"><span class="pre">-mangle-names</span></code> option to coqtop/coqc for
linting proof scripts, by Jasper Hugunin.</li>
</ul>
<p>On the implementation side, the <code class="docutils literal notranslate"><span class="pre">dev/doc/changes.md</span></code> file
documents the numerous changes to the implementation and improvements of
interfaces. The file provides guidelines on porting a plugin to the new
version.</p>
<p>Version 8.8 also comes with a bunch of smaller-scale changes and
improvements regarding the different components of the system.
Most important ones are documented in the <code class="docutils literal notranslate"><span class="pre">CHANGES</span></code> file.</p>
<p>The efficiency of the whole system has seen improvements thanks to
contributions from Gaëtan Gilbert, Pierre-Marie Pédrot, Maxime Dénès and
Matthieu Sozeau and performance issue tracking by Jason Gross and Paul
Steckler.</p>
<p>The official wiki and the bugtracker of <span class="smallcaps">Coq</span> migrated to the GitHub
platform, thanks to the work of Pierre Letouzey and Théo
Zimmermann. Gaëtan Gilbert, Emilio Jesús Gallego Arias worked on
maintaining and improving the continuous integration system.</p>
<p>The OPAM repository for <span class="smallcaps">Coq</span> packages has been maintained by Guillaume
Melquiond, Matthieu Sozeau, Enrico Tassi with contributions from many
users. A list of packages is available at <a class="reference external" href="https://coq.inria.fr/opam/www">https://coq.inria.fr/opam/www</a>.</p>
<p>The 44 contributors for this version are Yves Bertot, Joachim Breitner, Tej
Chajed, Arthur Charguéraud, Jacques-Pascal Deplaix, Maxime Dénès, Jim Fehrle,
Julien Forest, Yannick Forster, Gaëtan Gilbert, Jason Gross, Samuel Gruetter,
Thomas Hebb, Hugo Herbelin, Jasper Hugunin, Emilio Jesus Gallego Arias, Ralf
Jung, Johannes Kloos, Matej Košík, Robbert Krebbers, Tony Beta Lambda, Vincent
Laporte, Peter LeFanu Lumsdaine, Pierre Letouzey, Farzon Lotfi, Cyprien Mangin,
Guillaume Melquiond, Raphaël Monat, Carl Patenaude Poulin, Pierre-Marie Pédrot,
Clément Pit-Claudel, Matthew Ryan, Matt Quinn, Sigurd Schneider, Bernhard
Schommer, Michael Soegtrop, Matthieu Sozeau, Arnaud Spiwack, Paul Steckler,
Enrico Tassi, Anton Trunov, Martin Vassor, Vadim Zaliva and Théo Zimmermann.</p>
<p>Version 8.8 is the third release of <span class="smallcaps">Coq</span> developed on a time-based
development cycle. Its development spanned 6 months from the release of
<span class="smallcaps">Coq</span> 8.7 and was based on a public roadmap. The development process
was coordinated by Matthieu Sozeau. Maxime Dénès was in charge of the
release process. Théo Zimmermann is the maintainer of this release.</p>
<p>Many power users helped to improve the design of the new features via
the bug tracker, the pull request system, the <span class="smallcaps">Coq</span> development mailing
list or the <a class="reference external" href="mailto:coq-club&#37;&#52;&#48;inria&#46;fr">coq-club<span>&#64;</span>inria<span>&#46;</span>fr</a> mailing list. Special thanks to the users who
contributed patches and intensive brain-storming and code reviews,
starting with Jason Gross, Ralf Jung, Robbert Krebbers and Amin Timany.
It would however be impossible to mention exhaustively the names
of everybody who to some extent influenced the development.</p>
<p>The <span class="smallcaps">Coq</span> consortium, an organization directed towards users and
supporters of the system, is now running and employs Maxime Dénès.
The contacts of the Coq Consortium are Yves Bertot and Maxime Dénès.</p>
<div class="line-block">
<div class="line">Santiago de Chile, March 2018,</div>
<div class="line">Matthieu Sozeau for the <span class="smallcaps">Coq</span> development team</div>
<div class="line"><br /></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="_static/notations.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>