

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The ring and field tactic families &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="Nsatz: tactics for proving equalities in integral domains" href="nsatz.html" />
    <link rel="prev" title="Program" href="program.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="program.html">Program</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The ring and field tactic families</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#what-does-this-tactic-do">What does this tactic do?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-variables-map">The variables map</a></li>
<li class="toctree-l2"><a class="reference internal" href="#is-it-automatic">Is it automatic?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#concrete-usage-in-coq">Concrete usage in Coq</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-a-ring-structure">Adding a ring structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-does-it-work">How does it work?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dealing-with-fields">Dealing with fields</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-a-new-field-structure">Adding a new field structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="#history-of-ring">History of ring</a></li>
<li class="toctree-l2"><a class="reference internal" href="#discussion">Discussion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The ring and field tactic families</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/addendum/ring.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-ring-and-field-tactic-families">
<span id="theringandfieldtacticfamilies"></span><h1>The ring and field tactic families<a class="headerlink" href="#the-ring-and-field-tactic-families" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Bruno Barras, Benjamin Grégoire, Assia Mahboubi, Laurent Théry <a class="footnote-reference" href="#f1" id="id1">[1]</a></td>
</tr>
</tbody>
</table>
<p>This chapter presents the tactics dedicated to dealing with ring and
field equations.</p>
<div class="section" id="what-does-this-tactic-do">
<h2>What does this tactic do?<a class="headerlink" href="#what-does-this-tactic-do" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ring</span></code> does associative-commutative rewriting in ring and semiring
structures. Assume you have two binary functions <span class="math notranslate">\(\oplus\)</span> and
<span class="math notranslate">\(\otimes\)</span> that are associative and commutative, with <span class="math notranslate">\(\oplus\)</span>
distributive on <span class="math notranslate">\(\otimes\)</span>, and two constants 0 and 1 that are unities for
<span class="math notranslate">\(\oplus\)</span> and <span class="math notranslate">\(\otimes\)</span>. A polynomial is an expression built on
variables <span class="math notranslate">\(V_0\)</span>, <span class="math notranslate">\(V_1\)</span>, <span class="math notranslate">\(\dots\)</span> and constants by application
of <span class="math notranslate">\(\oplus\)</span> and <span class="math notranslate">\(\otimes\)</span>.</p>
<p>Let an ordered product be a product of variables <span class="math notranslate">\(V_{i_1} \otimes \dots
\otimes V_{i_n}\)</span> verifying <span class="math notranslate">\(i_1 ≤ i_2 ≤ \dots ≤ i_n\)</span> . Let a monomial be
the product of a constant and an ordered product. We can order the monomials by
the lexicographic order on products of variables. Let a canonical sum be an
ordered sum of monomials that are all different, i.e. each monomial in the sum
is strictly less than the following monomial according to the lexicographic
order. It is an easy theorem to show that every polynomial is equivalent (modulo
the ring properties) to exactly one canonical sum. This canonical sum is called
the normal form of the polynomial. In fact, the actual representation shares
monomials with same prefixes. So what does the <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic do? It normalizes polynomials over
any ring or semiring structure. The basic use of <code class="docutils literal notranslate"><span class="pre">ring</span></code> is to simplify ring
expressions, so that the user does not have to deal manually with the theorems
of associativity and commutativity.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<dl class="last docutils">
<dt>In the ring of integers, the normal form of</dt>
<dd><span class="math notranslate">\(x (3 + yx + 25(1 − z)) + zx\)</span></dd>
<dt>is</dt>
<dd><span class="math notranslate">\(28x + (−24)xz + xxy\)</span>.</dd>
</dl>
</div>
<p><code class="docutils literal notranslate"><span class="pre">ring</span></code> is also able to compute a normal form modulo monomial equalities.
For example, under the hypothesis that <span class="math notranslate">\(2x^2 = yz+1\)</span>, the normal form of
<span class="math notranslate">\(2(x + 1)x − x − zy\)</span> is <span class="math notranslate">\(x+1\)</span>.</p>
</div>
<div class="section" id="the-variables-map">
<h2>The variables map<a class="headerlink" href="#the-variables-map" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>It is frequent to have an expression built with <span class="math notranslate">\(+\)</span> and <span class="math notranslate">\(\times\)</span>,
but rarely on variables only. Let us associate a number to each subterm of a
ring expression in the Gallina language. For example, consider this expression
in the semiring <code class="docutils literal notranslate"><span class="pre">nat</span></code>:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(plus (mult (plus (f (5)) x) x)
      (mult (if b then (4) else (f (3))) (2)))
</pre></div>
</div>
<p>As a ring expression, it has 3 subterms. Give each subterm a number in
an arbitrary order:</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="33%" />
<col width="57%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>0</td>
<td><span class="math notranslate">\(\mapsto\)</span></td>
<td>if b then (4) else (f (3))</td>
</tr>
<tr class="row-even"><td>1</td>
<td><span class="math notranslate">\(\mapsto\)</span></td>
<td>(f (5))</td>
</tr>
<tr class="row-odd"><td>2</td>
<td><span class="math notranslate">\(\mapsto\)</span></td>
<td>x</td>
</tr>
</tbody>
</table>
<p>Then normalize the “abstract” polynomial
<span class="math notranslate">\(((V_1 \otimes V_2 ) \oplus V_2) \oplus (V_0 \otimes 2)\)</span>
In our example the normal form is:
<span class="math notranslate">\((2 \otimes V_0 ) \oplus (V_1 \otimes V_2) \oplus (V_2 \otimes V_2 )\)</span>.
Then substitute the variables by their values in the variables map to
get the concrete normal polynomial:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(plus (mult (2) (if b then (4) else (f (3))))
      (plus (mult (f (5)) x) (mult x x)))
</pre></div>
</div>
</div>
<div class="section" id="is-it-automatic">
<h2>Is it automatic?<a class="headerlink" href="#is-it-automatic" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Yes, building the variables map and doing the substitution after
normalizing is automatically done by the tactic. So you can just
forget this paragraph and use the tactic according to your intuition.</p>
</div>
<div class="section" id="concrete-usage-in-coq">
<h2>Concrete usage in Coq<a class="headerlink" href="#concrete-usage-in-coq" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>ring</span></span></code></dt>
<dd></dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic solves equations upon polynomial expressions of a ring
(or semiring) structure. It proceeds by normalizing both sides
of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation, rewriting of monomials) and
comparing syntactically the results.</p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span></span></code></dt>
<dd></dd></dl>

<p><code class="docutils literal notranslate"><span class="pre">ring_simplify</span></code> applies the normalization procedure described above to
the given terms. The tactic then replaces all occurrences of the terms
given in the conclusion of the goal by their normal forms. If no term
is given, then the conclusion should be an equation and both
sides are normalized. The tactic can also be applied in a hypothesis.</p>
<p>The tactic must be loaded by <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Ring</span></code>. The ring structures
must be declared with the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code> command (see below). The ring of
booleans is predefined; if one wants to use the tactic on <code class="docutils literal notranslate"><span class="pre">nat</span></code> one must
first require the module <code class="docutils literal notranslate"><span class="pre">ArithRing</span></code> exported by <code class="docutils literal notranslate"><span class="pre">Arith</span></code>); for <code class="docutils literal notranslate"><span class="pre">Z</span></code>, do
<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">ZArithRing</span></code> or simply <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">ZArith</span></code>; for <code class="docutils literal notranslate"><span class="pre">N</span></code>, do
<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">NArithRing</span></code> or <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">NArith</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ZArith</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file z_syntax_plugin.cmxs ... done]
[Loading ML file quote_plugin.cmxs ... done]
[Loading ML file newring_plugin.cmxs ... done]
[Loading ML file omega_plugin.cmxs ... done]</span></dd>
<dt><span class="coqdoc-keyword">Open</span><span> </span><span class="coqdoc-keyword">Scope</span><span> </span><span class="coqdoc-var">Z_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span>:</span><span class="coqdoc-var">Z</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;(</span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">b</span><span> + </span><span class="coqdoc-var">c</span><span>) ^ 2 =</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">a</span><span> * </span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">b</span><span> ^ 2 + </span><span class="coqdoc-var">c</span><span> * </span><span class="coqdoc-var">c</span><span> + 2 * </span><span class="coqdoc-var">a</span><span> * </span><span class="coqdoc-var">b</span><span> + 2 * </span><span class="coqdoc-var">a</span><span> * </span><span class="coqdoc-var">c</span><span> + 2 * </span><span class="coqdoc-var">b</span><span> * </span><span class="coqdoc-var">c</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">^ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">^ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">ring</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">Z</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 * </span><span class="coqdoc-var">a</span><span> * </span><span class="coqdoc-var">b</span><span> = 30 -&gt; (</span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">b</span><span>) ^ 2 = </span><span class="coqdoc-var">a</span><span> ^ 2 + </span><span class="coqdoc-var">b</span><span> ^ 2 + 30.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 30</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">^ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">^ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">^ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 30</span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">ring</span><span> [</span><span class="coqdoc-var">H</span><span>].</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>ring</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd></dd></dl>

<p>decides the equality of two terms modulo ring operations and
the equalities defined by the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s.
Each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> has to be a proof of some equality <cite>m = p</cite>, where <cite>m</cite> is a monomial (after “abstraction”), <cite>p</cite> a polynomial and <cite>=</cite> the corresponding equality of the ring structure.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd></dd></dl>

<p>performs the simplification in the hypothesis named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span> <span class="hole">term1</span><span>;</span> <span>ring</span><span>_</span><span>simplify</span> <span class="hole">term2</span></span></code></dt>
<dd></dd></dl>

<p>is not equivalent to</p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span> <span class="hole">term1</span> <span class="hole">term2</span></span></code></dt>
<dd></dd></dl>

<p class="last">In the latter case the variables map
is shared between the two terms, and common subterm <cite>t</cite> of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term1</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">term2</span></span></span></code>
will have the same associated variable number. So the first
alternative should be avoided for terms belonging to the same ring
theory.</p>
</div>
<p>Error messages:</p>
<dl class="exn">
<dt id="coq:exn.not-a-valid-ring-equation">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>a</span> <span>valid</span> <span>ring</span> <span>equation.</span></span></code><a class="headerlink" href="#coq:exn.not-a-valid-ring-equation" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The conclusion of the goal is not provable in the corresponding ring theory.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.arguments-of-ring-simplify-do-not-have-all-the-same-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Arguments</span> <span>of</span> <span>ring</span><span>_</span><span>simplify</span> <span>do</span> <span>not</span> <span>have</span> <span>all</span> <span>the</span> <span>same</span> <span>type.</span></span></code><a class="headerlink" href="#coq:exn.arguments-of-ring-simplify-do-not-have-all-the-same-type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">ring_simplify</span></code> cannot simplify terms of several rings at the same
time. Invoke the tactic once per ring structure.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-find-a-declared-ring-structure-over-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>a</span> <span>declared</span> <span>ring</span> <span>structure</span> <span>over</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-a-declared-ring-structure-over-term" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>No ring has been declared for the type of the terms to be simplified.
Use <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code> first.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-find-a-declared-ring-structure-for-equality-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>a</span> <span>declared</span> <span>ring</span> <span>structure</span> <span>for</span> <span>equality</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-a-declared-ring-structure-for-equality-term" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Same as above in the case of the <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic.</p>
</dd></dl>

</div>
<div class="section" id="adding-a-ring-structure">
<h2>Adding a ring structure<a class="headerlink" href="#adding-a-ring-structure" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Declaring a new ring consists in proving that a ring signature (a
carrier set, an equality, and ring operations: <code class="docutils literal notranslate"><span class="pre">Ring_theory.ring_theory</span></code>
and <code class="docutils literal notranslate"><span class="pre">Ring_theory.semi_ring_theory</span></code>) satisfies the ring axioms. Semi-
rings (rings without + inverse) are also supported. The equality can
be either Leibniz equality, or any relation declared as a setoid (see
<a class="reference internal" href="generalized-rewriting.html#tactics-enabled-on-user-provided-relations"><span class="std std-ref">Tactics enabled on user provided relations</span></a>).
The definitions of ring and semiring (see module <code class="docutils literal notranslate"><span class="pre">Ring_theory</span></code>) are:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">ring_theory</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">mk_rt</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Radd_0_l</span><span>    : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, 0 + </span><span class="coqdoc-var">x</span><span> == </span><span class="coqdoc-var">x</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Radd_sym</span><span>    : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> == </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">x</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Radd_assoc</span><span>  : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>, </span><span class="coqdoc-var">x</span><span> + (</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span>) == (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>) + </span><span class="coqdoc-var">z</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Rmul_1_l</span><span>    : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, 1 * </span><span class="coqdoc-var">x</span><span> == </span><span class="coqdoc-var">x</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Rmul_sym</span><span>    : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">y</span><span> == </span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">x</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Rmul_assoc</span><span>  : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>, </span><span class="coqdoc-var">x</span><span> * (</span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">z</span><span>) == (</span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">y</span><span>) * </span><span class="coqdoc-var">z</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Rdistr_l</span><span>    : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>, (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>) * </span><span class="coqdoc-var">z</span><span> == (</span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">z</span><span>) + (</span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">z</span><span>);</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Rsub_def</span><span>    : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span> - </span><span class="coqdoc-var">y</span><span> == </span><span class="coqdoc-var">x</span><span> + -</span><span class="coqdoc-var">y</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Ropp_def</span><span>    : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> + (- </span><span class="coqdoc-var">x</span><span>) == 0</span><span>
}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 70-71:
&gt; Record ring_theory : Prop := mk_rt {   Radd_0_l    : forall x, 0 + x == x;   Radd_sym    : forall x y, x + y == y + x;   Radd_assoc  : forall x y z, x + (y + z) == (x + y) + z;   Rmul_1_l    : forall x, 1 * x == x;   Rmul_sym    : forall x y, x * y == y * x;   Rmul_assoc  : forall x y z, x * (y * z) == (x * y) * z;   Rdistr_l    : forall x y z, (x + y) * z == (x * z) + (y * z);   Rsub_def    : forall x y, x - y == x + -y;   Ropp_def    : forall x, x + (- x) == 0 }.
&gt;                                                                       ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [constr:operconstr] expected after '=' (in [constr:operconstr]).</span></dd>
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">semi_ring_theory</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">mk_srt</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRadd_0_l</span><span>   : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, 0 + </span><span class="coqdoc-var">n</span><span> == </span><span class="coqdoc-var">n</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRadd_sym</span><span>   : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span> == </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> ;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRadd_assoc</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>, </span><span class="coqdoc-var">n</span><span> + (</span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">p</span><span>) == (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>) + </span><span class="coqdoc-var">p</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRmul_1_l</span><span>   : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, 1*</span><span class="coqdoc-var">n</span><span> == </span><span class="coqdoc-var">n</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRmul_0_l</span><span>   : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, 0*</span><span class="coqdoc-var">n</span><span> == 0;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRmul_sym</span><span>   : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">n</span><span>*</span><span class="coqdoc-var">m</span><span> == </span><span class="coqdoc-var">m</span><span>*</span><span class="coqdoc-var">n</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRmul_assoc</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>, </span><span class="coqdoc-var">n</span><span>*(</span><span class="coqdoc-var">m</span><span>*</span><span class="coqdoc-var">p</span><span>) == (</span><span class="coqdoc-var">n</span><span>*</span><span class="coqdoc-var">m</span><span>)*</span><span class="coqdoc-var">p</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SRdistr_l</span><span>   : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>, (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>)*</span><span class="coqdoc-var">p</span><span> == </span><span class="coqdoc-var">n</span><span>*</span><span class="coqdoc-var">p</span><span> + </span><span class="coqdoc-var">m</span><span>*</span><span class="coqdoc-var">p</span><span>
}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 76-77:
&gt; Record semi_ring_theory : Prop := mk_srt {   SRadd_0_l   : forall n, 0 + n == n;   SRadd_sym   : forall n m, n + m == m + n ;   SRadd_assoc : forall n m p, n + (m + p) == (n + m) + p;   SRmul_1_l   : forall n, 1*n == n;   SRmul_0_l   : forall n, 0*n == 0;   SRmul_sym   : forall n m, n*m == m*n;   SRmul_assoc : forall n m p, n*(m*p) == (n*m)*p;   SRdistr_l   : forall n m p, (n + m)*p == n*p + m*p }.
&gt;                                                                             ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [constr:operconstr] expected after '=' (in [constr:operconstr]).</span></dd>
</dl>
</div>
<p>This implementation of <code class="docutils literal notranslate"><span class="pre">ring</span></code> also features a notion of constant that
can be parameterized. This can be used to improve the handling of
closed expressions when operations are effective. It consists in
introducing a type of <em>coefficients</em> and an implementation of the ring
operations, and a morphism from the coefficient type to the ring
carrier type. The morphism needs not be injective, nor surjective.</p>
<p>As an example, one can consider the real numbers. The set of
coefficients could be the rational numbers, upon which the ring
operations can be implemented. The fact that there exists a morphism
is defined by the following properties:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">ring_morph</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">mkmorph</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">morph0</span><span>    : [</span><span class="coqdoc-var">cO</span><span>] == 0;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">morph1</span><span>    : [</span><span class="coqdoc-var">cI</span><span>] == 1;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">morph_add</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, [</span><span class="coqdoc-var">x</span><span> +! </span><span class="coqdoc-var">y</span><span>] == [</span><span class="coqdoc-var">x</span><span>]+[</span><span class="coqdoc-var">y</span><span>];</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">morph_sub</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, [</span><span class="coqdoc-var">x</span><span> -! </span><span class="coqdoc-var">y</span><span>] == [</span><span class="coqdoc-var">x</span><span>]-[</span><span class="coqdoc-var">y</span><span>];</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">morph_mul</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, [</span><span class="coqdoc-var">x</span><span> *! </span><span class="coqdoc-var">y</span><span>] == [</span><span class="coqdoc-var">x</span><span>]*[</span><span class="coqdoc-var">y</span><span>];</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">morph_opp</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, [-!</span><span class="coqdoc-var">x</span><span>] == -[</span><span class="coqdoc-var">x</span><span>];</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">morph_eq</span><span>  : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span>?=!</span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">true</span><span> -&gt; [</span><span class="coqdoc-var">x</span><span>] == [</span><span class="coqdoc-var">y</span><span>]</span><span>
}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 52-53:
&gt; Record ring_morph : Prop := mkmorph {   morph0    : [cO] == 0;   morph1    : [cI] == 1;   morph_add : forall x y, [x +! y] == [x]+[y];   morph_sub : forall x y, [x -! y] == [x]-[y];   morph_mul : forall x y, [x *! y] == [x]*[y];   morph_opp : forall x, [-!x] == -[x];   morph_eq  : forall x y, x?=!y = true -&gt; [x] == [y] }.
&gt;                                                     ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [constr:lconstr] expected after [vernac:of_type_with_opt_coercion] (in [record_binder_body]).</span></dd>
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">semi_morph</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">mkRmorph</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Smorph0</span><span> : [</span><span class="coqdoc-var">cO</span><span>] == 0;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Smorph1</span><span> : [</span><span class="coqdoc-var">cI</span><span>] == 1;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Smorph_add</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, [</span><span class="coqdoc-var">x</span><span> +! </span><span class="coqdoc-var">y</span><span>] == [</span><span class="coqdoc-var">x</span><span>]+[</span><span class="coqdoc-var">y</span><span>];</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Smorph_mul</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, [</span><span class="coqdoc-var">x</span><span> *! </span><span class="coqdoc-var">y</span><span>] == [</span><span class="coqdoc-var">x</span><span>]*[</span><span class="coqdoc-var">y</span><span>];</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Smorph_eq</span><span>  : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span>?=!</span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">true</span><span> -&gt; [</span><span class="coqdoc-var">x</span><span>] == [</span><span class="coqdoc-var">y</span><span>]</span><span>
}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 51-52:
&gt; Record semi_morph : Prop := mkRmorph {   Smorph0 : [cO] == 0;   Smorph1 : [cI] == 1;   Smorph_add : forall x y, [x +! y] == [x]+[y];   Smorph_mul : forall x y, [x *! y] == [x]*[y];   Smorph_eq  : forall x y, x?=!y = true -&gt; [x] == [y] }.
&gt;                                                    ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [constr:lconstr] expected after [vernac:of_type_with_opt_coercion] (in [record_binder_body]).</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">c0</span></code> and <code class="docutils literal notranslate"><span class="pre">cI</span></code> denote the 0 and 1 of the coefficient set, <code class="docutils literal notranslate"><span class="pre">+!</span></code>, <code class="docutils literal notranslate"><span class="pre">*!</span></code>, <code class="docutils literal notranslate"><span class="pre">-!</span></code>
are the implementations of the ring operations, <code class="docutils literal notranslate"><span class="pre">==</span></code> is the equality of
the coefficients, <code class="docutils literal notranslate"><span class="pre">?+!</span></code> is an implementation of this equality, and <code class="docutils literal notranslate"><span class="pre">[x]</span></code>
is a notation for the image of <code class="docutils literal notranslate"><span class="pre">x</span></code> by the ring morphism.</p>
<p>Since <code class="docutils literal notranslate"><span class="pre">Z</span></code> is an initial ring (and <code class="docutils literal notranslate"><span class="pre">N</span></code> is an initial semiring), it can
always be considered as a set of coefficients. There are basically
three kinds of (semi-)rings:</p>
<dl class="docutils">
<dt>abstract rings</dt>
<dd>to be used when operations are not effective. The set
of coefficients is <code class="docutils literal notranslate"><span class="pre">Z</span></code> (or <code class="docutils literal notranslate"><span class="pre">N</span></code> for semirings).</dd>
<dt>computational rings</dt>
<dd>to be used when operations are effective. The
set of coefficients is the ring itself. The user only has to provide
an implementation for the equality.</dd>
<dt>customized ring</dt>
<dd>for other cases. The user has to provide the
coefficient set and the morphism.</dd>
</dl>
<p>This implementation of ring can also recognize simple power
expressions as ring expressions. A power function is specified by the
following property:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">POWER</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">Cpow</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">Cpow is declared</span></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">Cp_phi</span><span> : </span><span class="coqdoc-var">N</span><span> -&gt; </span><span class="coqdoc-var">Cpow</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">Cp_phi is declared</span></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">rpow</span><span> : </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">Cpow</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 29-30:
&gt; Variable rpow : R -&gt; Cpow -&gt; R.
&gt;                              ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference R was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">power_theory</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">mkpow_th</span><span> {</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">rpow_pow_N</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">r</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">req</span><span> (</span><span class="coqdoc-var">rpow</span><span> </span><span class="coqdoc-var">r</span><span> (</span><span class="coqdoc-var">Cp_phi</span><span> </span><span class="coqdoc-var">n</span><span>)) (</span><span class="coqdoc-var">pow_N</span><span> </span><span class="coqdoc-var">rI</span><span> </span><span class="coqdoc-var">rmul</span><span> </span><span class="coqdoc-var">r</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
&nbsp;&nbsp;}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 70-73:
&gt; Record power_theory : Prop := mkpow_th {     rpow_pow_N : forall r n, req (rpow r (Cp_phi n)) (pow_N rI rmul r n)   }.
&gt;                                                                       ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference req was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">POWER</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p>The syntax for adding a new ring is</p>
<dl class="cmd">
<dt id="coq:cmd.add-ring">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Add</span> <span>Ring</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <a class="reference internal" href="#grammar-token-ring_mod"><span class="hole">ring_mod</span></a> <span class="repeat-wrapper"><span class="repeat"><span>,</span> <a class="reference internal" href="#grammar-token-ring_mod"><span class="hole">ring_mod</span></a></span><span class="notation-sup">*</span></span> <span>)</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.add-ring" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is not relevant. It is used just for error messages. The
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof that the ring signature satisfies the (semi-)ring
axioms. The optional list of modifiers is used to tailor the behavior
of the tactic. The following list describes their syntax and effects:</p>
<pre>
<strong id="grammar-token-ring_mod">ring_mod</strong> ::=  abstract | decidable <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> | morphism <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
              | setoid <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
              | constants [<code class="xref docutils literal notranslate"><span class="pre">ltac</span></code>]
              | preprocess [<code class="xref docutils literal notranslate"><span class="pre">ltac</span></code>]
              | postprocess [<code class="xref docutils literal notranslate"><span class="pre">ltac</span></code>]
              | power_tac <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> [<code class="xref docutils literal notranslate"><span class="pre">ltac</span></code>]
              | sign <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
              | div <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
</pre>
<dl class="docutils">
<dt>abstract</dt>
<dd>declares the ring as abstract. This is the default.</dd>
<dt>decidable <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt>
<dd>declares the ring as computational. The expression
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is the correctness proof of an equality test <code class="docutils literal notranslate"><span class="pre">?=!</span></code>
(which  hould be evaluable). Its type should be of the form
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">x</span> <span class="pre">y,</span> <span class="pre">x</span> <span class="pre">?=!</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">true</span> <span class="pre">→</span> <span class="pre">x</span> <span class="pre">==</span> <span class="pre">y</span></code>.</dd>
<dt>morphism <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt>
<dd>declares the ring as a customized one. The expression
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof that there exists a morphism between a set of
coefficient and the ring carrier (see <code class="docutils literal notranslate"><span class="pre">Ring_theory.ring_morph</span></code> and
<code class="docutils literal notranslate"><span class="pre">Ring_theory.semi_morph</span></code>).</dd>
<dt>setoid <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt>
<dd>forces the use of given setoid. The first
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof that the equality is indeed a setoid (see
<code class="docutils literal notranslate"><span class="pre">Setoid.Setoid_Theory</span></code>), and the second <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> a proof that the
ring operations are morphisms (see <code class="docutils literal notranslate"><span class="pre">Ring_theory.ring_eq_ext</span></code> and
<code class="docutils literal notranslate"><span class="pre">Ring_theory.sring_eq_ext</span></code>).
This modifier needs not be used if the setoid and morphisms have been
declared.</dd>
<dt>constants [<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code>]</dt>
<dd>specifies a tactic expression <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code> that, given a
term, returns either an object of the coefficient set that is mapped
to the expression via the morphism, or returns
<code class="docutils literal notranslate"><span class="pre">InitialRing.NotConstant</span></code>. The default behavior is to map only 0 and 1
to their counterpart in the coefficient set. This is generally not
desirable for non trivial computational rings.</dd>
<dt>preprocess [<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code>]</dt>
<dd>specifies a tactic <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code> that is applied as a
preliminary step for <code class="docutils literal notranslate"><span class="pre">ring</span></code> and <code class="docutils literal notranslate"><span class="pre">ring_simplify</span></code>. It can be used to
transform a goal so that it is better recognized. For instance, <code class="docutils literal notranslate"><span class="pre">S</span> <span class="pre">n</span></code>
can be changed to <code class="docutils literal notranslate"><span class="pre">plus</span> <span class="pre">1</span> <span class="pre">n</span></code>.</dd>
<dt>postprocess [<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code>]</dt>
<dd>specifies a tactic <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code> that is applied as a final
step for <code class="docutils literal notranslate"><span class="pre">ring_simplify</span></code>. For instance, it can be used to undo
modifications of the preprocessor.</dd>
<dt>power_tac <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> [<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code>]</dt>
<dd>allows <code class="docutils literal notranslate"><span class="pre">ring</span></code> and <code class="docutils literal notranslate"><span class="pre">ring_simplify</span></code> to recognize
power expressions with a constant positive integer exponent (example:
:<span class="math notranslate">\(x^2\)</span> ). The term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof that a given power function satisfies
the specification of a power function (term has to be a proof of
<code class="docutils literal notranslate"><span class="pre">Ring_theory.power_theory</span></code>) and <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">ltac</span></span></span></code> specifies a tactic expression
that, given a term, “abstracts” it into an object of type <code class="docutils literal notranslate"><span class="pre">N</span></code> whose
interpretation via <code class="docutils literal notranslate"><span class="pre">Cp_phi</span></code> (the evaluation function of power
coefficient) is the original term, or returns <code class="docutils literal notranslate"><span class="pre">InitialRing.NotConstant</span></code>
if not a constant coefficient (i.e. <cite>L</cite><sub>tac</sub> is the inverse function of
<code class="docutils literal notranslate"><span class="pre">Cp_phi</span></code>). See files <code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/ZArithRing.v</span></code>
and <code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/RealField.v</span></code> for examples. By default the tactic
does not recognize power expressions as ring expressions.</dd>
<dt>sign <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt>
<dd>allows <code class="docutils literal notranslate"><span class="pre">ring_simplify</span></code> to use a minus operation when
outputting its normal form, i.e writing <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">−</span> <span class="pre">y</span></code> instead of <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">(−</span> <span class="pre">y)</span></code>. The
term <cite>:n:`&#64;term</cite> is a proof that a given sign function indicates expressions
that are signed (<cite>term</cite> has to be a proof of <code class="docutils literal notranslate"><span class="pre">Ring_theory.get_sign</span></code>). See
<code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/InitialRing.v</span></code> for examples of sign function.</dd>
<dt>div <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt>
<dd>allows <code class="docutils literal notranslate"><span class="pre">ring</span></code> and <code class="docutils literal notranslate"><span class="pre">ring_simplify</span></code> to use monomials with
coefficients other than 1 in the rewriting. The term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof
that a given division function satisfies the specification of an
euclidean division function (<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> has to be a proof of
<code class="docutils literal notranslate"><span class="pre">Ring_theory.div_theory</span></code>). For example, this function is called when
trying to rewrite <span class="math notranslate">\(7x\)</span> by <span class="math notranslate">\(2x = z\)</span> to tell that <span class="math notranslate">\(7 = 3 \times 2 + 1\)</span>. See
<code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring/InitialRing.v</span></code> for examples of div function.</dd>
</dl>
<p>Error messages:</p>
<dl class="exn">
<dt id="coq:exn.bad-ring-structure">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Bad</span> <span>ring</span> <span>structure.</span></span></code><a class="headerlink" href="#coq:exn.bad-ring-structure" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The proof of the ring structure provided is not
of the expected type.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.bad-lemma-for-decidability-of-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Bad</span> <span>lemma</span> <span>for</span> <span>decidability</span> <span>of</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.bad-lemma-for-decidability-of-equality" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The equality function
provided in the case of a computational ring has not the expected
type.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.ring-operation-should-be-declared-as-a-morphism">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Ring</span> <span>operation</span> <span>should</span> <span>be</span> <span>declared</span> <span>as</span> <span>a</span> <span>morphism.</span></span></code><a class="headerlink" href="#coq:exn.ring-operation-should-be-declared-as-a-morphism" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>A setoid associated to the carrier of the ring structure has been found,
but the ring operation should be declared as morphism. See <a class="reference internal" href="generalized-rewriting.html#tactics-enabled-on-user-provided-relations"><span class="std std-ref">Tactics enabled on user provided relations</span></a>.</p>
</dd></dl>

</div>
<div class="section" id="how-does-it-work">
<h2>How does it work?<a class="headerlink" href="#how-does-it-work" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The code of <code class="docutils literal notranslate"><span class="pre">ring</span></code> is a good example of a tactic written using <em>reflection</em>.
What is reflection? Basically, using it means that a part of a tactic is written
in Gallina, Coq's language of terms, rather than <cite>L</cite><sub>tac</sub> or <span class="smallcaps">OCaml</span>. From the
philosophical point of view, reflection is using the ability of the Calculus of
Constructions to speak and reason about itself. For the <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic we used
Coq as a programming language and also as a proof environment to build a tactic
and to prove its correctness.</p>
<p>The interested reader is strongly advised to have a look at the
file <code class="docutils literal notranslate"><span class="pre">Ring_polynom.v</span></code>. Here a type for polynomials is defined:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">PExpr</span><span> : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PEc</span><span> : </span><span class="coqdoc-var">C</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PEX</span><span> : </span><span class="coqdoc-var">positive</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PEadd</span><span> : </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PEsub</span><span> : </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PEmul</span><span> : </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PEopp</span><span> : </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PEpow</span><span> : </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">N</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 36-37:
&gt; Inductive PExpr : Type :=   | PEc : C -&gt; PExpr   | PEX : positive -&gt; PExpr   | PEadd : PExpr -&gt; PExpr -&gt; PExpr   | PEsub : PExpr -&gt; PExpr -&gt; PExpr   | PEmul : PExpr -&gt; PExpr -&gt; PExpr   | PEopp : PExpr -&gt; PExpr   | PEpow : PExpr -&gt; N -&gt; PExpr.
&gt;                                     ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference C was not found in the current environment.</span></dd>
</dl>
</div>
<p>Polynomials in normal form are defined as:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Pol</span><span> : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">Pc</span><span> : </span><span class="coqdoc-var">C</span><span> -&gt; </span><span class="coqdoc-var">Pol</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">Pinj</span><span> : </span><span class="coqdoc-var">positive</span><span> -&gt; </span><span class="coqdoc-var">Pol</span><span> -&gt; </span><span class="coqdoc-var">Pol</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">PX</span><span> : </span><span class="coqdoc-var">Pol</span><span> -&gt; </span><span class="coqdoc-var">positive</span><span> -&gt; </span><span class="coqdoc-var">Pol</span><span> -&gt; </span><span class="coqdoc-var">Pol</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 33-34:
&gt; Inductive Pol : Type :=   | Pc : C -&gt; Pol   | Pinj : positive -&gt; Pol -&gt; Pol   | PX : Pol -&gt; positive -&gt; Pol -&gt; Pol.
&gt;                                  ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference C was not found in the current environment.</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Pinj</span> <span class="pre">n</span> <span class="pre">P</span></code> denotes <code class="docutils literal notranslate"><span class="pre">P</span></code> in which <span class="math notranslate">\(V_i\)</span> is replaced by <span class="math notranslate">\(V_{i+n}\)</span> ,
and <code class="docutils literal notranslate"><span class="pre">PX</span> <span class="pre">P</span> <span class="pre">n</span> <span class="pre">Q</span></code> denotes <span class="math notranslate">\(P \otimes V_1^n \oplus Q'\)</span>, <cite>Q'</cite> being <cite>Q</cite> where <span class="math notranslate">\(V_i\)</span> is replaced by <span class="math notranslate">\(V_{i+1}\)</span>.</p>
<p>Variable maps are represented by lists of ring elements, and two
interpretation functions, one that maps a variables map and a
polynomial to an element of the concrete ring, and the second one that
does the same for normal forms:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">PEeval</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> := [...].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 44-45:
&gt; Definition PEeval : list R -&gt; PExpr -&gt; R := [...].
&gt;                                             ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax error: [reduce] expected after ':=' (in [vernac:def_body]).</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">Pphi_dev</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">Pol</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> := [...].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 44-45:
&gt; Definition Pphi_dev : list R -&gt; Pol -&gt; R := [...].
&gt;                                             ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax error: [reduce] expected after ':=' (in [vernac:def_body]).</span></dd>
</dl>
</div>
<p>A function to normalize polynomials is defined, and the big theorem is
its correctness w.r.t interpretation, that is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">norm</span><span> : </span><span class="coqdoc-var">PExpr</span><span> -&gt; </span><span class="coqdoc-var">Pol</span><span> := [...].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 34-35:
&gt; Definition norm : PExpr -&gt; Pol := [...].
&gt;                                   ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax error: [reduce] expected after ':=' (in [vernac:def_body]).</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">Pphi_dev_ok</span><span> :</span><span>
&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">pe</span><span> </span><span class="coqdoc-var">npe</span><span>, </span><span class="coqdoc-var">norm</span><span> </span><span class="coqdoc-var">pe</span><span> = </span><span class="coqdoc-var">npe</span><span> -&gt; </span><span class="coqdoc-var">PEeval</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">pe</span><span> == </span><span class="coqdoc-var">Pphi_dev</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">npe</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 70-71:
&gt; Lemma Pphi_dev_ok :    forall l pe npe, norm pe = npe -&gt; PEeval l pe == Pphi_dev l npe.
&gt;                                                                       ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [constr:operconstr] expected after '=' (in [constr:operconstr]).</span></dd>
</dl>
</div>
<p>So now, what is the scheme for a normalization proof? Let p be the
polynomial expression that the user wants to normalize. First a little
piece of <span class="smallcaps">ML</span> code guesses the type of <cite>p</cite>, the ring theory <cite>T</cite> to use, an
abstract polynomial <cite>ap</cite> and a variables map <cite>v</cite> such that <cite>p</cite> is <span class="math notranslate">\(\beta\delta\iota\)</span>-
equivalent to <code class="docutils literal notranslate"><span class="pre">(PEeval</span></code> <cite>v</cite> <cite>ap</cite><code class="docutils literal notranslate"><span class="pre">)</span></code>. Then we replace it by <code class="docutils literal notranslate"><span class="pre">(Pphi_dev</span></code> <cite>v</cite>
<code class="docutils literal notranslate"><span class="pre">(norm</span></code> <cite>ap</cite><code class="docutils literal notranslate"><span class="pre">))</span></code>, using the main correctness theorem and we reduce it to a
concrete expression <cite>p’</cite>, which is the concrete normal form of <cite>p</cite>. This is summarized in this diagram:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="32%" />
<col width="21%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><cite>p</cite></td>
<td><span class="math notranslate">\(\rightarrow_{\beta\delta\iota}\)</span></td>
<td><code class="docutils literal notranslate"><span class="pre">(PEeval</span></code> <cite>v</cite> <cite>ap</cite><code class="docutils literal notranslate"><span class="pre">)</span></code></td>
</tr>
<tr class="row-even"><td></td>
<td><cite>=</cite><sub>(by the main correctness theorem)</sub></td>
<td></td>
</tr>
<tr class="row-odd"><td><cite>p’</cite></td>
<td><span class="math notranslate">\(\leftarrow_{\beta\delta\iota}\)</span></td>
<td><code class="docutils literal notranslate"><span class="pre">(Pphi_dev</span></code> <cite>v</cite> <code class="docutils literal notranslate"><span class="pre">(norm</span></code> <cite>ap</cite><code class="docutils literal notranslate"><span class="pre">))</span></code></td>
</tr>
</tbody>
</table>
<p>The user does not see the right part of the diagram. From outside, the
tactic behaves like a <span class="math notranslate">\(\beta\delta\iota\)</span> simplification extended with rewriting rules
for associativity and commutativity. Basically, the proof is only the
application of the main correctness theorem to well-chosen arguments.</p>
</div>
<div class="section" id="dealing-with-fields">
<h2>Dealing with fields<a class="headerlink" href="#dealing-with-fields" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>field</span></span></code></dt>
<dd></dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">field</span></code> tactic is an extension of the <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic that deals with rational
expressions. Given a rational expression <span class="math notranslate">\(F = 0\)</span>. It first reduces the
expression <cite>F</cite> to a common denominator <span class="math notranslate">\(N/D = 0\)</span> where <cite>N</cite> and <cite>D</cite>
are two ring expressions. For example, if we take <span class="math notranslate">\(F = (1 − 1/x) x − x + 1\)</span>, this
gives <span class="math notranslate">\(N = (x − 1) x − x^2 + x\)</span> and <span class="math notranslate">\(D = x\)</span>. It then calls ring to solve
<span class="math notranslate">\(N = 0\)</span>.
Note that <code class="docutils literal notranslate"><span class="pre">field</span></code> also generates nonzero conditions for all the
denominators it encounters in the reduction. In our example, it
generates the condition <span class="math notranslate">\(x \neq 0\)</span>. These conditions appear as one subgoal
which is a conjunction if there are several denominators. Nonzero
conditions are always polynomial expressions. For example when
reducing the expression <span class="math notranslate">\(1/(1 + 1/x)\)</span>, two side conditions are
generated: <span class="math notranslate">\(x \neq 0\)</span> and <span class="math notranslate">\(x + 1 \neq 0\)</span>. Factorized expressions are broken since
a field is an integral domain, and when the equality test on
coefficients is complete w.r.t. the equality of the target field,
constants can be proven different from zero automatically.</p>
<p>The tactic must be loaded by <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Field</span></code>. New field
structures can be declared to the system with the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Field</span></code> command
(see below). The field of real numbers is defined in module <code class="docutils literal notranslate"><span class="pre">RealField</span></code>
(in <code class="docutils literal notranslate"><span class="pre">plugins/setoid_ring</span></code>). It is exported by module <code class="docutils literal notranslate"><span class="pre">Rbase</span></code>, so
that requiring <code class="docutils literal notranslate"><span class="pre">Rbase</span></code> or <code class="docutils literal notranslate"><span class="pre">Reals</span></code> is enough to use the field tactics on
real numbers. Rational numbers in canonical form are also declared as
a field in the module <code class="docutils literal notranslate"><span class="pre">Qcanon</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Reals</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file r_syntax_plugin.cmxs ... done]
[Loading ML file fourier_plugin.cmxs ... done]
[Loading ML file micromega_plugin.cmxs ... done]</span></dd>
<dt><span class="coqdoc-keyword">Open</span><span> </span><span class="coqdoc-keyword">Scope</span><span> </span><span class="coqdoc-var">R_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">x</span><span> &lt;&gt; 0 -&gt; (1 - 1 / </span><span class="coqdoc-var">x</span><span>) * </span><span class="coqdoc-var">x</span><span> - </span><span class="coqdoc-var">x</span><span> + 1 = 0.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">field</span><span>; </span><span class="coqdoc-tactic">auto</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">y</span><span> &lt;&gt; 0 -&gt; </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> / </span><span class="coqdoc-var">y</span><span> = 1.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 1</span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-var">H1</span><span>; </span><span class="coqdoc-tactic">field</span><span> [</span><span class="coqdoc-var">H1</span><span>]; </span><span class="coqdoc-tactic">auto</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd><p>decides the equality of two terms modulo
field operations and the equalities defined
by the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s. Each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> has to be a proof of some equality
<cite>m</cite> <code class="docutils literal notranslate"><span class="pre">=</span></code> <cite>p</cite>, where <cite>m</cite> is a monomial (after “abstraction”), <cite>p</cite> a polynomial
and <code class="docutils literal notranslate"><span class="pre">=</span></code> the corresponding equality of the field structure.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">rewriting works with the equality  <cite>m</cite> <code class="docutils literal notranslate"><span class="pre">=</span></code> <cite>p</cite> only if <cite>p</cite> is a polynomial since
rewriting is handled by the underlying ring tactic.</p>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span></span></code></dt>
<dd><p>performs the simplification in the conclusion of the
goal, <span class="math notranslate">\(F_1 = F_2\)</span> becomes <span class="math notranslate">\(N_1 / D_1 = N_2 / D_2\)</span>. A normalization step
(the same as the one for rings) is then applied to <span class="math notranslate">\(N_1\)</span>, <span class="math notranslate">\(D_1\)</span>,
<span class="math notranslate">\(N_2\)</span> and <span class="math notranslate">\(D_2\)</span>. This way, polynomials remain in factorized form during
fraction simplification. This yields smaller expressions when
reducing to the same denominator since common factors can be canceled.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd><p>performs the simplification in the conclusion of the goal using the equalities
defined by the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>performs the simplification in the terms <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">terms</span></span></span></code>  of the conclusion of the goal
using the equalities defined by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s inside the brackets.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>performs the simplification in the assumption <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>performs the simplification
in the assumption <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> using the equalities defined by the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>performs the simplification in the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s of the assumption <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> using the
equalities defined by  the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s inside the brackets.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span></span></code></dt>
<dd><p>performs the simplification in the conclusion of
the goal removing the denominator. <span class="math notranslate">\(F_1 = F_2\)</span> becomes <span class="math notranslate">\(N_1 D_2 = N_2 D_1\)</span>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span></span></code></dt>
<dd><p>performs the simplification in
the conclusion of the goal using the equalities defined by
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>s.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>performs the simplification in the assumption <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>]</span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>performs the simplification in the assumption <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> using the equalities defined by
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">terms</span></span></span></code>s and removing the denominator.</p>
</dd></dl>

</div>
<div class="section" id="adding-a-new-field-structure">
<h2>Adding a new field structure<a class="headerlink" href="#adding-a-new-field-structure" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Declaring a new field consists in proving that a field signature (a
carrier set, an equality, and field operations:
<code class="docutils literal notranslate"><span class="pre">Field_theory.field_theory</span></code> and <code class="docutils literal notranslate"><span class="pre">Field_theory.semi_field_theory</span></code>)
satisfies the field axioms. Semi-fields (fields without + inverse) are
also supported. The equality can be either Leibniz equality, or any
relation declared as a setoid (see <a class="reference internal" href="generalized-rewriting.html#tactics-enabled-on-user-provided-relations"><span class="std std-ref">Tactics enabled on user provided relations</span></a>). The definition of
fields and semifields is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">field_theory</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">mk_field</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">F_R</span><span> : </span><span class="coqdoc-var">ring_theory</span><span> </span><span class="coqdoc-var">rO</span><span> </span><span class="coqdoc-var">rI</span><span> </span><span class="coqdoc-var">radd</span><span> </span><span class="coqdoc-var">rmul</span><span> </span><span class="coqdoc-var">rsub</span><span> </span><span class="coqdoc-var">ropp</span><span> </span><span class="coqdoc-var">req</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">F_1_neq_0</span><span> : ~ 1 == 0;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Fdiv_def</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">q</span><span>, </span><span class="coqdoc-var">p</span><span> / </span><span class="coqdoc-var">q</span><span> == </span><span class="coqdoc-var">p</span><span> * / </span><span class="coqdoc-var">q</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">Finv_l</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">p</span><span>, ~ </span><span class="coqdoc-var">p</span><span> == 0 -&gt;  / </span><span class="coqdoc-var">p</span><span> * </span><span class="coqdoc-var">p</span><span> == 1</span><span>
}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 111-112:
&gt; Record field_theory : Prop := mk_field {   F_R : ring_theory rO rI radd rmul rsub ropp req;   F_1_neq_0 : ~ 1 == 0;   Fdiv_def : forall p q, p / q == p * / q;   Finv_l : forall p, ~ p == 0 -&gt;  / p * p == 1 }.
&gt;                                                                                                                ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [constr:operconstr] expected after '=' (in [constr:operconstr]).</span></dd>
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">semi_field_theory</span><span> : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">mk_sfield</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SF_SR</span><span> : </span><span class="coqdoc-var">semi_ring_theory</span><span> </span><span class="coqdoc-var">rO</span><span> </span><span class="coqdoc-var">rI</span><span> </span><span class="coqdoc-var">radd</span><span> </span><span class="coqdoc-var">rmul</span><span> </span><span class="coqdoc-var">req</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SF_1_neq_0</span><span> : ~ 1 == 0;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SFdiv_def</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">q</span><span>, </span><span class="coqdoc-var">p</span><span> / </span><span class="coqdoc-var">q</span><span> == </span><span class="coqdoc-var">p</span><span> * / </span><span class="coqdoc-var">q</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">SFinv_l</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">p</span><span>, ~ </span><span class="coqdoc-var">p</span><span> == 0 -&gt;  / </span><span class="coqdoc-var">p</span><span> * </span><span class="coqdoc-var">p</span><span> == 1</span><span>
}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 115-116:
&gt; Record semi_field_theory : Prop := mk_sfield {   SF_SR : semi_ring_theory rO rI radd rmul req;   SF_1_neq_0 : ~ 1 == 0;   SFdiv_def : forall p q, p / q == p * / q;   SFinv_l : forall p, ~ p == 0 -&gt;  / p * p == 1 }.
&gt;                                                                                                                    ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [constr:operconstr] expected after '=' (in [constr:operconstr]).</span></dd>
</dl>
</div>
<p>The result of the normalization process is a fraction represented by
the following type:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Record</span><span> </span><span class="coqdoc-var">linear</span><span> : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">mk_linear</span><span> {</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">num</span><span> : </span><span class="coqdoc-var">PExpr</span><span> </span><span class="coqdoc-var">C</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">denum</span><span> : </span><span class="coqdoc-var">PExpr</span><span> </span><span class="coqdoc-var">C</span><span>;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">condition</span><span> : </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">PExpr</span><span> </span><span class="coqdoc-var">C</span><span>)</span><span>
}.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 44-49:
&gt; Record linear : Type := mk_linear {   num : PExpr C;   denum : PExpr C;   condition : list (PExpr C) }.
&gt;                                             ^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference PExpr was not found in the current environment.</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">num</span></code> and <code class="docutils literal notranslate"><span class="pre">denum</span></code> are the numerator and denominator; <code class="docutils literal notranslate"><span class="pre">condition</span></code> is a
list of expressions that have appeared as a denominator during the
normalization process. These expressions must be proven different from
zero for the correctness of the algorithm.</p>
<p>The syntax for adding a new field is</p>
<dl class="cmd">
<dt id="coq:cmd.add-field">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Add</span> <span>Field</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>(</span> <a class="reference internal" href="#grammar-token-field_mod"><span class="hole">field_mod</span></a> <span class="repeat-wrapper"><span class="repeat"><span>,</span> <a class="reference internal" href="#grammar-token-field_mod"><span class="hole">field_mod</span></a></span><span class="notation-sup">*</span></span> <span>)</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.add-field" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is not relevant. It is used just for error
messages. <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof that the field signature satisfies the
(semi-)field axioms. The optional list of modifiers is used to tailor
the behavior of the tactic.</p>
<pre>
<strong id="grammar-token-field_mod">field_mod</strong> ::=  <a class="reference internal" href="#grammar-token-ring_mod"><code class="xref docutils literal notranslate"><span class="pre">ring_mod</span></code></a> | completeness <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
</pre>
<p>Since field tactics are built upon <code class="docutils literal notranslate"><span class="pre">ring</span></code>
tactics, all modifiers of the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code> apply. There is only one
specific modifier:</p>
<dl class="docutils">
<dt>completeness <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></dt>
<dd><p class="first">allows the field tactic to prove automatically
that the image of nonzero coefficients are mapped to nonzero
elements of the field. <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof of</p>
<p><code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">x</span> <span class="pre">y,</span> <span class="pre">[x]</span> <span class="pre">==</span> <span class="pre">[y]</span> <span class="pre">-&gt;</span>&#160; <span class="pre">x</span> <span class="pre">?=!</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">true</span></code>,</p>
<p class="last">which is the completeness of equality on coefficients
w.r.t. the field equality.</p>
</dd>
</dl>
</div>
<div class="section" id="history-of-ring">
<h2>History of ring<a class="headerlink" href="#history-of-ring" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>First Samuel Boutin designed the tactic <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code>. This tactic did lot
of rewriting. But the proofs terms generated by rewriting were too big
for <span class="smallcaps">Coq</span>’s type checker. Let us see why:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ZArith</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Open</span><span> </span><span class="coqdoc-keyword">Scope</span><span> </span><span class="coqdoc-var">Z_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">Z</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">x</span><span> + 3 + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">y</span><span> * </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">x</span><span> + 3 + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span> * </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">Zmult_comm</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>); </span><span class="coqdoc-tactic">reflexivity</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Save</span><span> </span><span class="coqdoc-var">foo</span><span>.</span></dt>
<dd><span class="first last">foo is defined</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">foo</span><span>.</span></dt>
<dd><span class="first">foo = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt;
</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_ind_r</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> z0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_refl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  (</span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">mul_comm</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">

Argument scopes are [Z_scope Z_scope Z_scope]</span></dd>
</dl>
</div>
<p>At each step of rewriting, the whole context is duplicated in the
proof term. Then, a tactic that does hundreds of rewriting generates
huge proof terms. Since <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code> was too slow, Samuel Boutin rewrote
it using reflection (see <a class="reference internal" href="../zebibliography.html#bou97" id="id2">[Bou97]</a>). Later, it
was rewritten by Patrick Loiseleur: the new tactic does not any
more require <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code> to compile and it makes use of <span class="math notranslate">\(\beta\delta\iota\)</span>-reduction not
only to replace the rewriting steps, but also to achieve the
interleaving of computation and reasoning (see <a class="reference internal" href="#discussion-reflection"><span class="std std-ref">Discussion</span></a>). He also wrote
some <span class="smallcaps">ML</span> code for the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Ring</span></code> command that allows registering new rings dynamically.</p>
<p>Proofs terms generated by ring are quite small, they are linear in the
number of <span class="math notranslate">\(\oplus\)</span> and <span class="math notranslate">\(\otimes\)</span> operations in the normalized terms. Type checking
those terms requires some time because it makes a large use of the
conversion rule, but memory requirements are much smaller.</p>
</div>
<div class="section" id="discussion">
<span id="discussion-reflection"></span><h2>Discussion<a class="headerlink" href="#discussion" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Efficiency is not the only motivation to use reflection here. <code class="docutils literal notranslate"><span class="pre">ring</span></code>
also deals with constants, it rewrites for example the expression
<code class="docutils literal notranslate"><span class="pre">34</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">−</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">12</span></code> to the expected result <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">46</span></code>.
For the tactic <code class="docutils literal notranslate"><span class="pre">ACDSimpl</span></code>, the only constants were 0 and 1.
So the expression <code class="docutils literal notranslate"><span class="pre">34</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">(x</span> <span class="pre">−</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">12</span></code>
is interpreted as <span class="math notranslate">\(V_0 \oplus V_1 \otimes (V_2 \ominus 1) \oplus V_3\)</span>,
with the variables mapping
<span class="math notranslate">\(\{V_0 \mapsto 34; V_1 \mapsto 2; V_2 \mapsto x; V_3 \mapsto 12\}\)</span>.
Then it is rewritten to <code class="docutils literal notranslate"><span class="pre">34</span> <span class="pre">−</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">x</span> <span class="pre">+</span> <span class="pre">12</span></code>, very far from the expected result.
Here rewriting is not sufficient: you have to do some kind of reduction
(some kind of computation) to achieve the normalization.</p>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">ring</span></code> is not only faster than the old one: by using
reflection, we get for free the integration of computation and reasoning
that would be very difficult to implement without it.</p>
<p>Is it the ultimate way to write tactics? The answer is: yes and no.
The <code class="docutils literal notranslate"><span class="pre">ring</span></code> tactic intensively uses the conversion rules of the Calculus of
Inductive Constructions, i.e. it replaces proofs by computations as much as possible.
It can be useful in all situations where a classical tactic generates huge proof
terms, like symbolic processing and tautologies. But there
are also tactics like <code class="docutils literal notranslate"><span class="pre">auto</span></code> or <code class="docutils literal notranslate"><span class="pre">linear</span></code> that do many complex computations,
using side-effects and backtracking, and generate a small proof term.
Clearly, it would be significantly less efficient to replace them by
tactics using reflection.</p>
<p>Another idea suggested by Benjamin Werner: reflection could be used to
couple an external tool (a rewriting program or a model checker)
with <span class="smallcaps">Coq</span>. We define (in <span class="smallcaps">Coq</span>) a type of terms, a type of <em>traces</em>, and
prove a correctness theorem that states that <em>replaying traces</em> is safe
with respect to some interpretation. Then we let the external tool do every
computation (using side-effects, backtracking, exception, or others
features that are not available in pure lambda calculus) to produce
the trace. Now we can check in <span class="smallcaps">Coq</span> that the trace has the expected
semantics by applying the correctness theorem.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>based on previous work from Patrick Loiseleur and Samuel Boutin</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="nsatz.html" class="btn btn-neutral float-right" title="Nsatz: tactics for proving equalities in integral domains" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="program.html" class="btn btn-neutral" title="Program" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>