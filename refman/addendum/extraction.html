

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Extraction of programs in OCaml and Haskell &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="Program" href="program.html" />
    <link rel="prev" title="Micromega: tactics for solving arithmetic goals over ordered rings" href="micromega.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#generating-ml-code">Generating ML Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#extraction-options">Extraction Options</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setting-the-target-language">Setting the target language</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inlining-and-optimizations">Inlining and optimizations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extra-elimination-of-useless-arguments">Extra elimination of useless arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#realizing-axioms">Realizing axioms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#realizing-inductive-types">Realizing inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#avoiding-conflicts-with-existing-filenames">Avoiding conflicts with existing filenames</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#differences-between-coq-and-ml-type-systems">Differences between <span class="smallcaps">Coq</span> and ML type systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#some-examples">Some examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-detailed-example-euclidean-division">A detailed example: Euclidean division</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extraction-s-horror-museum">Extraction's horror museum</a></li>
<li class="toctree-l3"><a class="reference internal" href="#users-contributions">Users' Contributions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/addendum/extraction.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="extraction-of-programs-in-ocaml-and-haskell">
<span id="extraction"></span><h1>Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell<a class="headerlink" href="#extraction-of-programs-in-ocaml-and-haskell" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Jean-Christophe Filliâtre and Pierre Letouzey</td>
</tr>
</tbody>
</table>
<p>We present here the <span class="smallcaps">Coq</span> extraction commands, used to build certified
and relatively efficient functional programs, extracting them from
either <span class="smallcaps">Coq</span> functions or <span class="smallcaps">Coq</span> proofs of specifications. The
functional languages available as output are currently <span class="smallcaps">OCaml</span>, Haskell
and Scheme. In the following, &quot;ML&quot; will be used (abusively) to refer
to any of the three.</p>
<p>Before using any of the commands or options described in this chapter,
the extraction framework should first be loaded explicitly
via <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Extraction</span></code>, or via the more robust
<code class="docutils literal notranslate"><span class="pre">From</span> <span class="pre">Coq</span> <span class="pre">Require</span> <span class="pre">Extraction</span></code>.
Note that in earlier versions of Coq, these commands and options were
directly available without any preliminary <code class="docutils literal notranslate"><span class="pre">Require</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Extraction</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">[Loading ML file extraction_plugin.cmxs ... done]</span></dd>
</dl>
</div>
<div class="section" id="generating-ml-code">
<h2>Generating ML Code<a class="headerlink" href="#generating-ml-code" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">In the following, a qualified identifier <cite>qualid</cite>
can be used to refer to any kind of <span class="smallcaps">Coq</span> global &quot;object&quot; : constant,
inductive type, inductive constructor or module name.</p>
</div>
<p>The next two commands are meant to be used for rapid preview of
extraction. They both display extracted term(s) inside <span class="smallcaps">Coq</span>.</p>
<dl class="cmd">
<dt id="coq:cmd.extraction">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmd.extraction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Extraction of the mentioned object in the <span class="smallcaps">Coq</span> toplevel.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.recursive-extraction">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Recursive</span> <span>Extraction</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.recursive-extraction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Recursive extraction of all the mentioned objects and
all their dependencies in the <span class="smallcaps">Coq</span> toplevel.</p>
</dd></dl>

<p>All the following commands produce real ML files. User can choose to
produce one monolithic file or one file per <span class="smallcaps">Coq</span> library.</p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>&quot;</span><span class="hole">file</span><span>&quot;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Recursive extraction of all the mentioned objects and all
their dependencies in one monolithic <cite>file</cite>.
Global and local identifiers are renamed according to the chosen ML
language to fulfill its syntactic conventions, keeping original
names as much as possible.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.extraction-library">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Library</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.extraction-library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Extraction of the whole <span class="smallcaps">Coq</span> library <code class="docutils literal notranslate"><span class="pre">ident.v</span></code> to an ML module
<code class="docutils literal notranslate"><span class="pre">ident.ml</span></code>. In case of name clash, identifiers are here renamed
using prefixes <code class="docutils literal notranslate"><span class="pre">coq_</span></code>  or <code class="docutils literal notranslate"><span class="pre">Coq_</span></code> to ensure a session-independent
renaming.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.recursive-extraction-library">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Recursive</span> <span>Extraction</span> <span>Library</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.recursive-extraction-library" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Extraction of the <span class="smallcaps">Coq</span> library <code class="docutils literal notranslate"><span class="pre">ident.v</span></code> and all other modules
<code class="docutils literal notranslate"><span class="pre">ident.v</span></code> depends on.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.separate-extraction">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Separate</span> <span>Extraction</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.separate-extraction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Recursive extraction of all the mentioned objects and all
their dependencies, just as <code class="docutils literal notranslate"><span class="pre">Extraction</span> <span class="pre">&quot;file&quot;</span></code>,
but instead of producing one monolithic file, this command splits
the produced code in separate ML files, one per corresponding Coq
<code class="docutils literal notranslate"><span class="pre">.v</span></code> file. This command is hence quite similar to
<a class="reference internal" href="#coq:cmd.recursive-extraction-library" title="Recursive Extraction Library"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Recursive</span> <span class="pre">Extraction</span> <span class="pre">Library</span></code></a>, except that only the needed
parts of Coq libraries are extracted instead of the whole.
The naming convention in case of name clash is the same one as
<a class="reference internal" href="#coq:cmd.extraction-library" title="Extraction Library"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extraction</span> <span class="pre">Library</span></code></a>: identifiers are here renamed using prefixes
<code class="docutils literal notranslate"><span class="pre">coq_</span></code>  or <code class="docutils literal notranslate"><span class="pre">Coq_</span></code>.</p>
</dd></dl>

<p>The following command is meant to help automatic testing of
the extraction, see for instance the <code class="docutils literal notranslate"><span class="pre">test-suite</span></code> directory
in the <span class="smallcaps">Coq</span> sources.</p>
<dl class="cmd">
<dt id="coq:cmd.extraction-testcompile">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>TestCompile</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.extraction-testcompile" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>All the mentioned objects and all their dependencies are extracted
to a temporary <span class="smallcaps">OCaml</span> file, just as in <code class="docutils literal notranslate"><span class="pre">Extraction</span> <span class="pre">&quot;file&quot;</span></code>. Then
this temporary file and its signature are compiled with the same
<span class="smallcaps">OCaml</span> compiler used to built <span class="smallcaps">Coq</span>. This command succeeds only
if the extraction and the <span class="smallcaps">OCaml</span> compilation succeed. It fails
if the current target language of the extraction is not <span class="smallcaps">OCaml</span>.</p>
</dd></dl>

</div>
<div class="section" id="extraction-options">
<h2>Extraction Options<a class="headerlink" href="#extraction-options" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="setting-the-target-language">
<h3>Setting the target language<a class="headerlink" href="#setting-the-target-language" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The ability to fix target language is the first and more important
of the extraction options. Default is <code class="docutils literal notranslate"><span class="pre">OCaml</span></code>.</p>
<dl class="cmd">
<dt id="coq:cmd.extraction-language-ocaml">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Language</span> <span>OCaml</span></span></code><a class="headerlink" href="#coq:cmd.extraction-language-ocaml" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmd">
<dt id="coq:cmd.extraction-language-haskell">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Language</span> <span>Haskell</span></span></code><a class="headerlink" href="#coq:cmd.extraction-language-haskell" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmd">
<dt id="coq:cmd.extraction-language-scheme">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Language</span> <span>Scheme</span></span></code><a class="headerlink" href="#coq:cmd.extraction-language-scheme" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="inlining-and-optimizations">
<h3>Inlining and optimizations<a class="headerlink" href="#inlining-and-optimizations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Since <span class="smallcaps">OCaml</span> is a strict language, the extracted code has to
be optimized in order to be efficient (for instance, when using
induction principles we do not want to compute all the recursive calls
but only the needed ones). So the extraction mechanism provides an
automatic optimization routine that will be called each time the user
wants to generate an <span class="smallcaps">OCaml</span> program. The optimizations can be split in two
groups: the type-preserving ones (essentially constant inlining and
reductions) and the non type-preserving ones (some function
abstractions of dummy types are removed when it is deemed safe in order
to have more elegant types). Therefore some constants may not appear in the
resulting monolithic <span class="smallcaps">OCaml</span> program. In the case of modular extraction,
even if some inlining is done, the inlined constants are nevertheless
printed, to ensure session-independent programs.</p>
<p>Concerning Haskell, type-preserving optimizations are less useful
because of laziness. We still make some optimizations, for example in
order to produce more readable code.</p>
<p>The type-preserving optimizations are controlled by the following <span class="smallcaps">Coq</span> options:</p>
<dl class="flag">
<dt id="coq:flag.extraction-optimize">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Optimize</span></span></code><a class="headerlink" href="#coq:flag.extraction-optimize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Default is on. This controls all type-preserving optimizations made on
the ML terms (mostly reduction of dummy beta/iota redexes, but also
simplifications on Cases, etc). Turn this option off if you want a
ML term as close as possible to the Coq term.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.extraction-conservative-types">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Conservative</span> <span>Types</span></span></code><a class="headerlink" href="#coq:flag.extraction-conservative-types" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Default is off. This controls the non type-preserving optimizations
made on ML terms (which try to avoid function abstraction of dummy
types). Turn this option on to make sure that <code class="docutils literal notranslate"><span class="pre">e:t</span></code>
implies that <code class="docutils literal notranslate"><span class="pre">e':t'</span></code> where <code class="docutils literal notranslate"><span class="pre">e'</span></code> and <code class="docutils literal notranslate"><span class="pre">t'</span></code> are the extracted
code of <code class="docutils literal notranslate"><span class="pre">e</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code> respectively.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.extraction-keepsingleton">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>KeepSingleton</span></span></code><a class="headerlink" href="#coq:flag.extraction-keepsingleton" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Default is off. Normally, when the extraction of an inductive type
produces a singleton type (i.e. a type with only one constructor, and
only one argument to this constructor), the inductive structure is
removed and this type is seen as an alias to the inner type.
The typical example is <code class="docutils literal notranslate"><span class="pre">sig</span></code>. This option allows disabling this
optimization when one wishes to preserve the inductive structure of types.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.extraction-autoinline">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>AutoInline</span></span></code><a class="headerlink" href="#coq:flag.extraction-autoinline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Default is on. The extraction mechanism inlines the bodies of
some defined constants, according to some heuristics
like size of bodies, uselessness of some arguments, etc.
Those heuristics are not always perfect; if you want to disable
this feature, turn this option off.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.extraction-inline">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Inline</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.extraction-inline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>In addition to the automatic inline feature, the constants
mentionned by this command will always be inlined during extraction.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.extraction-noinline">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>NoInline</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.extraction-noinline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Conversely, the constants mentionned by this command will
never be inlined during extraction.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.print-extraction-inline">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Extraction</span> <span>Inline</span></span></code><a class="headerlink" href="#coq:cmd.print-extraction-inline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prints the current state of the table recording the custom inlinings
declared by the two previous commands.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.reset-extraction-inline">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Reset</span> <span>Extraction</span> <span>Inline</span></span></code><a class="headerlink" href="#coq:cmd.reset-extraction-inline" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Empties the table recording the custom inlinings (see the
previous commands).</p>
</dd></dl>

<p><strong>Inlining and printing of a constant declaration:</strong></p>
<p>The user can explicitly ask for a constant to be extracted by two means:</p>
<blockquote>
<div><ul class="simple">
<li>by mentioning it on the extraction command line</li>
<li>by extracting the whole <span class="smallcaps">Coq</span> module of this constant.</li>
</ul>
</div></blockquote>
<p>In both cases, the declaration of this constant will be present in the
produced file. But this same constant may or may not be inlined in
the following terms, depending on the automatic/custom inlining mechanism.</p>
<p>For the constants non-explicitly required but needed for dependency
reasons, there are two cases:</p>
<blockquote>
<div><ul class="simple">
<li>If an inlining decision is taken, whether automatically or not,
all occurrences of this constant are replaced by its extracted body,
and this constant is not declared in the generated file.</li>
<li>If no inlining decision is taken, the constant is normally
declared in the produced file.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="extra-elimination-of-useless-arguments">
<h3>Extra elimination of useless arguments<a class="headerlink" href="#extra-elimination-of-useless-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following command provides some extra manual control on the
code elimination performed during extraction, in a way which
is independent but complementary to the main elimination
principles of extraction (logical parts and types).</p>
<dl class="cmd">
<dt id="coq:cmd.extraction-implicit">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Implicit</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>]</span></span></code><a class="headerlink" href="#coq:cmd.extraction-implicit" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This experimental command allows declaring some arguments of
<cite>qualid</cite> as implicit, i.e. useless in extracted code and hence to
be removed by extraction. Here <cite>qualid</cite> can be any function or
inductive constructor, and the given <cite>ident</cite> are the names of
the concerned arguments. In fact, an argument can also be referred
by a number indicating its position, starting from 1.</p>
</dd></dl>

<p>When an actual extraction takes place, an error is normally raised if the
<a class="reference internal" href="#coq:cmd.extraction-implicit" title="Extraction Implicit"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extraction</span> <span class="pre">Implicit</span></code></a> declarations cannot be honored, that is
if any of the implicit arguments still occurs in the final code.
This behavior can be relaxed via the following option:</p>
<dl class="flag">
<dt id="coq:flag.extraction-safeimplicits">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>SafeImplicits</span></span></code><a class="headerlink" href="#coq:flag.extraction-safeimplicits" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Default is on. When this option is off, a warning is emitted
instead of an error if some implicit arguments still occur in the
final code of an extraction. This way, the extracted code may be
obtained nonetheless and reviewed manually to locate the source of the issue
(in the code, some comments mark the location of these remaining implicit arguments).
Note that this extracted code might not compile or run properly,
depending of the use of these remaining implicit arguments.</p>
</dd></dl>

</div>
<div class="section" id="realizing-axioms">
<h3>Realizing axioms<a class="headerlink" href="#realizing-axioms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Extraction will fail if it encounters an informative axiom not realized.
A warning will be issued if it encounters a logical axiom, to remind the
user that inconsistent logical axioms may lead to incorrect or
non-terminating extracted terms.</p>
<p>It is possible to assume some axioms while developing a proof. Since
these axioms can be any kind of proposition or object or type, they may
perfectly well have some computational content. But a program must be
a closed term, and of course the system cannot guess the program which
realizes an axiom.  Therefore, it is possible to tell the system
what ML term corresponds to a given axiom.</p>
<dl class="cmd">
<dt id="coq:cmd.extract-constant">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extract</span> <span>Constant</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>=&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code><a class="headerlink" href="#coq:cmd.extract-constant" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Give an ML extraction for the given constant.
The <cite>string</cite> may be an identifier or a quoted string.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.extract-inlined-constant">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extract</span> <span>Inlined</span> <span>Constant</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>=&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code><a class="headerlink" href="#coq:cmd.extract-inlined-constant" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Same as the previous one, except that the given ML terms will
be inlined everywhere instead of being declared via a <code class="docutils literal notranslate"><span class="pre">let</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">This command is sugar for an <a class="reference internal" href="#coq:cmd.extract-constant" title="Extract Constant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extract</span> <span class="pre">Constant</span></code></a> followed
by a <a class="reference internal" href="#coq:cmd.extraction-inline" title="Extraction Inline"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extraction</span> <span class="pre">Inline</span></code></a>. Hence a <a class="reference internal" href="#coq:cmd.reset-extraction-inline" title="Reset Extraction Inline"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Reset</span> <span class="pre">Extraction</span> <span class="pre">Inline</span></code></a>
will have an effect on the realized and inlined axiom.</p>
</div>
</dd></dl>

<div class="admonition caution">
<p class="first admonition-title">ご用心</p>
<p class="last">It is the responsibility of the user to ensure that the ML
terms given to realize the axioms do have the expected types. In
fact, the strings containing realizing code are just copied to the
extracted files. The extraction recognizes whether the realized axiom
should become a ML type constant or a ML object declaration. For example:</p>
</div>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Set</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">X is declared</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">X</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">x is declared</span></dd>
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-var">Constant</span><span> </span><span class="coqdoc-var">X</span><span> =&gt; &quot;int&quot;.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-var">Constant</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; &quot;0&quot;.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p>Notice that in the case of type scheme axiom (i.e. whose type is an
arity, that is a sequence of product finished by a sort), then some type
variables have to be given (as quoted strings). The syntax is then:</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Extract</span> <span>Constant</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span>...</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span>=&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd></dd></dl>

<p>The number of type variables is checked by the system. For example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">Y</span><span> : </span><span class="coqdoc-keyword">Set</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">Y is declared</span></dd>
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-var">Constant</span><span> </span><span class="coqdoc-var">Y</span><span> &quot;'a&quot; &quot;'b&quot; =&gt; &quot; 'a * 'b &quot;.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p>Realizing an axiom via <a class="reference internal" href="#coq:cmd.extract-constant" title="Extract Constant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extract</span> <span class="pre">Constant</span></code></a> is only useful in the
case of an informative axiom (of sort <code class="docutils literal notranslate"><span class="pre">Type</span></code> or <code class="docutils literal notranslate"><span class="pre">Set</span></code>). A logical axiom
has no computational content and hence will not appear in extracted
terms. But a warning is nonetheless issued if extraction encounters a
logical axiom. This warning reminds user that inconsistent logical
axioms may lead to incorrect or non-terminating extracted terms.</p>
<p>If an informative axiom has not been realized before an extraction, a
warning is also issued and the definition of the axiom is filled with
an exception labeled <code class="docutils literal notranslate"><span class="pre">AXIOM</span> <span class="pre">TO</span> <span class="pre">BE</span> <span class="pre">REALIZED</span></code>. The user must then
search these exceptions inside the extracted file and replace them by
real code.</p>
</div>
<div class="section" id="realizing-inductive-types">
<h3>Realizing inductive types<a class="headerlink" href="#realizing-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The system also provides a mechanism to specify ML terms for inductive
types and constructors. For instance, the user may want to use the ML
native boolean type instead of the <span class="smallcaps">Coq</span> one. The syntax is the following:</p>
<dl class="cmd">
<dt id="coq:cmd.extract-inductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extract</span> <span>Inductive</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>=&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span><span class="notation-sup">+</span></span> <span>]</span></span></code><a class="headerlink" href="#coq:cmd.extract-inductive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Give an ML extraction for the given inductive type. You must specify
extractions for the type itself (first <cite>string</cite>) and all its
constructors (all the <cite>string</cite> between square brackets). In this form,
the ML extraction must be an ML inductive datatype, and the native
pattern matching of the language will be used.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Extract</span> <span>Inductive</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>=&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span><span class="notation-sup">+</span></span> <span>]</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd><p>Same as before, with a final extra <cite>string</cite> that indicates how to
perform pattern matching over this inductive type. In this form,
the ML extraction could be an arbitrary type.
For an inductive type with <cite>k</cite> constructors, the function used to
emulate the pattern matching should expect <cite>(k+1)</cite> arguments, first the <cite>k</cite>
branches in functional form, and then the inductive element to
destruct. For instance, the match branch <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">S</span> <span class="pre">n</span> <span class="pre">=&gt;</span> <span class="pre">foo</span></code> gives the
functional form <code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">n</span> <span class="pre">-&gt;</span> <span class="pre">foo)</span></code>. Note that a constructor with no
arguments is considered to have one unit argument, in order to block
early evaluation of the branch: <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">O</span> <span class="pre">=&gt;</span> <span class="pre">bar</span></code> leads to the functional
form <code class="docutils literal notranslate"><span class="pre">(fun</span> <span class="pre">()</span> <span class="pre">-&gt;</span> <span class="pre">bar)</span></code>. For instance, when extracting <code class="docutils literal notranslate"><span class="pre">nat</span></code>
into <span class="smallcaps">OCaml</span> <code class="docutils literal notranslate"><span class="pre">int</span></code>, the code to be provided has type:
<code class="docutils literal notranslate"><span class="pre">(unit-&gt;'a)-&gt;(int-&gt;'a)-&gt;int-&gt;'a</span></code>.</p>
</dd></dl>

<div class="admonition caution">
<p class="first admonition-title">ご用心</p>
<p>As for <a class="reference internal" href="#coq:cmd.extract-constant" title="Extract Constant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extract</span> <span class="pre">Constant</span></code></a>, this command should be used with care:</p>
<ul class="last simple">
<li>The ML code provided by the user is currently <strong>not</strong> checked at all by
extraction, even for syntax errors.</li>
<li>Extracting an inductive type to a pre-existing ML inductive type
is quite sound. But extracting to a general type (by providing an
ad-hoc pattern matching) will often <strong>not</strong> be fully rigorously
correct. For instance, when extracting <code class="docutils literal notranslate"><span class="pre">nat</span></code> to <span class="smallcaps">OCaml</span> <code class="docutils literal notranslate"><span class="pre">int</span></code>,
it is theoretically possible to build <code class="docutils literal notranslate"><span class="pre">nat</span></code> values that are
larger than <span class="smallcaps">OCaml</span> <code class="docutils literal notranslate"><span class="pre">max_int</span></code>. It is the user's responsibility to
be sure that no overflow or other bad events occur in practice.</li>
<li>Translating an inductive type to an arbitrary ML type does <strong>not</strong>
magically improve the asymptotic complexity of functions, even if the
ML type is an efficient representation. For instance, when extracting
<code class="docutils literal notranslate"><span class="pre">nat</span></code> to <span class="smallcaps">OCaml</span> <code class="docutils literal notranslate"><span class="pre">int</span></code>, the function <code class="docutils literal notranslate"><span class="pre">Nat.mul</span></code> stays quadratic.
It might be interesting to associate this translation with
some specific <a class="reference internal" href="#coq:cmd.extract-constant" title="Extract Constant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extract</span> <span class="pre">Constant</span></code></a> when primitive counterparts exist.</li>
</ul>
</div>
<p>Typical examples are the following:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">unit</span><span> =&gt; &quot;unit&quot; [ &quot;()&quot; ].</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">bool</span><span> =&gt; &quot;bool&quot; [ &quot;true&quot; &quot;false&quot; ].</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">sumbool</span><span> =&gt; &quot;bool&quot; [ &quot;true&quot; &quot;false&quot; ].</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">When extracting to <span class="smallcaps">OCaml</span>, if an inductive constructor or type has arity 2 and
the corresponding string is enclosed by parentheses, and the string meets
<span class="smallcaps">OCaml</span>'s lexical criteria for an infix symbol, then the rest of the string is
used as an infix constructor or type.</p>
</div>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> =&gt; &quot;list&quot; [ &quot;[]&quot; &quot;(::)&quot; ].</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">prod</span><span> =&gt; &quot;(*)&quot;  [ &quot;(,)&quot; ].</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p>As an example of translation to a non-inductive datatype, let's turn
<code class="docutils literal notranslate"><span class="pre">nat</span></code> into <span class="smallcaps">OCaml</span> <code class="docutils literal notranslate"><span class="pre">int</span></code> (see caveat above):</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Extract</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> =&gt; </span><span class="coqdoc-var">int</span><span> [ &quot;0&quot; &quot;succ&quot; ] &quot;(fun fO fS n -&gt; if n=0 then fO () else fS (n-1))&quot;.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<div class="section" id="avoiding-conflicts-with-existing-filenames">
<h3>Avoiding conflicts with existing filenames<a class="headerlink" href="#avoiding-conflicts-with-existing-filenames" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When using <a class="reference internal" href="#coq:cmd.extraction-library" title="Extraction Library"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Extraction</span> <span class="pre">Library</span></code></a>, the names of the extracted files
directly depend on the names of the <span class="smallcaps">Coq</span> files. It may happen that
these filenames are in conflict with already existing files,
either in the standard library of the target language or in other
code that is meant to be linked with the extracted code.
For instance the module <code class="docutils literal notranslate"><span class="pre">List</span></code> exists both in <span class="smallcaps">Coq</span> and in <span class="smallcaps">OCaml</span>.
It is possible to instruct the extraction not to use particular filenames.</p>
<dl class="cmd">
<dt id="coq:cmd.extraction-blacklist">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Extraction</span> <span>Blacklist</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.extraction-blacklist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Instruct the extraction to avoid using these names as filenames
for extracted code.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.print-extraction-blacklist">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Extraction</span> <span>Blacklist</span></span></code><a class="headerlink" href="#coq:cmd.print-extraction-blacklist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Show the current list of filenames the extraction should avoid.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.reset-extraction-blacklist">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Reset</span> <span>Extraction</span> <span>Blacklist</span></span></code><a class="headerlink" href="#coq:cmd.reset-extraction-blacklist" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Allow the extraction to use any filename.</p>
</dd></dl>

<p>For <span class="smallcaps">OCaml</span>, a typical use of these commands is
<code class="docutils literal notranslate"><span class="pre">Extraction</span> <span class="pre">Blacklist</span> <span class="pre">String</span> <span class="pre">List</span></code>.</p>
</div>
</div>
<div class="section" id="differences-between-coq-and-ml-type-systems">
<h2>Differences between <span class="smallcaps">Coq</span> and ML type systems<a class="headerlink" href="#differences-between-coq-and-ml-type-systems" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Due to differences between <span class="smallcaps">Coq</span> and ML type systems,
some extracted programs are not directly typable in ML.
We now solve this problem (at least in <span class="smallcaps">OCaml</span>) by adding
when needed some unsafe casting <code class="docutils literal notranslate"><span class="pre">Obj.magic</span></code>, which give
a generic type <code class="docutils literal notranslate"><span class="pre">'a</span></code> to any term.</p>
<p>First, if some part of the program is <em>very</em> polymorphic, there
may be no ML type for it. In that case the extraction to ML works
alright but the generated code may be refused by the ML
type checker. A very well known example is the <code class="docutils literal notranslate"><span class="pre">distr-pair</span></code>
function:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">dp</span><span> {</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Type</span><span>}(</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">A</span><span>)(</span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">B</span><span>)(</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">C</span><span>:</span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">C</span><span>-&gt;</span><span class="coqdoc-var">C</span><span>) := (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">y</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">dp is defined</span></dd>
</dl>
</div>
<p>In <span class="smallcaps">OCaml</span>, for instance, the direct extracted term would be:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>let dp x y f = Pair((f () x),(f () y))
</pre></div>
</div>
<p>and would have type:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>dp : &#39;a -&gt; &#39;a -&gt; (unit -&gt; &#39;a -&gt; &#39;b) -&gt; (&#39;b,&#39;b) prod
</pre></div>
</div>
<p>which is not its original type, but a restriction.</p>
<p>We now produce the following correct version:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>let dp x y f = Pair ((Obj.magic f () x), (Obj.magic f () y))
</pre></div>
</div>
<p>Secondly, some <span class="smallcaps">Coq</span> definitions may have no counterpart in ML. This
happens when there is a quantification over types inside the type
of a constructor; for example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">anything</span><span> : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">dummy</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>, </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">anything</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">anything is defined
anything_rect is defined
anything_ind is defined
anything_rec is defined</span></dd>
</dl>
</div>
<p>which corresponds to the definition of an ML dynamic type.
In <span class="smallcaps">OCaml</span>, we must cast any argument of the constructor dummy
(no GADT are produced yet by the extraction).</p>
<p>Even with those unsafe castings, you should never get error like
<code class="docutils literal notranslate"><span class="pre">segmentation</span> <span class="pre">fault</span></code>. In fact even if your program may seem
ill-typed to the <span class="smallcaps">OCaml</span> type checker, it can't go wrong : it comes
from a Coq well-typed terms, so for example inductive types will always
have the correct number of arguments, etc. Of course, when launching
manually some extracted function, you should apply it to arguments
of the right shape (from the <span class="smallcaps">Coq</span> point-of-view).</p>
<p>More details about the correctness of the extracted programs can be
found in <a class="reference internal" href="../zebibliography.html#let02" id="id1">[Let02]</a>.</p>
<p>We have to say, though, that in most &quot;realistic&quot; programs, these problems do not
occur. For example all the programs of Coq library are accepted by the <span class="smallcaps">OCaml</span>
type checker without any <code class="docutils literal notranslate"><span class="pre">Obj.magic</span></code> (see examples below).</p>
</div>
<div class="section" id="some-examples">
<h2>Some examples<a class="headerlink" href="#some-examples" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We present here two examples of extraction, taken from the
<span class="smallcaps">Coq</span> Standard Library. We choose <span class="smallcaps">OCaml</span> as the target language,
but everything, with slight modifications, can also be done in the
other languages supported by extraction.
We then indicate where to find other examples and tests of extraction.</p>
<div class="section" id="a-detailed-example-euclidean-division">
<h3>A detailed example: Euclidean division<a class="headerlink" href="#a-detailed-example-euclidean-division" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The file <code class="docutils literal notranslate"><span class="pre">Euclid</span></code> contains the proof of Euclidean division.
The natural numbers used here are unary, represented by the type``nat``,
which is defined by two constructors <code class="docutils literal notranslate"><span class="pre">O</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code>.
This module contains a theorem <code class="docutils literal notranslate"><span class="pre">eucl_dev</span></code>, whose type is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall b:nat, b &gt; 0 -&gt; forall a:nat, diveucl a b
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">diveucl</span></code> is a type for the pair of the quotient and the
modulo, plus some logical assertions that disappear during extraction.
We can now extract this program to <span class="smallcaps">OCaml</span>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Reset</span><span> </span><span class="coqdoc-var">Initial</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Extraction</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Euclid</span><span> </span><span class="coqdoc-var">Wf_nat</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Extraction</span><span> </span><span class="coqdoc-keyword">Inline</span><span> </span><span class="coqdoc-var">gt_wf_rec</span><span> </span><span class="coqdoc-var">lt_wf_rec</span><span> </span><span class="coqdoc-var">induction_ltof2</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Recursive Extraction</span><span> </span><span class="coqdoc-var">eucl_dev</span><span>.</span></dt>
<dd><span class="first last">
type nat =
| O
| S of nat

type sumbool =
| Left
| Right

(** val sub : nat -&gt; nat -&gt; nat **)

let rec sub n m =
  match n with
  | O -&gt; n
  | S k -&gt; (match m with
            | O -&gt; n
            | S l -&gt; sub k l)

(** val le_lt_dec : nat -&gt; nat -&gt; sumbool **)

let rec le_lt_dec n m =
  match n with
  | O -&gt; Left
  | S n0 -&gt; (match m with
             | O -&gt; Right
             | S m0 -&gt; le_lt_dec n0 m0)

(** val le_gt_dec : nat -&gt; nat -&gt; sumbool **)

let le_gt_dec =
  le_lt_dec

type diveucl =
| Divex of nat * nat

(** val eucl_dev : nat -&gt; nat -&gt; diveucl **)

let rec eucl_dev n m =
  let s = le_gt_dec n m in
  (match s with
   | Left -&gt;
     let d = let y = sub m n in eucl_dev n y in
     let Divex (q, r) = d in Divex ((S q), r)
   | Right -&gt; Divex (O, m))</span></dd>
</dl>
</div>
<p>The inlining of <code class="docutils literal notranslate"><span class="pre">gt_wf_rec</span></code> and others is not
mandatory. It only enhances readability of extracted code.
You can then copy-paste the output to a file <code class="docutils literal notranslate"><span class="pre">euclid.ml</span></code> or let
<span class="smallcaps">Coq</span> do it for you with the following command:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Extraction &quot;euclid&quot; eucl_dev.
</pre></div>
</div>
<p>Let us play the resulting program (in an <span class="smallcaps">OCaml</span> toplevel):</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#use &quot;euclid.ml&quot;;;
type nat = O | S of nat
type sumbool = Left | Right
val sub : nat -&gt; nat -&gt; nat = &lt;fun&gt;
val le_lt_dec : nat -&gt; nat -&gt; sumbool = &lt;fun&gt;
val le_gt_dec : nat -&gt; nat -&gt; sumbool = &lt;fun&gt;
type diveucl = Divex of nat * nat
val eucl_dev : nat -&gt; nat -&gt; diveucl = &lt;fun&gt;

# eucl_dev (S (S O)) (S (S (S (S (S O)))));;
- : diveucl = Divex (S (S O), S O)
</pre></div>
</div>
<p>It is easier to test on <span class="smallcaps">OCaml</span> integers:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span># let rec nat_of_int = function 0 -&gt; O | n -&gt; S (nat_of_int (n-1));;
val nat_of_int : int -&gt; nat = &lt;fun&gt;

# let rec int_of_nat = function O -&gt; 0 | S p -&gt; 1+(int_of_nat p);;
val int_of_nat : nat -&gt; int = &lt;fun&gt;

# let div a b =
  let Divex (q,r) = eucl_dev (nat_of_int b) (nat_of_int a)
  in (int_of_nat q, int_of_nat r);;
val div : int -&gt; int -&gt; int * int = &lt;fun&gt;

# div 173 15;;
- : int * int = (11, 8)
</pre></div>
</div>
<p>Note that these <code class="docutils literal notranslate"><span class="pre">nat_of_int</span></code> and <code class="docutils literal notranslate"><span class="pre">int_of_nat</span></code> are now
available via a mere <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">ExtrOcamlIntConv</span></code> and then
adding these functions to the list of functions to extract. This file
<code class="docutils literal notranslate"><span class="pre">ExtrOcamlIntConv.v</span></code> and some others in <code class="docutils literal notranslate"><span class="pre">plugins/extraction/</span></code>
are meant to help building concrete program via extraction.</p>
</div>
<div class="section" id="extraction-s-horror-museum">
<h3>Extraction's horror museum<a class="headerlink" href="#extraction-s-horror-museum" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Some pathological examples of extraction are grouped in the file
<code class="docutils literal notranslate"><span class="pre">test-suite/success/extraction.v</span></code> of the sources of <span class="smallcaps">Coq</span>.</p>
</div>
<div class="section" id="users-contributions">
<h3>Users' Contributions<a class="headerlink" href="#users-contributions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Several of the <span class="smallcaps">Coq</span> Users' Contributions use extraction to produce
certified programs. In particular the following ones have an automatic
extraction test:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">additions</span></code> : <a class="reference external" href="https://github.com/coq-contribs/additions">https://github.com/coq-contribs/additions</a></li>
<li><code class="docutils literal notranslate"><span class="pre">bdds</span></code> : <a class="reference external" href="https://github.com/coq-contribs/bdds">https://github.com/coq-contribs/bdds</a></li>
<li><code class="docutils literal notranslate"><span class="pre">canon-bdds</span></code> : <a class="reference external" href="https://github.com/coq-contribs/canon-bdds">https://github.com/coq-contribs/canon-bdds</a></li>
<li><code class="docutils literal notranslate"><span class="pre">chinese</span></code> : <a class="reference external" href="https://github.com/coq-contribs/chinese">https://github.com/coq-contribs/chinese</a></li>
<li><code class="docutils literal notranslate"><span class="pre">continuations</span></code> : <a class="reference external" href="https://github.com/coq-contribs/continuations">https://github.com/coq-contribs/continuations</a></li>
<li><code class="docutils literal notranslate"><span class="pre">coq-in-coq</span></code> : <a class="reference external" href="https://github.com/coq-contribs/coq-in-coq">https://github.com/coq-contribs/coq-in-coq</a></li>
<li><code class="docutils literal notranslate"><span class="pre">exceptions</span></code> : <a class="reference external" href="https://github.com/coq-contribs/exceptions">https://github.com/coq-contribs/exceptions</a></li>
<li><code class="docutils literal notranslate"><span class="pre">firing-squad</span></code> : <a class="reference external" href="https://github.com/coq-contribs/firing-squad">https://github.com/coq-contribs/firing-squad</a></li>
<li><code class="docutils literal notranslate"><span class="pre">founify</span></code> : <a class="reference external" href="https://github.com/coq-contribs/founify">https://github.com/coq-contribs/founify</a></li>
<li><code class="docutils literal notranslate"><span class="pre">graphs</span></code> : <a class="reference external" href="https://github.com/coq-contribs/graphs">https://github.com/coq-contribs/graphs</a></li>
<li><code class="docutils literal notranslate"><span class="pre">higman-cf</span></code> : <a class="reference external" href="https://github.com/coq-contribs/higman-cf">https://github.com/coq-contribs/higman-cf</a></li>
<li><code class="docutils literal notranslate"><span class="pre">higman-nw</span></code> : <a class="reference external" href="https://github.com/coq-contribs/higman-nw">https://github.com/coq-contribs/higman-nw</a></li>
<li><code class="docutils literal notranslate"><span class="pre">hardware</span></code> : <a class="reference external" href="https://github.com/coq-contribs/hardware">https://github.com/coq-contribs/hardware</a></li>
<li><code class="docutils literal notranslate"><span class="pre">multiplier</span></code> : <a class="reference external" href="https://github.com/coq-contribs/multiplier">https://github.com/coq-contribs/multiplier</a></li>
<li><code class="docutils literal notranslate"><span class="pre">search-trees</span></code> : <a class="reference external" href="https://github.com/coq-contribs/search-trees">https://github.com/coq-contribs/search-trees</a></li>
<li><code class="docutils literal notranslate"><span class="pre">stalmarck</span></code> : <a class="reference external" href="https://github.com/coq-contribs/stalmarck">https://github.com/coq-contribs/stalmarck</a></li>
</ul>
</div></blockquote>
<p>Note that <code class="docutils literal notranslate"><span class="pre">continuations</span></code> and <code class="docutils literal notranslate"><span class="pre">multiplier</span></code> are a bit particular. They are
examples of developments where <code class="docutils literal notranslate"><span class="pre">Obj.magic</span></code> is needed. This is
probably due to a heavy use of impredicativity. After compilation, those
two examples run nonetheless, thanks to the correction of the
extraction <a class="reference internal" href="../zebibliography.html#let02" id="id2">[Let02]</a>.</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="program.html" class="btn btn-neutral float-right" title="Program" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="micromega.html" class="btn btn-neutral" title="Micromega: tactics for solving arithmetic goals over ordered rings" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>