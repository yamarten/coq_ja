

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Micromega: tactics for solving arithmetic goals over ordered rings &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="Extraction of programs in OCaml and Haskell" href="extraction.html" />
    <link rel="prev" title="Omega: a solver for quantifier-free problems in Presburger Arithmetic" href="omega.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Micromega: tactics for solving arithmetic goals over ordered rings</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#short-description-of-the-tactics">Short description of the tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#positivstellensatz-refutations"><em>Positivstellensatz</em> refutations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic"><cite>lra</cite>: a decision procedure for linear real and rational arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lia-a-tactic-for-linear-integer-arithmetic"><cite>lia</cite>: a tactic for linear integer arithmetic</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#high-level-view-of-lia">High level view of <cite>lia</cite></a></li>
<li class="toctree-l3"><a class="reference internal" href="#cutting-plane-proofs">Cutting plane proofs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#case-split">Case split</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#nra-a-proof-procedure-for-non-linear-arithmetic"><cite>nra</cite>: a proof procedure for non-linear arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nia-a-proof-procedure-for-non-linear-integer-arithmetic"><cite>nia</cite>: a proof procedure for non-linear integer arithmetic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#psatz-a-proof-procedure-for-non-linear-arithmetic"><cite>psatz</cite>: a proof procedure for non-linear arithmetic</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Micromega: tactics for solving arithmetic goals over ordered rings</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/addendum/micromega.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="micromega-tactics-for-solving-arithmetic-goals-over-ordered-rings">
<h1>Micromega: tactics for solving arithmetic goals over ordered rings<a class="headerlink" href="#micromega-tactics-for-solving-arithmetic-goals-over-ordered-rings" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Frédéric Besson and Evgeny Makarov</td>
</tr>
</tbody>
</table>
<div class="section" id="short-description-of-the-tactics">
<h2>Short description of the tactics<a class="headerlink" href="#short-description-of-the-tactics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The Psatz module (<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Psatz.</span></code>) gives access to several
tactics for solving arithmetic goals over <span class="math notranslate">\(\mathbb{Z}\)</span>, <span class="math notranslate">\(\mathbb{Q}\)</span>, and <span class="math notranslate">\(\mathbb{R}\)</span> <a class="footnote-reference" href="#id7" id="id1">[1]</a>.
It also possible to get the tactics for integers by a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Lia</span></code>,
rationals <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Lqa</span></code> and reals <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Lra</span></code>.</p>
<ul class="simple">
<li><a class="reference internal" href="#coq:tacn.lia" title="lia"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lia</span></code></a> is a decision procedure for linear integer arithmetic;</li>
<li><a class="reference internal" href="#coq:tacn.nia" title="nia"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">nia</span></code></a> is an incomplete proof procedure for integer non-linear
arithmetic;</li>
<li><a class="reference internal" href="#coq:tacn.lra" title="lra"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lra</span></code></a> is a decision procedure for linear (real or rational) arithmetic;</li>
<li><a class="reference internal" href="#coq:tacn.nra" title="nra"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">nra</span></code></a> is an incomplete proof procedure for non-linear (real or
rational) arithmetic;</li>
<li><a class="reference internal" href="#coq:tacn.psatz" title="psatz"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">psatz</span></code></a> <code class="docutils literal notranslate"><span class="pre">D</span> <span class="pre">n</span></code> where <code class="docutils literal notranslate"><span class="pre">D</span></code> is <span class="math notranslate">\(\mathbb{Z}\)</span> or <span class="math notranslate">\(\mathbb{Q}\)</span> or <span class="math notranslate">\(\mathbb{R}\)</span>, and
<code class="docutils literal notranslate"><span class="pre">n</span></code> is an optional integer limiting the proof search depth,
is an incomplete proof procedure for non-linear arithmetic.
It is based on John Harrison’s HOL Light
driver to the external prover <cite>csdp</cite> <a class="footnote-reference" href="#id8" id="id2">[2]</a>. Note that the <cite>csdp</cite> driver is
generating a <em>proof cache</em> which makes it possible to rerun scripts
even without <cite>csdp</cite>.</li>
</ul>
<p>The tactics solve propositional formulas parameterized by atomic
arithmetic expressions interpreted over a domain <span class="math notranslate">\(D\)</span> ∈ {ℤ, ℚ, ℝ}.
The syntax of the formulas is the following:</p>
<blockquote>
<div><pre>
<strong id="grammar-token-F">F</strong> ::=  A ∣ P ∣ True ∣ False ∣ F ∧ F ∣ F ∨ F ∣ F ↔ F ∣ F → F ∣ ¬ F
<strong id="grammar-token-A">A</strong> ::=  p = p ∣ p &gt; p ∣ p &lt; p ∣ p ≥ p ∣ p ≤ p
<strong id="grammar-token-p">p</strong> ::=  c ∣ x ∣ −p ∣ p − p ∣ p + p ∣ p × p ∣ p ^ n
</pre>
</div></blockquote>
<p>where <span class="math notranslate">\(c\)</span> is a numeric constant, <span class="math notranslate">\(x \in D\)</span> is a numeric variable, the
operators <span class="math notranslate">\(−, +, ×\)</span> are respectively subtraction, addition, and product;
<span class="math notranslate">\(p ^ n\)</span> is exponentiation by a constant <span class="math notranslate">\(n\)</span>, <span class="math notranslate">\(P\)</span> is an arbitrary proposition.
For <span class="math notranslate">\(\mathbb{Q}\)</span>, equality is not Leibniz equality = but the equality of
rationals ==.</p>
<p>For <span class="math notranslate">\(\mathbb{Z}\)</span> (resp. <span class="math notranslate">\(\mathbb{Q}\)</span>), <span class="math notranslate">\(c\)</span> ranges over integer constants (resp. rational
constants). For <span class="math notranslate">\(\mathbb{R}\)</span>, the tactic recognizes as real constants the
following expressions:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>c ::= R0 | R1 | Rmul(c,c) | Rplus(c,c) | Rminus(c,c) | IZR z | IQR q | Rdiv(c,c) | Rinv c
</pre></div>
</div>
<p>where <span class="math notranslate">\(z\)</span> is a constant in <span class="math notranslate">\(\mathbb{Z}\)</span> and <span class="math notranslate">\(q\)</span> is a constant in <span class="math notranslate">\(\mathbb{Q}\)</span>.
This includes integer constants written using the decimal notation, <em>i.e.</em>, c%R.</p>
</div>
<div class="section" id="positivstellensatz-refutations">
<h2><em>Positivstellensatz</em> refutations<a class="headerlink" href="#positivstellensatz-refutations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The name <cite>psatz</cite> is an abbreviation for <em>positivstellensatz</em> – literally
&quot;positivity theorem&quot; – which generalizes Hilbert’s <em>nullstellensatz</em>. It
relies on the notion of Cone. Given a (finite) set of polynomials <span class="math notranslate">\(S\)</span>,
<span class="math notranslate">\(\mathit{Cone}(S)\)</span> is inductively defined as the smallest set of polynomials
closed under the following rules:</p>
<p><span class="math notranslate">\(\begin{array}{l}
\dfrac{p \in S}{p \in \mathit{Cone}(S)} \quad
\dfrac{}{p^2 \in \mathit{Cone}(S)} \quad
\dfrac{p_1 \in \mathit{Cone}(S) \quad p_2 \in \mathit{Cone}(S) \quad
\Join \in \{+,*\}} {p_1 \Join p_2 \in \mathit{Cone}(S)}\\
\end{array}\)</span></p>
<p>The following theorem provides a proof principle for checking that a
set of polynomial inequalities does not have solutions <a class="footnote-reference" href="#id9" id="id3">[3]</a>.</p>
<p id="psatz-thm"><strong>Theorem (Psatz)</strong>. Let <span class="math notranslate">\(S\)</span> be a set of polynomials.
If <span class="math notranslate">\(-1\)</span> belongs to <span class="math notranslate">\(\mathit{Cone}(S)\)</span>, then the conjunction
<span class="math notranslate">\(\bigwedge_{p \in S} p\ge 0\)</span>  is unsatisfiable.
A proof based on this theorem is called a <em>positivstellensatz</em>
refutation. The tactics work as follows. Formulas are normalized into
conjunctive normal form <span class="math notranslate">\(\bigwedge_i C_i\)</span> where <span class="math notranslate">\(C_i\)</span> has the
general form <span class="math notranslate">\((\bigwedge_{j\in S_i} p_j \Join 0) \to \mathit{False}\)</span> and
<span class="math notranslate">\(\Join \in \{&gt;,\ge,=\}\)</span> for <span class="math notranslate">\(D\in \{\mathbb{Q},\mathbb{R}\}\)</span> and
<span class="math notranslate">\(\Join \in \{\ge, =\}\)</span> for <span class="math notranslate">\(\mathbb{Z}\)</span>.</p>
<p>For each conjunct <span class="math notranslate">\(C_i\)</span>, the tactic calls an oracle which searches for
<span class="math notranslate">\(-1\)</span> within the cone. Upon success, the oracle returns a <em>cone
expression</em> that is normalized by the ring tactic (see <a class="reference internal" href="ring.html#theringandfieldtacticfamilies"><span class="std std-ref">The ring and field tactic families</span></a>)
and checked to be <span class="math notranslate">\(-1\)</span>.</p>
</div>
<div class="section" id="lra-a-decision-procedure-for-linear-real-and-rational-arithmetic">
<h2><cite>lra</cite>: a decision procedure for linear real and rational arithmetic<a class="headerlink" href="#lra-a-decision-procedure-for-linear-real-and-rational-arithmetic" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.lra">
<code class="descname"><span class="notation"><span>lra</span></span></code><a class="headerlink" href="#coq:tacn.lra" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic is searching for <em>linear</em> refutations using Fourier
elimination <a class="footnote-reference" href="#id10" id="id4">[4]</a>. As a result, this tactic explores a subset of the <em>Cone</em>
defined as</p>
<blockquote>
<div><span class="math notranslate">\(\mathit{LinCone}(S) =\left\{ \left. \sum_{p \in S} \alpha_p \times p~\right|~\alpha_p \mbox{ are positive constants} \right\}\)</span></div></blockquote>
<p>The deductive power of <cite>lra</cite> is the combined deductive power of
<cite>ring_simplify</cite> and <cite>fourier</cite>. There is also an overlap with the field
tactic <em>e.g.</em>, <span class="math notranslate">\(x = 10 * x / 10\)</span> is solved by <cite>lra</cite>.</p>
</div>
<div class="section" id="lia-a-tactic-for-linear-integer-arithmetic">
<h2><cite>lia</cite>: a tactic for linear integer arithmetic<a class="headerlink" href="#lia-a-tactic-for-linear-integer-arithmetic" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.lia">
<code class="descname"><span class="notation"><span>lia</span></span></code><a class="headerlink" href="#coq:tacn.lia" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic offers an alternative to the <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a> and <a class="reference internal" href="omega.html#coq:tacv.romega" title="romega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">romega</span></code></a>
tactics. Roughly speaking, the deductive power of lia is the combined deductive
power of <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.ring-simplify" title="ring_simplify"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">ring_simplify</span></code></a> and <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a>. However, it solves linear
goals that <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a> and <a class="reference internal" href="omega.html#coq:tacv.romega" title="romega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">romega</span></code></a> do not solve, such as the following
so-called <em>omega nightmare</em> <a class="reference internal" href="../zebibliography.html#theomegapaper" id="id5">[Pug92]</a>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>,</span><span>
&nbsp;&nbsp;27 &lt;= 11 * </span><span class="coqdoc-var">x</span><span> + 13 * </span><span class="coqdoc-var">y</span><span> &lt;= 45 -&gt;</span><span>
&nbsp;&nbsp;-10 &lt;= 7 * </span><span class="coqdoc-var">x</span><span> - 9 * </span><span class="coqdoc-var">y</span><span> &lt;= 4 -&gt; </span><span class="coqdoc-var">False</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 52-55:
&gt; Goal forall x y,   27 &lt;= 11 * x + 13 * y &lt;= 45 -&gt;   -10 &lt;= 7 * x - 9 * y &lt;= 4 -&gt; False.
&gt;                                                     ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Cannot interpret a negative number as a number of type nat</span></dd>
</dl>
</div>
<p>The estimation of the relative efficiency of <a class="reference internal" href="#coq:tacn.lia" title="lia"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">lia</span></code></a> <em>vs</em> <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a> and
<a class="reference internal" href="omega.html#coq:tacv.romega" title="romega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">romega</span></code></a> is under evaluation.</p>
<div class="section" id="high-level-view-of-lia">
<h3>High level view of <cite>lia</cite><a class="headerlink" href="#high-level-view-of-lia" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Over <span class="math notranslate">\(\mathbb{R}\)</span>, <em>positivstellensatz</em> refutations are a complete proof
principle <a class="footnote-reference" href="#id11" id="id6">[5]</a>. However, this is not the case over <span class="math notranslate">\(\mathbb{Z}\)</span>. Actually,
<em>positivstellensatz</em> refutations are not even sufficient to decide
linear <em>integer</em> arithmetic. The canonical example is <span class="math notranslate">\(2 * x = 1 -&gt; \mathtt{False}\)</span>
which is a theorem of <span class="math notranslate">\(\mathbb{Z}\)</span> but not a theorem of <span class="math notranslate">\({\mathbb{R}}\)</span>. To remedy this
weakness, the <cite>lia</cite> tactic is using recursively a combination of:</p>
<ul class="simple">
<li>linear <em>positivstellensatz</em> refutations;</li>
<li>cutting plane proofs;</li>
<li>case split.</li>
</ul>
</div>
<div class="section" id="cutting-plane-proofs">
<h3>Cutting plane proofs<a class="headerlink" href="#cutting-plane-proofs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>are a way to take into account the discreteness of <span class="math notranslate">\(\mathbb{Z}\)</span> by rounding up
(rational) constants up-to the closest integer.</p>
<span class="target" id="ceil-thm"></span><dl class="thm">
<dt>
<em class="property"><span class="sigannot">Theorem</span></em> <code class="descname">Bound on the ceiling function</code></dt>
<dd><p>Let <span class="math notranslate">\(p\)</span> be an integer and <span class="math notranslate">\(c\)</span> a rational constant. Then
<span class="math notranslate">\(p \ge c \rightarrow p \ge \lceil{c}\rceil\)</span>.</p>
</dd></dl>

<p>For instance, from 2 x = 1 we can deduce</p>
<ul class="simple">
<li><span class="math notranslate">\(x \ge 1/2\)</span> whose cut plane is <span class="math notranslate">\(x \ge \lceil{1/2}\rceil = 1\)</span>;</li>
<li><span class="math notranslate">\(x \le 1/2\)</span> whose cut plane is <span class="math notranslate">\(x \le \lfloor{1/2}\rfloor = 0\)</span>.</li>
</ul>
<p>By combining these two facts (in normal form) <span class="math notranslate">\(x − 1 \ge 0\)</span> and
<span class="math notranslate">\(-x \ge 0\)</span>, we conclude by exhibiting a <em>positivstellensatz</em> refutation:
<span class="math notranslate">\(−1 \equiv x−1 + −x \in \mathit{Cone}({x−1,x})\)</span>.</p>
<p>Cutting plane proofs and linear <em>positivstellensatz</em> refutations are a
complete proof principle for integer linear arithmetic.</p>
</div>
<div class="section" id="case-split">
<h3>Case split<a class="headerlink" href="#case-split" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>enumerates over the possible values of an expression.</p>
<p id="casesplit-thm"><strong>Theorem</strong>. Let <span class="math notranslate">\(p\)</span> be an integer and <span class="math notranslate">\(c_1\)</span> and <span class="math notranslate">\(c_2\)</span>
integer constants. Then:</p>
<blockquote>
<div><span class="math notranslate">\(c_1 \le p \le c_2 \Rightarrow \bigvee_{x \in [c_1,c_2]} p = x\)</span></div></blockquote>
<p>Our current oracle tries to find an expression <span class="math notranslate">\(e\)</span> with a small range
<span class="math notranslate">\([c_1,c_2]\)</span>. We generate <span class="math notranslate">\(c_2 − c_1\)</span> subgoals which contexts are enriched
with an equation <span class="math notranslate">\(e = i\)</span> for <span class="math notranslate">\(i \in [c_1,c_2]\)</span> and recursively search for
a proof.</p>
</div>
</div>
<div class="section" id="nra-a-proof-procedure-for-non-linear-arithmetic">
<h2><cite>nra</cite>: a proof procedure for non-linear arithmetic<a class="headerlink" href="#nra-a-proof-procedure-for-non-linear-arithmetic" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.nra">
<code class="descname"><span class="notation"><span>nra</span></span></code><a class="headerlink" href="#coq:tacn.nra" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic is an <em>experimental</em> proof procedure for non-linear
arithmetic. The tactic performs a limited amount of non-linear
reasoning before running the linear prover of <cite>lra</cite>. This pre-processing
does the following:</p>
<ul class="simple">
<li>If the context contains an arithmetic expression of the form
<span class="math notranslate">\(e[x^2]\)</span> where <span class="math notranslate">\(x\)</span> is a monomial, the context is enriched with
<span class="math notranslate">\(x^2 \ge 0\)</span>;</li>
<li>For all pairs of hypotheses <span class="math notranslate">\(e_1 \ge 0\)</span>, <span class="math notranslate">\(e_2 \ge 0\)</span>, the context is
enriched with <span class="math notranslate">\(e_1 \times e_2 \ge 0\)</span>.</li>
</ul>
<p>After this pre-processing, the linear prover of <cite>lra</cite> searches for a
proof by abstracting monomials by variables.</p>
</div>
<div class="section" id="nia-a-proof-procedure-for-non-linear-integer-arithmetic">
<h2><cite>nia</cite>: a proof procedure for non-linear integer arithmetic<a class="headerlink" href="#nia-a-proof-procedure-for-non-linear-integer-arithmetic" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.nia">
<code class="descname"><span class="notation"><span>nia</span></span></code><a class="headerlink" href="#coq:tacn.nia" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic is a proof procedure for non-linear integer arithmetic.
It performs a pre-processing similar to <cite>nra</cite>. The obtained goal is
solved using the linear integer prover <cite>lia</cite>.</p>
</div>
<div class="section" id="psatz-a-proof-procedure-for-non-linear-arithmetic">
<h2><cite>psatz</cite>: a proof procedure for non-linear arithmetic<a class="headerlink" href="#psatz-a-proof-procedure-for-non-linear-arithmetic" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.psatz">
<code class="descname"><span class="notation"><span>psatz</span></span></code><a class="headerlink" href="#coq:tacn.psatz" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic explores the <span class="math notranslate">\(\mathit{Cone}\)</span> by increasing degrees – hence the
depth parameter <span class="math notranslate">\(n\)</span>. In theory, such a proof search is complete – if the
goal is provable the search eventually stops. Unfortunately, the
external oracle is using numeric (approximate) optimization techniques
that might miss a refutation.</p>
<p>To illustrate the working of the tactic, consider we wish to prove the
following Coq goal:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ZArith</span><span> </span><span class="coqdoc-var">Psatz</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file z_syntax_plugin.cmxs ... done]
[Loading ML file quote_plugin.cmxs ... done]
[Loading ML file newring_plugin.cmxs ... done]
[Loading ML file omega_plugin.cmxs ... done]
[Loading ML file r_syntax_plugin.cmxs ... done]
[Loading ML file micromega_plugin.cmxs ... done]</span></dd>
<dt><span class="coqdoc-keyword">Open</span><span> </span><span class="coqdoc-keyword">Scope</span><span> </span><span class="coqdoc-var">Z_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, -</span><span class="coqdoc-var">x</span><span>^2 &gt;= 0 -&gt; </span><span class="coqdoc-var">x</span><span> - 1 &gt;= 0 -&gt; </span><span class="coqdoc-var">False</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">-</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">^ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">-</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">^ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">psatz</span><span> </span><span class="coqdoc-var">Z</span><span> 2.</span></dt>
<dd><span class="first">Toplevel input, characters 0-9:
&gt; psatz Z 2.
&gt; ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
In nested Ltac calls to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">psatz</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (constr) (int_or_var)&quot;, 
&quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xpsatz</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; and &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">psatz_Z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (int_or_var) (tactic)&quot;, last call failed.
Tactic failure:  Skipping what remains of this tactic: the complexity of the goal requires the use of a specialized external tool called csdp. 

Unfortunately Coq isn't aware of the presence of any &quot;csdp&quot; executable in the path. 

Csdp packages are provided by some OS distributions; binaries and source code can be downloaded from https://projects.coin-or.org/Csdp.</span></dd>
</dl>
</div>
<p>As shown, such a goal is solved by <code class="docutils literal notranslate"><span class="pre">intro</span> <span class="pre">x.</span> <span class="pre">psatz</span> <span class="pre">Z</span> <span class="pre">2.</span></code>. The oracle returns the
cone expression <span class="math notranslate">\(2 \times (x-1) + (\mathbf{x-1}) \times (\mathbf{x−1}) + -x^2\)</span>
(polynomial hypotheses are printed in bold). By construction, this expression
belongs to <span class="math notranslate">\(\mathit{Cone}({−x^2,x -1})\)</span>. Moreover, by running <cite>ring</cite> we
obtain <span class="math notranslate">\(-1\)</span>. By Theorem <a class="reference internal" href="#psatz-thm"><span class="std std-ref">Psatz</span></a>, the goal is valid.</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Support for <cite>nat</cite> and <span class="math notranslate">\(\mathbb{N}\)</span> is obtained by pre-processing the goal with
the <cite>zify</cite> tactic.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Sources and binaries can be found at <a class="reference external" href="https://projects.coin-or.org/Csdp">https://projects.coin-or.org/Csdp</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Variants deal with equalities and strict inequalities.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>More efficient linear programming techniques could equally be employed.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>In practice, the oracle might fail to produce such a refutation.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="extraction.html" class="btn btn-neutral float-right" title="Extraction of programs in OCaml and Haskell" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="omega.html" class="btn btn-neutral" title="Omega: a solver for quantifier-free problems in Presburger Arithmetic" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>