

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Extended pattern matching &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="Implicit Coercions" href="implicit-coercions.html" />
    <link rel="prev" title="Coq Integrated Development Environment" href="../practical-tools/coqide.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Extended pattern matching</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#patterns">Patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-patterns">Multiple patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#aliasing-subpatterns">Aliasing subpatterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nested-patterns">Nested patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#disjunctive-patterns">Disjunctive patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#about-patterns-of-parametric-types">About patterns of parametric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parameters-in-patterns">Parameters in patterns</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-arguments-in-patterns">Implicit arguments in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#matching-objects-of-dependent-types">Matching objects of dependent types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#understanding-dependencies-in-patterns">Understanding dependencies in patterns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#when-the-elimination-predicate-must-be-provided">When the elimination predicate must be provided</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dependent-pattern-matching">Dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-dependent-pattern-matching">Multiple dependent pattern matching</a></li>
<li class="toctree-l3"><a class="reference internal" href="#patterns-in-in">Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#using-pattern-matching-to-write-proofs">Using pattern matching to write proofs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pattern-matching-on-inductive-objects-involving-local-definitions">Pattern-matching on inductive objects involving local definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pattern-matching-and-coercions">Pattern-matching and coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#when-does-the-expansion-strategy-fail">When does the expansion strategy fail?</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Extended pattern matching</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/addendum/extended-pattern-matching.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="extended-pattern-matching">
<span id="extendedpatternmatching"></span><h1>Extended pattern matching<a class="headerlink" href="#extended-pattern-matching" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Cristina Cornes and Hugo Herbelin</td>
</tr>
</tbody>
</table>
<p>This section describes the full form of pattern matching in <span class="smallcaps">Coq</span> terms.</p>
<div class="section" id="patterns">
<h2>Patterns<a class="headerlink" href="#patterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The full syntax of match is presented in Figures 1.1 and 1.2.
Identifiers in patterns are either constructor names or variables. Any
identifier that is not the constructor of an inductive or co-inductive
type is considered to be a variable. A variable name cannot occur more
than once in a given pattern. It is recommended to start variable
names by a lowercase letter.</p>
<p>If a pattern has the form <code class="docutils literal notranslate"><span class="pre">(c</span> <span class="pre">x)</span></code> where <code class="docutils literal notranslate"><span class="pre">c</span></code> is a constructor symbol and x
is a linear vector of (distinct) variables, it is called <em>simple</em>: it
is the kind of pattern recognized by the basic version of match. On
the opposite, if it is a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> or has the form <code class="docutils literal notranslate"><span class="pre">(c</span> <span class="pre">p)</span></code> with <code class="docutils literal notranslate"><span class="pre">p</span></code> not
only made of variables, the pattern is called <em>nested</em>.</p>
<p>A variable pattern matches any value, and the identifier is bound to
that value. The pattern “<code class="docutils literal notranslate"><span class="pre">_</span></code>” (called “don't care” or “wildcard” symbol)
also matches any value, but does not bind anything. It may occur an
arbitrary number of times in a pattern. Alias patterns written
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a> <span><span class="pre">as</span></span> <span class="hole"><span class="pre">identifier</span></span><span><span class="pre">)</span></span></span></code> are also accepted. This pattern matches the
same values as <code class="docutils literal notranslate"><span class="pre">pattern</span></code> does and <code class="docutils literal notranslate"><span class="pre">identifier</span></code> is bound to the matched
value. A pattern of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pattern</span></span> <span><span class="pre">|</span></span> <span><span class="pre">pattern</span></span></span></code> is called disjunctive. A
list of patterns separated with commas is also considered as a pattern
and is called <em>multiple pattern</em>. However multiple patterns can only
occur at the root of pattern matching equations. Disjunctions of
<em>multiple patterns</em> are allowed though.</p>
<p>Since extended <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions are compiled into the primitive ones,
the expressiveness of the theory remains the same. Once parsing has finished
only simple patterns remain. The original nesting of the <code class="docutils literal notranslate"><span class="pre">match</span></code> expressions
is recovered at printing time. An easy way to see the result
of the expansion is to toggle off the nesting performed at printing
(use here <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-matching" title="Printing Matching"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Matching</span></code></a>), then by printing the term with <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.print" title="Print"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Print</span></code></a>
if the term is a constant, or using the command <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.check" title="Check"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Check</span></code></a>.</p>
<p>The extended <code class="docutils literal notranslate"><span class="pre">match</span></code> still accepts an optional <em>elimination predicate</em>
given after the keyword <code class="docutils literal notranslate"><span class="pre">return</span></code>. Given a pattern matching expression,
if all the right-hand-sides of <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> have the same
type, then this type can be sometimes synthesized, and so we can omit
the return part. Otherwise the predicate after return has to be
provided, like for the basicmatch.</p>
<p>Let us illustrate through examples the different aspects of extended
pattern matching. Consider for example the function that computes the
maximum of two natural numbers. We can write it in primitive syntax
by:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">max</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span> =&gt; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m'</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">m'</span><span>)</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">max is defined
max is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
</div>
<div class="section" id="multiple-patterns">
<h2>Multiple patterns<a class="headerlink" href="#multiple-patterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Using multiple patterns in the definition of <code class="docutils literal notranslate"><span class="pre">max</span></code> lets us write:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">max</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span>, </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span>, </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m'</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">m'</span><span>)</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-143:
&gt; Fixpoint max (n m:nat) {struct m} : nat :=     match n, m with     | O, _ =&gt; m     | S n', O =&gt; S n'     | S n', S m' =&gt; S (max n' m')     end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> max already exists.</span></dd>
</dl>
</div>
<p>which will be compiled into the previous form.</p>
<p>The pattern matching compilation strategy examines patterns from left
to right. A match expression is generated <strong>only</strong> when there is at least
one constructor in the column of patterns. E.g. the following example
does not build a match expression.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">nat</span><span> =&gt; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">nat</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">y</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<div class="section" id="aliasing-subpatterns">
<h2>Aliasing subpatterns<a class="headerlink" href="#aliasing-subpatterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We can also use <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">as</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> to associate a name to a sub-pattern:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">max</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span>, </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">p</span><span>, </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">p</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m'</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">m'</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-135:
&gt; Fixpoint max (n m:nat) {struct n} : nat :=   match n, m with   | O, _ =&gt; m   | S n' as p, O =&gt; p   | S n', S m' =&gt; S (max n' m')   end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> max already exists.</span></dd>
</dl>
</div>
</div>
<div class="section" id="nested-patterns">
<h2>Nested patterns<a class="headerlink" href="#nested-patterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Here is now an example of nested patterns:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">bool</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">true</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">false</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span>) =&gt; </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n'</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">even is defined
even is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
<p>This is compiled into:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-var">Matching</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">even</span><span>.</span></dt>
<dd><span class="first">even = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> even (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> :=
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  | 0 =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
            | 0 =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">false</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
            | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">even</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
            </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">

Argument scope is [nat_scope]</span></dd>
</dl>
</div>
<p>In the previous examples patterns do not conflict with, but sometimes
it is comfortable to write patterns that admit a non trivial
superposition. Consider the boolean function <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">lef</span></span></code> that given two
natural numbers yields <code class="code Coq docutils literal notranslate"><span class="name builtin pseudo"><span class="pre">true</span></span></code> if the first one is less or equal than the
second one and <code class="code Coq docutils literal notranslate"><span class="name builtin pseudo"><span class="pre">false</span></span></code> otherwise. We can write it as follows:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">lef</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">bool</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span>, </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">true</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">false</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">lef</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">lef is defined
lef is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
<p>Note that the first and the second multiple pattern overlap because
the couple of values <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">O</span></code> matches both. Thus, what is the result of the
function on those values? To eliminate ambiguity we use the <em>textual
priority rule:</em> we consider patterns to be ordered from top to bottom. A
value is matched by the pattern at the ith row if and only if it is
not matched by some pattern from a previous row. Thus in the example, <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">O</span></code>
is matched by the first pattern, and so <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">lef</span></span> <span class="name"><span class="pre">O</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span></code> yields true.</p>
<p>Another way to write this function is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">lef</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">bool</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span>, </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">true</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">lef</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">_</span><span>, </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">false</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-127:
&gt; Fixpoint lef (n m:nat) {struct m} : bool :=   match n, m with   | O, x =&gt; true   | S n, S m =&gt; lef n m   | _, _ =&gt; false   end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> lef already exists.</span></dd>
</dl>
</div>
<p>Here the last pattern superposes with the first two. Because of the
priority rule, the last pattern will be used only for values that do
not match neither the first nor the second one.</p>
<p>Terms with useless patterns are not accepted by the system. Here is an
example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">nat</span><span> =&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">true</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">false</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">true</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="first last">The command has indeed failed with message:
This clause is redundant.</span></dd>
</dl>
</div>
</div>
<div class="section" id="disjunctive-patterns">
<h2>Disjunctive patterns<a class="headerlink" href="#disjunctive-patterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Multiple patterns that share the same right-hand-side can be
factorized using the notation <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-mult_pattern"><span class="hole"><span class="pre">mult_pattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span></span></code>. For
instance, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">max</span></span></code> can be rewritten as follows:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">max</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n'</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m'</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">max</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">m'</span><span>)</span><span>
&nbsp;&nbsp;| 0, </span><span class="coqdoc-var">p</span><span> | </span><span class="coqdoc-var">p</span><span>, 0 =&gt; </span><span class="coqdoc-var">p</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-120:
&gt; Fixpoint max (n m:nat) {struct m} : nat :=   match n, m with   | S n', S m' =&gt; S (max n' m')   | 0, p | p, 0 =&gt; p   end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> max already exists.</span></dd>
</dl>
</div>
<p>Similarly, factorization of (not necessarily multiple) patterns that
share the same variables is possible by using the notation <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span></span></code>.
Here is an example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">filter_2_4</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| 2 </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">m</span><span> | 4 </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">m</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">_</span><span> =&gt; 0</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">filter_2_4 is defined</span></dd>
</dl>
</div>
<p>Here is another example using disjunctive subpatterns.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">filter_some_square_corners</span><span> (</span><span class="coqdoc-var">p</span><span>:</span><span class="coqdoc-var">nat</span><span>*</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span>*</span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| ((2 </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">m</span><span> | 4 </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">m</span><span>), (3 </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">n</span><span> | 5 </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">n</span><span>)) =&gt; (</span><span class="coqdoc-var">m</span><span>,</span><span class="coqdoc-var">n</span><span>)</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">_</span><span> =&gt; (0,0)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">filter_some_square_corners is defined</span></dd>
</dl>
</div>
</div>
<div class="section" id="about-patterns-of-parametric-types">
<h2>About patterns of parametric types<a class="headerlink" href="#about-patterns-of-parametric-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="parameters-in-patterns">
<h3>Parameters in patterns<a class="headerlink" href="#parameters-in-patterns" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When matching objects of a parametric type, parameters do not bind in
patterns. They must be substituted by “<code class="docutils literal notranslate"><span class="pre">_</span></code>”. Consider for example the
type of polymorphic lists:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">List</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">List is defined
List_rect is defined
List_ind is defined
List_rec is defined</span></dd>
</dl>
</div>
<p>We can check the function <em>tail</em>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">nat</span><span> =&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">nat</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">l'</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ _ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>When we use parameters in patterns there is an error message:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Check</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">nat</span><span> =&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">A</span><span> =&gt; </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">nat</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">l'</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="first last">The command has indeed failed with message:
The parameters do not bind in patterns; they must be replaced by '_'.</span></dd>
</dl>
</div>
<dl class="flag">
<dt id="coq:flag.asymmetric-patterns">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Asymmetric</span> <span>Patterns</span></span></code><a class="headerlink" href="#coq:flag.asymmetric-patterns" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This flag (off by default) removes parameters from constructors in patterns:</p>
</dd></dl>

<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-var">Asymmetric</span><span> </span><span class="coqdoc-var">Patterns</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">nat</span><span> =&gt;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">nil</span><span> =&gt; </span><span class="coqdoc-var">nil</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">l'</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="first">Toplevel input, characters 72-74:
&gt; Check (fun l:List nat =&gt;   match l with   | nil =&gt; nil   | cons _ l' =&gt; l'   end).
&gt;                                                                         ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
In environment
l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
l' : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
The term &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; has type &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; while it is expected to have type
 &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">&quot;.</span></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-var">Asymmetric</span><span> </span><span class="coqdoc-var">Patterns</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="implicit-arguments-in-patterns">
<h2>Implicit arguments in patterns<a class="headerlink" href="#implicit-arguments-in-patterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>By default, implicit arguments are omitted in patterns. So we write:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">nil</span><span> [</span><span class="coqdoc-var">A</span><span>].</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">cons</span><span> [</span><span class="coqdoc-var">A</span><span>] </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Check</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">nat</span><span> =&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">nil</span><span> =&gt; </span><span class="coqdoc-var">nil</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">l'</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>But the possibility to use all the arguments is given by “<code class="docutils literal notranslate"><span class="pre">&#64;</span></code>” implicit
explicitations (as for terms 2.7.11).</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">List</span><span> </span><span class="coqdoc-var">nat</span><span> =&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &#64;</span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; &#64;</span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">nat</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| &#64;</span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">l'</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                    </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">List</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<div class="section" id="matching-objects-of-dependent-types">
<span id="matching-dependent"></span><h2>Matching objects of dependent types<a class="headerlink" href="#matching-objects-of-dependent-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The previous examples illustrate pattern matching on objects of non-
dependent types, but we can also use the expansion strategy to
destructure objects of dependent types. Consider the type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listn</span></span></code> of
lists of a certain length:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">listn</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">niln</span><span> : </span><span class="coqdoc-var">listn</span><span> 0</span><span>
| </span><span class="coqdoc-var">consn</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">listn</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">listn is defined
listn_rect is defined
listn_ind is defined
listn_rec is defined</span></dd>
</dl>
</div>
</div>
<div class="section" id="understanding-dependencies-in-patterns">
<h2>Understanding dependencies in patterns<a class="headerlink" href="#understanding-dependencies-in-patterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We can define the function length over <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listn</span></span></code> by:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span>) := </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">length is defined</span></dd>
</dl>
</div>
<p>Just for illustrating pattern matching, we can define it by case
analysis:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span>) :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">niln</span><span> =&gt; 0</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">consn</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-99:
&gt; Definition length (n:nat) (l:listn n) :=   match l with   | niln =&gt; 0   | consn n _ _ =&gt; S n   end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> length already exists.</span></dd>
</dl>
</div>
<p>We can understand the meaning of this definition using the same
notions of usual pattern matching.</p>
</div>
<div class="section" id="when-the-elimination-predicate-must-be-provided">
<h2>When the elimination predicate must be provided<a class="headerlink" href="#when-the-elimination-predicate-must-be-provided" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="dependent-pattern-matching">
<h3>Dependent pattern matching<a class="headerlink" href="#dependent-pattern-matching" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The examples given so far do not need an explicit elimination
predicate because all the right hand sides have the same type and Coq
succeeds to synthesize it. Unfortunately when dealing with dependent
patterns it often happens that we need to write cases where the types
of the right hand sides are different instances of the elimination predicate. The
function <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">concat</span></span></code> for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listn</span></span></code> is an example where the branches have
different types and we need to provide the elimination predicate:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">concat</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">l'</span><span>:</span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">m</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">l</span><span>} :</span><span>
&nbsp;</span><span class="coqdoc-var">listn</span><span> (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>) :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">listn</span><span> (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">niln</span><span> =&gt; </span><span class="coqdoc-var">l'</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">consn</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">consn</span><span> (</span><span class="coqdoc-var">n'</span><span> + </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-var">a</span><span> (</span><span class="coqdoc-var">concat</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">l'</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">concat is defined
concat is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
<p>The elimination predicate is <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">listn</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">listn</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">+</span></span><span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code>.
In general if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code> has type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">q1</span></span> <span class="error"><span class="pre">…</span></span> <span class="name"><span class="pre">qr</span></span> <span class="name"><span class="pre">t1</span></span> <span class="error"><span class="pre">…</span></span> <span class="name"><span class="pre">ts</span></span><span class="operator"><span class="pre">)</span></span></code> where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">q1</span></span><span class="operator"><span class="pre">,</span></span> <span class="error"><span class="pre">…</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">qr</span></span></code>
are parameters, the elimination predicate should be of the form <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">y1</span></span> <span class="error"><span class="pre">…</span></span> <span class="name"><span class="pre">ys</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">:</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">q1</span></span> <span class="error"><span class="pre">…</span></span> <span class="name"><span class="pre">qr</span></span> <span class="name"><span class="pre">y1</span></span> <span class="error"><span class="pre">…</span></span> <span class="name"><span class="pre">ys</span></span> <span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">Q</span></span></code>.</p>
<p>In the concrete syntax, it should be written :
<code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">m</span> <span class="pre">as</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">(I</span> <span class="pre">_</span> <span class="pre">…</span> <span class="pre">_</span> <span class="pre">y1</span> <span class="pre">…</span> <span class="pre">ys)</span> <span class="pre">return</span> <span class="pre">Q</span> <span class="pre">with</span> <span class="pre">…</span> <span class="pre">end</span></code>.
The variables which appear in the <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">as</span></code> clause are new and bounded
in the property <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Q</span></span></code> in the return clause. The parameters of the
inductive definitions should not be mentioned and are replaced by <code class="docutils literal notranslate"><span class="pre">_</span></code>.</p>
</div>
<div class="section" id="multiple-dependent-pattern-matching">
<h3>Multiple dependent pattern matching<a class="headerlink" href="#multiple-dependent-pattern-matching" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Recall that a list of patterns is also a pattern. So, when we
destructure several terms at the same time and the branches have
different types we need to provide the elimination predicate for this
multiple pattern. It is done using the same scheme: each term may be
associated to an <code class="docutils literal notranslate"><span class="pre">as</span></code> clause and an <code class="docutils literal notranslate"><span class="pre">in</span></code> clause in order to introduce
a dependent product.</p>
<p>For example, an equivalent definition for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">concat</span></span></code> (even though the
matching on the second term is trivial) would have been:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">concat</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">l'</span><span>:</span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">m</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">l</span><span>} :</span><span>
&nbsp;</span><span class="coqdoc-var">listn</span><span> (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>) :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">l'</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">listn</span><span> (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">niln</span><span>, </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">x</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">consn</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">consn</span><span> (</span><span class="coqdoc-var">n'</span><span> + </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-var">a</span><span> (</span><span class="coqdoc-var">concat</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">x</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-220:
&gt; Fixpoint concat (n:nat) (l:listn n) (m:nat) (l':listn m) {struct l} :  listn (n + m) :=   match l in listn n, l' return listn (n + m) with   | niln, x =&gt; x   | consn n' a y, x =&gt; consn (n' + m) a (concat n' y m x)   end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> concat already exists.</span></dd>
</dl>
</div>
<p>Even without real matching over the second term, this construction can
be used to keep types linked. If <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> are two <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listn</span></span></code> of the same
length, by writing</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>: </span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span>) =&gt;</span><span>
&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">a</span><span>, </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;| </span><span class="coqdoc-var">niln</span><span>, </span><span class="coqdoc-var">b0</span><span> =&gt; </span><span class="coqdoc-var">tt</span><span>
&nbsp;| </span><span class="coqdoc-var">consn</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">bS</span><span> =&gt; </span><span class="coqdoc-var">tt</span><span>
&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (a _ : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">listn</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                                 | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">niln</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> | _ =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tt</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                                 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">listn</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">listn</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">unit</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>we have a copy of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> in type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listn</span></span> <span class="literal number integer"><span class="pre">0</span></span></code> resp. <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listn</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n'</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
</div>
<div class="section" id="patterns-in-in">
<span id="match-in-patterns"></span><h3>Patterns in <code class="docutils literal notranslate"><span class="pre">in</span></code><a class="headerlink" href="#patterns-in-in" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>If the type of the matched term is more precise than an inductive
applied to variables, arguments of the inductive in the <code class="docutils literal notranslate"><span class="pre">in</span></code> branch can
be more complicated patterns than a variable.</p>
<p>Moreover, constructors whose types do not follow the same pattern will
become impossible branches. In an impossible branch, you can answer
anything but False_rect unit has the advantage to be subterm of
anything.</p>
<p>To be concrete: the <code class="docutils literal notranslate"><span class="pre">tail</span></code> function can be written:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">tail</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">v</span><span>: </span><span class="coqdoc-var">listn</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)) :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">v</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">listn</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">niln</span><span> =&gt; </span><span class="coqdoc-var">False_rect</span><span> </span><span class="coqdoc-var">unit</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">consn</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">y</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">tail is defined</span></dd>
</dl>
</div>
<p>and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tail</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">v</span></span></code> will be subterm of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">v</span></span></code>.</p>
</div>
</div>
<div class="section" id="using-pattern-matching-to-write-proofs">
<h2>Using pattern matching to write proofs<a class="headerlink" href="#using-pattern-matching-to-write-proofs" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In all the previous examples the elimination predicate does not depend
on the object(s) matched. But it may depend and the typical case is
when we write a proof by induction or a function that yields an object
of a dependent type. An example of a proof written using <code class="docutils literal notranslate"><span class="pre">match</span></code> is given
in the description of the tactic <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a>.</p>
<p>For example, we can write the function <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">buildlist</span></span></code> that given a natural
number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> builds a list of length <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> containing zeros as follows:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">buildlist</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">listn</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">niln</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span> =&gt; </span><span class="coqdoc-var">consn</span><span> </span><span class="coqdoc-var">n</span><span> 0 (</span><span class="coqdoc-var">buildlist</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">buildlist is defined
buildlist is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
<p>We can also use multiple patterns. Consider the following definition
of the predicate less-equal <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Le</span></span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">LE</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">LEO</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">LE</span><span> 0 </span><span class="coqdoc-var">n</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">LES</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">LE</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">LE is defined
LE_ind is defined</span></dd>
</dl>
</div>
<p>We can use multiple patterns to write the proof of the lemma
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">),</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">LE</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">LE</span></span> <span class="name"><span class="pre">m</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">dec</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> \/ </span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> \/ </span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span>, </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">x</span><span> 0) (</span><span class="coqdoc-var">LEO</span><span> </span><span class="coqdoc-var">x</span><span>)</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">x</span><span> 0) (</span><span class="coqdoc-var">LEO</span><span> </span><span class="coqdoc-var">x</span><span>)</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">n'</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">m'</span><span> =&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">dec</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">or_introl</span><span> </span><span class="coqdoc-var">h</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">m'</span><span> </span><span class="coqdoc-var">n'</span><span>) (</span><span class="coqdoc-var">LES</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">h</span><span>)</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">or_intror</span><span> </span><span class="coqdoc-var">h</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">LE</span><span> </span><span class="coqdoc-var">n'</span><span> </span><span class="coqdoc-var">m'</span><span>) (</span><span class="coqdoc-var">LES</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">h</span><span>)</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">dec is defined
dec is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
<p>In the example of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">dec</span></span></code>, the first match is dependent while the second
is not.</p>
<p>The user can also use match in combination with the tactic <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> (see
Section 8.2.3) to build incomplete proofs beginning with a match
construction.</p>
</div>
<div class="section" id="pattern-matching-on-inductive-objects-involving-local-definitions">
<h2>Pattern-matching on inductive objects involving local definitions<a class="headerlink" href="#pattern-matching-on-inductive-objects-involving-local-definitions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>If local definitions occur in the type of a constructor, then there
are two ways to match on this constructor. Either the local
definitions are skipped and matching is done only on the true
arguments of the constructors, or the bindings for local definitions
can also be caught in the matching.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> 0</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">m</span><span> := (2 * </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>)).</span></dt>
<dd class="coqtop-hidden"><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
</dl>
</div>
<p>In the next example, the local definition is not caught.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">n</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">l</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">nil</span><span> =&gt; 0</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">l0</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">length</span><span> (2 * </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">l0</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-122:
&gt; Fixpoint length n (l:list n) {struct l} : nat :=   match l with   | nil =&gt; 0   | cons n l0 =&gt; S (length (2 * n) l0)   end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> length already exists.</span></dd>
</dl>
</div>
<p>But in this example, it is.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">length'</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">n</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">l</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">nil</span><span> =&gt; 0</span><span>
&nbsp;&nbsp;| &#64;</span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">l0</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">length'</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">l0</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">length' is defined
length' is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">For a given matching clause, either none of the local
definitions or all of them can be caught.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">You can only catch let bindings in mode where you bind all
variables and so you have to use <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> syntax.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">this feature is incoherent with the fact that parameters
cannot be caught and consequently is somehow hidden. For example,
there is no mention of it in error messages.</p>
</div>
</div>
<div class="section" id="pattern-matching-and-coercions">
<h2>Pattern-matching and coercions<a class="headerlink" href="#pattern-matching-and-coercions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>If a mismatch occurs between the expected type of a pattern and its
actual type, a coercion made from constructors is sought. If such a
coercion can be found, it is automatically inserted around the
pattern.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">C1</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">I</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">C2</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">I</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">I is defined
I_rect is defined
I_ind is defined
I_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Coercion</span><span> </span><span class="coqdoc-var">C1</span><span> : </span><span class="coqdoc-var">nat</span><span> &gt;-&gt; </span><span class="coqdoc-var">I</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">C1 is now a coercion</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">C2</span><span> </span><span class="coqdoc-var">O</span><span> =&gt; 0</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">_</span><span> =&gt; 0</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">I</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
             | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ | _ =&gt; 0
             </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">I</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="when-does-the-expansion-strategy-fail">
<h2>When does the expansion strategy fail?<a class="headerlink" href="#when-does-the-expansion-strategy-fail" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The strategy works very like in ML languages when treating patterns of
non-dependent types. But there are new cases of failure that are due to
the presence of dependencies.</p>
<p>The error messages of the current implementation may be sometimes
confusing. When the tactic fails because patterns are somehow
incorrect then error messages refer to the initial expression. But the
strategy may succeed to build an expression whose sub-expressions are
well typed when the whole expression is not. In this situation the
message makes reference to the expanded expression. We encourage
users, when they have patterns with the same outer constructor in
different equations, to name the variable patterns in the same
positions with the same name. E.g. to write <code class="docutils literal notranslate"><span class="pre">(cons</span> <span class="pre">n</span> <span class="pre">O</span> <span class="pre">x)</span> <span class="pre">=&gt;</span> <span class="pre">e1</span></code> and
<code class="docutils literal notranslate"><span class="pre">(cons</span> <span class="pre">n</span> <span class="pre">_</span> <span class="pre">x)</span> <span class="pre">=&gt;</span> <span class="pre">e2</span></code> instead of <code class="docutils literal notranslate"><span class="pre">(cons</span> <span class="pre">n</span> <span class="pre">O</span> <span class="pre">x)</span> <span class="pre">=&gt;</span> <span class="pre">e1</span></code> and
<code class="docutils literal notranslate"><span class="pre">(cons</span> <span class="pre">n'</span> <span class="pre">_</span> <span class="pre">x')</span> <span class="pre">=&gt;</span> <span class="pre">e2</span></code>. This helps to maintain certain name correspondence between the
generated expression and the original.</p>
<p>Here is a summary of the error messages corresponding to each
situation:</p>
<dl class="exn">
<dt id="coq:exn.the-constructor-ident-expects-num-arguments">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <span>constructor</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>expects</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>arguments.</span></span></code><a class="headerlink" href="#coq:exn.the-constructor-ident-expects-num-arguments" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The variable ident is bound several times in pattern termFound a constructor
of inductive type term while a constructor of term is expectedPatterns are
incorrect (because constructors are not applied to the correct number of the
arguments, because they are not linear or they are wrongly typed).</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.non-exhaustive-pattern-matching">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Non</span> <span>exhaustive</span> <span>pattern</span> <span>matching.</span></span></code><a class="headerlink" href="#coq:exn.non-exhaustive-pattern-matching" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The pattern matching is not exhaustive.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.the-elimination-predicate-term-should-be-of-arity-num-for-non-dependent-case-or-num-for-dependent-case">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <span>elimination</span> <span>predicate</span> <span>term</span> <span>should</span> <span>be</span> <span>of</span> <span>arity</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>(for</span> <span>non</span> <span>dependent</span> <span>case)</span> <span>or</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>(for</span> <span>dependent</span> <span>case).</span></span></code><a class="headerlink" href="#coq:exn.the-elimination-predicate-term-should-be-of-arity-num-for-non-dependent-case-or-num-for-dependent-case" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The elimination predicate provided to match has not the expected arity.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.unable-to-infer-a-match-predicate">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Unable</span> <span>to</span> <span>infer</span> <span>a</span> <span>match</span> <span>predicate</span></span></code><a class="headerlink" href="#coq:exn.unable-to-infer-a-match-predicate" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:exn.either-there-is-a-type-incompatibility-or-the-problem-involves-dependencies">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Either</span> <span>there</span> <span>is</span> <span>a</span> <span>type</span> <span>incompatibility</span> <span>or</span> <span>the</span> <span>problem</span> <span>involves</span> <span>dependencies.</span></span></code><a class="headerlink" href="#coq:exn.either-there-is-a-type-incompatibility-or-the-problem-involves-dependencies" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>There is a type mismatch between the different branches. The user should
provide an elimination predicate.</p>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="implicit-coercions.html" class="btn btn-neutral float-right" title="Implicit Coercions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../practical-tools/coqide.html" class="btn btn-neutral" title="Coq Integrated Development Environment" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>