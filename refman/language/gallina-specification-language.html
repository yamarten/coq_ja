

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The Gallina specification language &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="Extensions of Gallina" href="gallina-extensions.html" />
    <link rel="prev" title="Credits" href="../credits.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">The Gallina specification language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#about-the-grammars-in-the-manual">About the grammars in the manual</a></li>
<li class="toctree-l2"><a class="reference internal" href="#lexical-conventions">Lexical conventions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#terms">Terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax-of-terms">Syntax of terms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#qualified-identifiers-and-simple-identifiers">Qualified identifiers and simple identifiers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#numerals">Numerals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#binders">Binders</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abstractions">Abstractions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#products">Products</a></li>
<li class="toctree-l3"><a class="reference internal" href="#applications">Applications</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-cast">Type cast</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inferable-subterms">Inferable subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#let-in-definitions">Let-in definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definition-by-case-analysis">Definition by case analysis</a></li>
<li class="toctree-l3"><a class="reference internal" href="#recursive-functions">Recursive functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-vernacular">The Vernacular</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#assumptions">Assumptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-definitions">Inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-inductive-types">Simple inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#simple-annotated-inductive-types">Simple annotated inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#parametrized-inductive-types">Parametrized inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants">Variants</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mutually-defined-inductive-types">Mutually defined inductive types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#co-inductive-types">Co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#definition-of-recursive-functions">Definition of recursive functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#definition-of-functions-by-recursion-over-inductive-objects">Definition of functions by recursion over inductive objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#definitions-of-recursive-objects-in-co-inductive-types">Definitions of recursive objects in co-inductive types</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertions-and-proofs">Assertions and proofs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The Gallina specification language</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/gallina-specification-language.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-gallina-specification-language">
<span id="gallinaspecificationlanguage"></span><h1>The Gallina specification language<a class="headerlink" href="#the-gallina-specification-language" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>This chapter describes Gallina, the specification language of Coq. It allows
developing mathematical theories and to prove specifications of programs. The
theories are built from axioms, hypotheses, parameters, lemmas, theorems and
definitions of constants, functions, predicates and sets. The syntax of logical
objects involved in theories is described in Section <a class="reference internal" href="#term"><span class="std std-ref">Terms</span></a>. The
language of commands, called <em>The Vernacular</em> is described in Section
<a class="reference internal" href="#vernacular"><span class="std std-ref">The Vernacular</span></a>.</p>
<p>In Coq, logical objects are typed to ensure their logical correctness.  The
rules implemented by the typing algorithm are described in Chapter <a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a>.</p>
<div class="section" id="about-the-grammars-in-the-manual">
<h2>About the grammars in the manual<a class="headerlink" href="#about-the-grammars-in-the-manual" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Grammars are presented in Backus-Naur form (BNF). Terminal symbols are
set in black <code class="docutils literal notranslate"><span class="pre">typewriter</span> <span class="pre">font</span></code>. In addition, there are special notations for
regular expressions.</p>
<p>An expression enclosed in square brackets <code class="docutils literal notranslate"><span class="pre">[…]</span></code> means at most one
occurrence of this expression (this corresponds to an optional
component).</p>
<p>The notation “<code class="docutils literal notranslate"><span class="pre">entry</span> <span class="pre">sep</span> <span class="pre">…</span> <span class="pre">sep</span> <span class="pre">entry</span></code>” stands for a non empty sequence
of expressions parsed by entry and separated by the literal “<code class="docutils literal notranslate"><span class="pre">sep</span></code>” <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>Similarly, the notation “<code class="docutils literal notranslate"><span class="pre">entry</span> <span class="pre">…</span> <span class="pre">entry</span></code>” stands for a non empty
sequence of expressions parsed by the “<code class="docutils literal notranslate"><span class="pre">entry</span></code>” entry, without any
separator between.</p>
<p>At the end, the notation “<code class="docutils literal notranslate"><span class="pre">[entry</span> <span class="pre">sep</span> <span class="pre">…</span> <span class="pre">sep</span> <span class="pre">entry]</span></code>” stands for a
possibly empty sequence of expressions parsed by the “<code class="docutils literal notranslate"><span class="pre">entry</span></code>” entry,
separated by the literal “<code class="docutils literal notranslate"><span class="pre">sep</span></code>”.</p>
</div>
<div class="section" id="lexical-conventions">
<span id="id2"></span><h2>Lexical conventions<a class="headerlink" href="#lexical-conventions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="docutils">
<dt>Blanks</dt>
<dd>Space, newline and horizontal tabulation are considered as blanks.
Blanks are ignored but they separate tokens.</dd>
<dt>Comments</dt>
<dd>Comments in Coq are enclosed between <code class="docutils literal notranslate"><span class="pre">(*</span></code> and <code class="docutils literal notranslate"><span class="pre">*)</span></code>, and can be nested.
They can contain any character. However, <a class="reference internal" href="#grammar-token-string"><code class="xref std std-token docutils literal notranslate"><span class="pre">string</span></code></a> literals must be
correctly closed. Comments are treated as blanks.</dd>
<dt>Identifiers and access identifiers</dt>
<dd><p class="first">Identifiers, written <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>, are sequences of letters, digits, <code class="docutils literal notranslate"><span class="pre">_</span></code> and
<code class="docutils literal notranslate"><span class="pre">'</span></code>, that do not start with a digit or <code class="docutils literal notranslate"><span class="pre">'</span></code>. That is, they are
recognized by the following lexical class:</p>
<pre>
<strong id="grammar-token-first_letter">first_letter     </strong> ::=  a..z ∣ A..Z ∣ _ ∣ unicode-letter
<strong id="grammar-token-subsequent_letter">subsequent_letter</strong> ::=  a..z ∣ A..Z ∣ 0..9 ∣ _ ∣ ' ∣ unicode-letter ∣ unicode-id-part
<strong id="grammar-token-ident">ident            </strong> ::=  <a class="reference internal" href="#grammar-token-first_letter"><code class="xref docutils literal notranslate"><span class="pre">first_letter</span></code></a>[<a class="reference internal" href="#grammar-token-subsequent_letter"><code class="xref docutils literal notranslate"><span class="pre">subsequent_letter</span></code></a>…<a class="reference internal" href="#grammar-token-subsequent_letter"><code class="xref docutils literal notranslate"><span class="pre">subsequent_letter</span></code></a>]
<strong id="grammar-token-access_ident">access_ident     </strong> ::=  .<a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
</pre>
<p>All characters are meaningful. In particular, identifiers are case-sensitive.
The entry <code class="docutils literal notranslate"><span class="pre">unicode-letter</span></code> non-exhaustively includes Latin,
Greek, Gothic, Cyrillic, Arabic, Hebrew, Georgian, Hangul, Hiragana
and Katakana characters, CJK ideographs, mathematical letter-like
symbols, hyphens, non-breaking space, … The entry <code class="docutils literal notranslate"><span class="pre">unicode-id-part</span></code>
non-exhaustively includes symbols for prime letters and subscripts.</p>
<p class="last">Access identifiers, written <a class="reference internal" href="#grammar-token-access_ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">access_ident</span></code></a>, are identifiers prefixed by
<cite>.</cite> (dot) without blank. They are used in the syntax of qualified
identifiers.</p>
</dd>
<dt>Natural numbers and integers</dt>
<dd><p class="first">Numerals are sequences of digits. Integers are numerals optionally
preceded by a minus sign.</p>
<pre class="last">
<strong id="grammar-token-digit">digit  </strong> ::=  0..9
<strong id="grammar-token-num">num    </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a>…<a class="reference internal" href="#grammar-token-digit"><code class="xref docutils literal notranslate"><span class="pre">digit</span></code></a>
<strong id="grammar-token-integer">integer</strong> ::=  [-]<a class="reference internal" href="#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a>
</pre>
</dd>
<dt>Strings</dt>
<dd>Strings are delimited by <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> (double quote), and enclose a sequence of
any characters different from <code class="docutils literal notranslate"><span class="pre">&quot;</span></code> or the sequence <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> to denote the
double quote character. In grammars, the entry for quoted strings is
<span class="inline-grammar-production"><span class="target" id="grammar-token-string"></span><code class="docutils literal notranslate"><span class="pre">string</span></code></span>.</dd>
<dt>Keywords</dt>
<dd><p class="first">The following identifiers are reserved keywords, and cannot be
employed otherwise:</p>
<div class="last highlight-text notranslate"><div class="highlight"><pre><span></span>_ as at cofix else end exists exists2 fix for
forall fun if IF in let match mod Prop return
Set then Type using where with
</pre></div>
</div>
</dd>
<dt>Special tokens</dt>
<dd><p class="first">The following sequences of characters are special tokens:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>! % &amp; &amp;&amp; ( () ) * + ++ , - -&gt; . .( ..
/ /\ : :: :&lt; := :&gt; ; &lt; &lt;- &lt;-&gt; &lt;: &lt;= &lt;&gt; =
=&gt; =_D &gt; &gt;-&gt; &gt;= ? ?= @ [ \/ ] ^ { | |-
|| } ~
</pre></div>
</div>
<p class="last">Lexical ambiguities are resolved according to the “longest match”
rule: when a sequence of non alphanumerical characters can be
decomposed into several different ways, then the first token is the
longest possible one (among all tokens defined at this moment), and so
on.</p>
</dd>
</dl>
</div>
<div class="section" id="terms">
<span id="term"></span><h2>Terms<a class="headerlink" href="#terms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="syntax-of-terms">
<h3>Syntax of terms<a class="headerlink" href="#syntax-of-terms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following grammars describe the basic syntax of the terms of the
<em>Calculus of Inductive Constructions</em> (also called Cic). The formal
presentation of Cic is given in Chapter <a class="reference internal" href="cic.html#calculusofinductiveconstructions"><span class="std std-ref">Calculus of Inductive Constructions</span></a>. Extensions of this syntax
are given in Chapter <a class="reference internal" href="gallina-extensions.html#extensionsofgallina"><span class="std std-ref">Extensions of Gallina</span></a>. How to customize the syntax
is described in Chapter <a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a>.</p>
<pre>
<strong id="grammar-token-term">term        </strong> ::=  forall <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> , <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | fun <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | fix <a class="reference internal" href="#grammar-token-fix_bodies"><code class="xref docutils literal notranslate"><span class="pre">fix_bodies</span></code></a>
                  | cofix <a class="reference internal" href="#grammar-token-cofix_bodies"><code class="xref docutils literal notranslate"><span class="pre">cofix_bodies</span></code></a>
                  | let <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let fix <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let cofix <a class="reference internal" href="#grammar-token-cofix_body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let ( [<a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> , … , <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] ) [<a class="reference internal" href="#grammar-token-dep_ret_type"><code class="xref docutils literal notranslate"><span class="pre">dep_ret_type</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | let ' <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> [in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> [<a class="reference internal" href="#grammar-token-return_type"><code class="xref docutils literal notranslate"><span class="pre">return_type</span></code></a>] in <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | if <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> [<a class="reference internal" href="#grammar-token-dep_ret_type"><code class="xref docutils literal notranslate"><span class="pre">dep_ret_type</span></code></a>] then <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> else <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> &lt;: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> :&gt;
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> -&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> <a class="reference internal" href="#grammar-token-arg"><code class="xref docutils literal notranslate"><span class="pre">arg</span></code></a> … <a class="reference internal" href="#grammar-token-arg"><code class="xref docutils literal notranslate"><span class="pre">arg</span></code></a>
                  | &#64; <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> [<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> … <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>]
                  | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> % <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
                  | match <a class="reference internal" href="#grammar-token-match_item"><code class="xref docutils literal notranslate"><span class="pre">match_item</span></code></a> , … , <a class="reference internal" href="#grammar-token-match_item"><code class="xref docutils literal notranslate"><span class="pre">match_item</span></code></a> [<a class="reference internal" href="#grammar-token-return_type"><code class="xref docutils literal notranslate"><span class="pre">return_type</span></code></a>] with
                    [[|] <a class="reference internal" href="#grammar-token-equation"><code class="xref docutils literal notranslate"><span class="pre">equation</span></code></a> | … | <a class="reference internal" href="#grammar-token-equation"><code class="xref docutils literal notranslate"><span class="pre">equation</span></code></a>] end
                  | <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a>
                  | <a class="reference internal" href="#grammar-token-sort"><code class="xref docutils literal notranslate"><span class="pre">sort</span></code></a>
                  | <a class="reference internal" href="#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a>
                  | _
                  | ( <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
<strong id="grammar-token-arg">arg         </strong> ::=  <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                  | ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
<strong id="grammar-token-binders">binders     </strong> ::=  <a class="reference internal" href="#grammar-token-binder"><code class="xref docutils literal notranslate"><span class="pre">binder</span></code></a> … <a class="reference internal" href="#grammar-token-binder"><code class="xref docutils literal notranslate"><span class="pre">binder</span></code></a>
<strong id="grammar-token-binder">binder      </strong> ::=  <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>
                  | ( <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> … <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
                  | ( <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a> [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
                  | ' <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
<strong id="grammar-token-name">name        </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> | _
<strong id="grammar-token-qualid">qualid      </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> | <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="#grammar-token-access_ident"><code class="xref docutils literal notranslate"><span class="pre">access_ident</span></code></a>
<strong id="grammar-token-sort">sort        </strong> ::=  Prop | Set | Type
<strong id="grammar-token-fix_bodies">fix_bodies  </strong> ::=  <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a>
                  | <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> for <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
<strong id="grammar-token-cofix_bodies">cofix_bodies</strong> ::=  <a class="reference internal" href="#grammar-token-cofix_body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a>
                  | <a class="reference internal" href="#grammar-token-cofix_body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> with <a class="reference internal" href="#grammar-token-cofix_body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-cofix_body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> for <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
<strong id="grammar-token-fix_body">fix_body    </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> <a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a> [<a class="reference internal" href="#grammar-token-annotation"><code class="xref docutils literal notranslate"><span class="pre">annotation</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-cofix_body">cofix_body  </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-annotation">annotation  </strong> ::=  { struct <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> }
<strong id="grammar-token-match_item">match_item  </strong> ::=  <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> [as <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] [in <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> [<a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> … <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>]]
<strong id="grammar-token-dep_ret_type">dep_ret_type</strong> ::=  [as <a class="reference internal" href="#grammar-token-name"><code class="xref docutils literal notranslate"><span class="pre">name</span></code></a>] <a class="reference internal" href="#grammar-token-return_type"><code class="xref docutils literal notranslate"><span class="pre">return_type</span></code></a>
<strong id="grammar-token-return_type">return_type </strong> ::=  return <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-equation">equation    </strong> ::=  <a class="reference internal" href="#grammar-token-mult_pattern"><code class="xref docutils literal notranslate"><span class="pre">mult_pattern</span></code></a> | … | <a class="reference internal" href="#grammar-token-mult_pattern"><code class="xref docutils literal notranslate"><span class="pre">mult_pattern</span></code></a> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
<strong id="grammar-token-mult_pattern">mult_pattern</strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> , … , <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
<strong id="grammar-token-pattern">pattern     </strong> ::=  <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> … <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
                  | &#64; <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a> <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> … <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
                  | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> as <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
                  | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> % <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a>
                  | <a class="reference internal" href="#grammar-token-qualid"><code class="xref docutils literal notranslate"><span class="pre">qualid</span></code></a>
                  | _
                  | <a class="reference internal" href="#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a>
                  | ( <a class="reference internal" href="#grammar-token-or_pattern"><code class="xref docutils literal notranslate"><span class="pre">or_pattern</span></code></a> , … , <a class="reference internal" href="#grammar-token-or_pattern"><code class="xref docutils literal notranslate"><span class="pre">or_pattern</span></code></a> )
<strong id="grammar-token-or_pattern">or_pattern  </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a> | … | <a class="reference internal" href="#grammar-token-pattern"><code class="xref docutils literal notranslate"><span class="pre">pattern</span></code></a>
</pre>
</div>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Coq terms are typed. Coq types are recognized by the same syntactic
class as <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. We denote by <span class="inline-grammar-production"><span class="target" id="grammar-token-type"></span><code class="docutils literal notranslate"><span class="pre">type</span></code></span> the semantic subclass
of types inside the syntactic class <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
</div>
<div class="section" id="qualified-identifiers-and-simple-identifiers">
<span id="gallina-identifiers"></span><h3>Qualified identifiers and simple identifiers<a class="headerlink" href="#qualified-identifiers-and-simple-identifiers" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>Qualified identifiers</em> (<a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a>) denote <em>global constants</em>
(definitions, lemmas, theorems, remarks or facts), <em>global variables</em>
(parameters or axioms), <em>inductive types</em> or <em>constructors of inductive
types</em>. <em>Simple identifiers</em> (or shortly <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>) are a syntactic subset
of qualified identifiers. Identifiers may also denote <em>local variables</em>,
while qualified identifiers do not.</p>
</div>
<div class="section" id="numerals">
<h3>Numerals<a class="headerlink" href="#numerals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Numerals have no definite semantics in the calculus. They are mere
notations that can be bound to objects through the notation mechanism
(see Chapter&nbsp;<a class="reference internal" href="../user-extensions/syntax-extensions.html#syntaxextensionsandinterpretationscopes"><span class="std std-ref">Syntax extensions and interpretation scopes</span></a> for details).
Initially, numerals are bound to Peano’s representation of natural
numbers (see&nbsp;<a class="reference internal" href="coq-library.html#datatypes"><span class="std std-ref">Datatypes</span></a>).</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Negative integers are not at the same level as <a class="reference internal" href="#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a>, for this
would make precedence unnatural.</p>
</div>
</div>
<div class="section" id="sorts">
<span id="index-0"></span><h3>Sorts<a class="headerlink" href="#sorts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>There are three sorts <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.</p>
<ul class="simple">
<li><code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>&nbsp;is the universe of <em>logical propositions</em>. The logical propositions
themselves are typing the proofs. We denote propositions by <span class="inline-grammar-production"><span class="target" id="grammar-token-form"></span><code class="docutils literal notranslate"><span class="pre">form</span></code></span>.
This constitutes a semantic subclass of the syntactic class <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</li>
<li><code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code>&nbsp;is is the universe of <em>program types</em> or <em>specifications</em>. The
specifications themselves are typing the programs. We denote
specifications by <span class="inline-grammar-production"><span class="target" id="grammar-token-specif"></span><code class="docutils literal notranslate"><span class="pre">specif</span></code></span>. This constitutes a semantic subclass of
the syntactic class <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</li>
<li><code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> is the type of <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code></li>
</ul>
<p>More on sorts can be found in Section&nbsp;<a class="reference internal" href="cic.html#sorts"><span class="std std-ref">Sorts</span></a>.</p>
</div>
<div class="section" id="binders">
<span id="id3"></span><h3>Binders<a class="headerlink" href="#binders" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Various constructions such as <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fix</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">cofix</span></span></code>
<em>bind</em> variables. A binding is represented by an identifier. If the binding
variable is not used in the expression, the identifier can be replaced by the
symbol <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code>. When the type of a bound variable cannot be synthesized by the
system, it can be specified with the notation <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">&nbsp;:&nbsp;</span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>. There is also
a notation for a sequence of binding variables sharing the same type:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">&nbsp;:&nbsp;</span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>. A
binder can also be any pattern prefixed by a quote, e.g. <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">'</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">,</span></span><span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
<p>Some constructions allow the binding of a variable to value. This is
called a “let-binder”. The entry <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a> of the grammar accepts
either an assumption binder as defined above or a let-binder. The notation in
the latter case is <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">&nbsp;:=&nbsp;</span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code>. In a let-binder, only one
variable can be introduced at the same time. It is also possible to give
the type of the variable as follows:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">&nbsp;:&nbsp;</span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">&nbsp;:=&nbsp;</span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code>.</p>
<p>Lists of <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a> are allowed. In the case of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code>,
it is intended that at least one binder of the list is an assumption otherwise
fun and forall gets identical. Moreover, parentheses can be omitted in
the case of a single sequence of bindings sharing the same type (e.g.:
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">y</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">z</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">:</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">=&gt;</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">t</span></span></code> can be shortened in <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">x</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">y</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">z</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">:</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">A</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">=&gt;</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">t</span></span></code>).</p>
</div>
<div class="section" id="abstractions">
<span id="index-1"></span><h3>Abstractions<a class="headerlink" href="#abstractions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> defines the
<em>abstraction</em> of the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>, of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, over the term
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. It denotes a function of the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> that evaluates to
the expression <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> (e.g. <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">x</span></span></code> denotes the identity
function on type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>). The keyword <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span></code> can be followed by several
binders as given in Section&nbsp;<a class="reference internal" href="#binders"><span class="std std-ref">Binders</span></a>. Functions over
several variables are equivalent to an iteration of one-variable
functions. For instance the expression
“fun&nbsp;<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_{1}\)</span>&nbsp;…&nbsp;<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_{n}\)</span>
:&nbsp;<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>&nbsp;=&gt;&nbsp;<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>”
denotes the same function as “ fun&nbsp;<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_{1}\)</span>&nbsp;:&nbsp;<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>&nbsp;=&gt;&nbsp;…
fun&nbsp;<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_{n}\)</span>&nbsp;:&nbsp;<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>&nbsp;=&gt;&nbsp;<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>”. If
a let-binder occurs in
the list of binders, it is expanded to a let-in definition (see
Section&nbsp;<a class="reference internal" href="#let-in"><span class="std std-ref">Let-in definitions</span></a>).</p>
</div>
<div class="section" id="products">
<span id="index-2"></span><h3>Products<a class="headerlink" href="#products" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall&nbsp;</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">&nbsp;:&nbsp;</span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">,&nbsp;</span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> denotes the
<em>product</em> of the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, over the term <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.
As for abstractions, <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span></code> is followed by a binder list, and products
over several variables are equivalent to an iteration of one-variable
products. Note that <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is intended to be a type.</p>
<p>If the variable <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> occurs in <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, the product is called
<em>dependent product</em>. The intention behind a dependent product
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">x</span></span><span class="pre">&nbsp;</span><span class="operator"><span class="pre">:</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">B</span></span></code> is twofold. It denotes either
the universal quantification of the variable <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> of type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>
in the proposition <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> or the functional dependent product from
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> (a construction usually written
<span class="math notranslate">\(\Pi_{x:A}.B\)</span> in set theory).</p>
<p>Non dependent product types have a special notation: <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> stands for
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="operator"><span class="pre">_</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span><span class="pre">&nbsp;</span><span class="name"><span class="pre">B</span></span></code>. The <em>non dependent product</em> is used both to denote
the propositional implication and function types.</p>
</div>
<div class="section" id="applications">
<h3>Applications<a class="headerlink" href="#applications" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The expression <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_0\)</span> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span> denotes the
application of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_0\)</span> to <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span>.</p>
<p>The expression <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_0\)</span> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span> ...
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_n\)</span> denotes the application of the term
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_0\)</span> to the arguments <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span> ... then
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_n\)</span>. It is equivalent to ( … ( <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_0\)</span>
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span> ) … ) <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_n\)</span> : associativity is to the
left.</p>
<p>The notation <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">&nbsp;:=&nbsp;</span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code> for arguments is used for making
explicit the value of implicit arguments (see
Section&nbsp;<a class="reference internal" href="gallina-extensions.html#explicit-applications"><span class="std std-ref">Explicit applications</span></a>).</p>
</div>
<div class="section" id="type-cast">
<span id="index-3"></span><h3>Type cast<a class="headerlink" href="#type-cast" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The expression <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">&nbsp;:&nbsp;</span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> is a type cast expression. It enforces
the type of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to be <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">&nbsp;&lt;:&nbsp;</span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> locally sets up the virtual machine for checking that
<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<p><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">&nbsp;&lt;&lt;:&nbsp;</span></span><a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> uses native compilation for checking that <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>
has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</div>
<div class="section" id="inferable-subterms">
<span id="index-4"></span><h3>Inferable subterms<a class="headerlink" href="#inferable-subterms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Expressions often contain redundant pieces of information. Subterms that can be
automatically inferred by Coq can be replaced by the symbol <code class="docutils literal notranslate"><span class="pre">_</span></code> and Coq will
guess the missing piece of information.</p>
</div>
<div class="section" id="let-in-definitions">
<span id="let-in"></span><span id="index-5"></span><h3>Let-in definitions<a class="headerlink" href="#let-in-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code>
denotes the local binding of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to the variable
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>’. There is a syntactic sugar for let-in
definition of functions: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code>
stands for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binder"><span class="hole"><span class="pre">binder</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code>.</p>
</div>
<div class="section" id="definition-by-case-analysis">
<span id="index-6"></span><h3>Definition by case analysis<a class="headerlink" href="#definition-by-case-analysis" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Objects of inductive types can be destructurated by a case-analysis
construction called <em>pattern matching</em> expression. A pattern matching
expression is used to analyze the structure of an inductive object and
to apply specific treatments accordingly.</p>
<p>This paragraph describes the basic form of pattern matching. See
Section <a class="reference internal" href="gallina-extensions.html#mult-match"><span class="std std-ref">Multiple and nested pattern matching</span></a> and Chapter <a class="reference internal" href="../addendum/extended-pattern-matching.html#extendedpatternmatching"><span class="std std-ref">Extended pattern matching</span></a> for the description
of the general form. The basic form of pattern matching is characterized
by a single <a class="reference internal" href="#grammar-token-match_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">match_item</span></code></a> expression, a <a class="reference internal" href="#grammar-token-mult_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult_pattern</span></code></a> restricted to a
single <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> and <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> restricted to the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>.</p>
<p>The expression match &quot;<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_0\)</span> <a class="reference internal" href="#grammar-token-return_type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> with
<a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate">\(_1\)</span> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span> <span class="math notranslate">\(|\)</span> … <span class="math notranslate">\(|\)</span>
<a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate">\(_n\)</span> =&gt; <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_n\)</span> end&quot; denotes a
<em>pattern matching</em> over the term <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_0\)</span> (expected to be
of an inductive type <span class="math notranslate">\(I\)</span>). The terms <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span>…<a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_n\)</span> are the <em>branches</em> of the pattern matching
expression. Each of <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate">\(_i\)</span> has a form <a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a>
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> where <a class="reference internal" href="#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> must denote a constructor. There should be
exactly one branch for every constructor of <span class="math notranslate">\(I\)</span>.</p>
<p>The <a class="reference internal" href="#grammar-token-return_type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> expresses the type returned by the whole match
expression. There are several cases. In the <em>non dependent</em> case, all
branches have the same type, and the <a class="reference internal" href="#grammar-token-return_type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> is the common type of
branches. In this case, <a class="reference internal" href="#grammar-token-return_type"><code class="xref std std-token docutils literal notranslate"><span class="pre">return_type</span></code></a> can usually be omitted as it can be
inferred from the type of the branches <a class="footnote-reference" href="#id6" id="id4">[2]</a>.</p>
<p>In the <em>dependent</em> case, there are three subcases. In the first subcase,
the type in each branch may depend on the exact value being matched in
the branch. In this case, the whole pattern matching itself depends on
the term being matched. This dependency of the term being matched in the
return type is expressed with an “as <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>” clause where <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
is dependent in the return type. For instance, in the following example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">bool</span><span> : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">true</span><span> : </span><span class="coqdoc-var">bool</span><span> | </span><span class="coqdoc-var">false</span><span> : </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">bool is defined
bool_rect is defined
bool_ind is defined
bool_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">eq</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">eq_refl</span><span> : </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">eq is defined
eq_rect is defined
eq_ind is defined
eq_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">or_introl</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">or_intror</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">or is defined
or_ind is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">bool_case</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">false</span><span>) </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">true</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span>)</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">false</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span>)</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">bool_case is defined</span></dd>
</dl>
</div>
<p>the branches have respective types &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="keyword type"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="keyword type"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot;
and &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="keyword type"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="keyword type"><span class="pre">bool</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot; while the whole
pattern matching expression has type &quot;<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="keyword type"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name builtin pseudo"><span class="pre">true</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">eq</span></span> <span class="keyword type"><span class="pre">bool</span></span> <span class="name"><span class="pre">b</span></span> <span class="name builtin pseudo"><span class="pre">false</span></span><span class="operator"><span class="pre">)</span></span></code>&quot;,
the identifier <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> being used to represent the dependency.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>When the term being matched is a variable, the <code class="docutils literal notranslate"><span class="pre">as</span></code> clause can be
omitted and the term being matched can serve itself as binding name in
the return type. For instance, the following alternative definition is
accepted and has the same meaning as the previous one.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">bool_case</span><span> (</span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">false</span><span>) </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">true</span><span> =&gt; </span><span class="coqdoc-var">or_introl</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">true</span><span>)</span><span>
| </span><span class="coqdoc-var">false</span><span> =&gt; </span><span class="coqdoc-var">or_intror</span><span> (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">true</span><span>) (</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-var">false</span><span>) (</span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-var">false</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-301:
&gt; Definition bool_case (b:bool) : or (eq bool b true) (eq bool b false) := match b return or (eq bool b true) (eq bool b false) with | true =&gt; or_introl (eq bool true true) (eq bool true false) (eq_refl bool true) | false =&gt; or_intror (eq bool false true) (eq bool false false) (eq_refl bool false) end.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> bool_case already exists.</span></dd>
</dl>
</div>
</div>
<p>The second subcase is only relevant for annotated inductive types such
as the equality predicate (see Section <a class="reference internal" href="coq-library.html#coq-equality"><span class="std std-ref">Equality</span></a>),
the order predicate on natural numbers or the type of lists of a given
length (see Section <a class="reference internal" href="../addendum/extended-pattern-matching.html#matching-dependent"><span class="std std-ref">Matching objects of dependent types</span></a>). In this configuration, the
type of each branch can depend on the type dependencies specific to the
branch and the whole pattern matching expression has a type determined
by the specific dependencies in the type of the term being matched. This
dependency of the return type in the annotations of the inductive type
is expressed using a “<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">in</span></span></code> <span class="math notranslate">\(I\)</span> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span> <span class="error"><span class="pre">…</span></span> <span class="operator"><span class="pre">_</span></span></code> <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate">\(_1\)</span> …
<a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate">\(_n\)</span>” clause, where</p>
<ul class="simple">
<li><span class="math notranslate">\(I\)</span> is the inductive type of the term being matched;</li>
<li>the <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">_</span></span></code> are matching the parameters of the inductive type: the
return type is not dependent on them.</li>
<li>the <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate">\(_i\)</span> are matching the annotations of the
inductive type: the return type is dependent on them</li>
<li>in the basic case which we describe below, each <a class="reference internal" href="#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a><span class="math notranslate">\(_i\)</span>
is a name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_i\)</span>; see <a class="reference internal" href="../addendum/extended-pattern-matching.html#match-in-patterns"><span class="std std-ref">Patterns in in</span></a> for the
general case</li>
</ul>
<p>For instance, in the following example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">eq_sym</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">H</span><span>:</span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) : </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">eq</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">eq_refl</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 105-114:
&gt; Definition eq_sym (A:Type) (x y:A) (H:eq A x y) : eq A y x := match H in eq _ _ z return eq A z x with | eq_refl _ =&gt; eq_refl A x end.
&gt;                                                                                                          ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> The constructor </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_refl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (in type </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">) expects 2 arguments.</span></dd>
</dl>
</div>
<p>the type of the branch is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">x</span></span></code> because the third argument of
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> in the type of the pattern <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq_refl</span></span></code>. On the contrary, the
type of the whole pattern matching expression has type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">x</span></span></code> because the
third argument of eq is y in the type of H. This dependency of the case analysis
in the third argument of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is expressed by the identifier <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">z</span></span></code> in the
return type.</p>
<p>Finally, the third subcase is a combination of the first and second
subcase. In particular, it only applies to pattern matching on terms in
a type with annotations. For this third subcase, both the clauses <code class="docutils literal notranslate"><span class="pre">as</span></code> and
<code class="docutils literal notranslate"><span class="pre">in</span></code> are available.</p>
<p>There are specific notations for case analysis on types with one or two
constructors: <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">…</span> <span class="pre">then</span> <span class="pre">…</span> <span class="pre">else</span> <span class="pre">…</span></code> and <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">(…,…)</span> <span class="pre">:=</span> <span class="pre">…</span> <span class="pre">in</span> <span class="pre">…</span></code> (see
Sections <a class="reference internal" href="gallina-extensions.html#if-then-else"><span class="std std-ref">Pattern-matching on boolean values: the if expression</span></a> and <a class="reference internal" href="gallina-extensions.html#irrefutable-patterns"><span class="std std-ref">Irrefutable patterns: the destructuring let variants</span></a>).</p>
</div>
<div class="section" id="recursive-functions">
<span id="index-7"></span><h3>Recursive functions<a class="headerlink" href="#recursive-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The expression “<code class="docutils literal notranslate"><span class="pre">fix</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_1\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code>
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:=</span></code> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code>
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_n\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate">\(_n\)</span> : <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate">\(_n\)</span>
<code class="docutils literal notranslate"><span class="pre">:=</span></code> <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a><span class="math notranslate">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_i\)</span>” denotes the
<span class="math notranslate">\(i\)</span>-th component of a block of functions defined by mutual structural
recursion. It is the local counterpart of the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command. When
<span class="math notranslate">\(n=1\)</span>, the “<code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_i\)</span>” clause is omitted.</p>
<p>The expression “<code class="docutils literal notranslate"><span class="pre">cofix</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_1\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">:</span></code>
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate">\(_1\)</span> <code class="docutils literal notranslate"><span class="pre">with</span> <span class="pre">…</span> <span class="pre">with</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_n\)</span> <a class="reference internal" href="#grammar-token-binder"><code class="xref std std-token docutils literal notranslate"><span class="pre">binder</span></code></a><span class="math notranslate">\(_n\)</span>
: <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a><span class="math notranslate">\(_n\)</span> <code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_i\)</span>” denotes the
<span class="math notranslate">\(i\)</span>-th component of a block of terms defined by a mutual guarded
co-recursion. It is the local counterpart of the <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> command. When
<span class="math notranslate">\(n=1\)</span>, the “<code class="docutils literal notranslate"><span class="pre">for</span></code> <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><span class="math notranslate">\(_i\)</span>” clause is omitted.</p>
<p>The association of a single fixpoint and a local definition have a special
syntax: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <span><span class="pre">fix</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span></span></code> stands for
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">fix</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span></span></code>. The same applies for co-fixpoints.</p>
</div>
</div>
<div class="section" id="the-vernacular">
<span id="vernacular"></span><h2>The Vernacular<a class="headerlink" href="#the-vernacular" title="このヘッドラインへのパーマリンク">¶</a></h2>
<pre>
<strong id="grammar-token-sentence">sentence          </strong> ::=  <a class="reference internal" href="#grammar-token-assumption"><code class="xref docutils literal notranslate"><span class="pre">assumption</span></code></a>
                        | <a class="reference internal" href="#grammar-token-definition"><code class="xref docutils literal notranslate"><span class="pre">definition</span></code></a>
                        | <a class="reference internal" href="#grammar-token-inductive"><code class="xref docutils literal notranslate"><span class="pre">inductive</span></code></a>
                        | <a class="reference internal" href="#grammar-token-fixpoint"><code class="xref docutils literal notranslate"><span class="pre">fixpoint</span></code></a>
                        | <a class="reference internal" href="#grammar-token-assertion"><code class="xref docutils literal notranslate"><span class="pre">assertion</span></code></a> <a class="reference internal" href="#grammar-token-proof"><code class="xref docutils literal notranslate"><span class="pre">proof</span></code></a>
<strong id="grammar-token-assumption">assumption        </strong> ::=  <a class="reference internal" href="#grammar-token-assumption_keyword"><code class="xref docutils literal notranslate"><span class="pre">assumption_keyword</span></code></a> <a class="reference internal" href="#grammar-token-assums"><code class="xref docutils literal notranslate"><span class="pre">assums</span></code></a>.
<strong id="grammar-token-assumption_keyword">assumption_keyword</strong> ::=  Axiom | Conjecture
                        | Parameter | Parameters
                        | Variable | Variables
                        | Hypothesis | Hypotheses
<strong id="grammar-token-assums">assums            </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
                        | ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> ) … ( <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> … <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> )
<strong id="grammar-token-definition">definition        </strong> ::=  [Local] Definition <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
                        | Let <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [: <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] := <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
<strong id="grammar-token-inductive">inductive         </strong> ::=  Inductive <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> .
                        | CoInductive <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-ind_body"><code class="xref docutils literal notranslate"><span class="pre">ind_body</span></code></a> .
<strong id="grammar-token-ind_body">ind_body          </strong> ::=  <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> :=
                        [[|] <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [:<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>] | … | <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] [:<a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>]]
<strong id="grammar-token-fixpoint">fixpoint          </strong> ::=  Fixpoint <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-fix_body"><code class="xref docutils literal notranslate"><span class="pre">fix_body</span></code></a> .
                        | CoFixpoint <a class="reference internal" href="#grammar-token-cofix_body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> with … with <a class="reference internal" href="#grammar-token-cofix_body"><code class="xref docutils literal notranslate"><span class="pre">cofix_body</span></code></a> .
<strong id="grammar-token-assertion">assertion         </strong> ::=  <a class="reference internal" href="#grammar-token-assertion_keyword"><code class="xref docutils literal notranslate"><span class="pre">assertion_keyword</span></code></a> <a class="reference internal" href="#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-binders"><code class="xref docutils literal notranslate"><span class="pre">binders</span></code></a>] : <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> .
<strong id="grammar-token-assertion_keyword">assertion_keyword </strong> ::=  Theorem | Lemma
                        | Remark | Fact
                        | Corollary | Proposition
                        | Definition | Example
<strong id="grammar-token-proof">proof             </strong> ::=  Proof . … Qed .
                        | Proof . … Defined .
                        | Proof . … Admitted .
</pre>
<p>This grammar describes <em>The Vernacular</em> which is the language of
commands of Gallina. A sentence of the vernacular language, like in
many natural languages, begins with a capital letter and ends with a
dot.</p>
<p>The different kinds of command are described hereafter. They all suppose
that the terms occurring in the sentences are well-typed.</p>
<div class="section" id="assumptions">
<span id="gallina-assumptions"></span><h3>Assumptions<a class="headerlink" href="#assumptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Assumptions extend the environment with axioms, parameters, hypotheses
or variables. An assumption binds an <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> to a <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>. It is accepted
by Coq if and only if this <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is a correct type in the environment
preexisting the declaration and if <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> was not previously defined in
the same module. This <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is considered to be the type (or
specification, or statement) assumed by <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and we say that <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
<span class="target" id="axiom"></span><dl class="cmd">
<dt id="coq:cmd.parameter">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Parameter</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.parameter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> as its specification in
the global context. The fact asserted by <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is thus assumed as a
postulate.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-axiom">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-axiom" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Parameter</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Adds several parameters with specification <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Parameter </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds blocks of parameters with different specifications.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.local-parameter">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Local</span> <span>Parameter</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.local-parameter" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Such parameters are never made accessible through their unqualified name by
<a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants. You have to explicitly give their fully
qualified name to refer to them.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.parameters">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Parameters</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.parameters" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.axiom">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Axiom</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axiom" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.axioms">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Axioms</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.axioms" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.conjecture">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Conjecture</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjecture" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.conjectures">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Conjectures</span> <span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.conjectures" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These variants are synonyms of <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">Local</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">Parameter</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a> <span><span class="pre">)</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.variable">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Variable</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.variable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the context of
the current section (see Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a> for a description of
the section mechanism). When the current section is closed, name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
will be unknown and every object using this variable will be explicitly
parametrized (the variable is <em>discharged</em>). Using the <a class="reference internal" href="#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> command out
of any section is equivalent to using <a class="reference internal" href="#coq:cmdv.local-parameter" title="Local Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Parameter</span></code></a>.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-variable">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-variable" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Variable</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Links <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> to each <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Variable </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds blocks of variables with different specifications.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.variables">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Variables </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.variables" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.hypothesis">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hypothesis </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypothesis" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.hypotheses">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hypotheses </span><span class="repeat-wrapper"><span class="repeat"><span>( </span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmdv.hypotheses" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These variants are synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Variable</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">It is advised to use the commands <a class="reference internal" href="#coq:cmdv.axiom" title="Axiom"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Axiom</span></code></a>, <a class="reference internal" href="#coq:cmdv.conjecture" title="Conjecture"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Conjecture</span></code></a> and
<a class="reference internal" href="#coq:cmdv.hypothesis" title="Hypothesis"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Hypothesis</span></code></a> (and their plural forms) for logical postulates (i.e. when
the assertion <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> is of sort <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>), and to use the commands
<a class="reference internal" href="#coq:cmd.parameter" title="Parameter"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Parameter</span></code></a> and <a class="reference internal" href="#coq:cmd.variable" title="Variable"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variable</span></code></a> (and their plural forms) in other cases
(corresponding to the declaration of an abstract mathematical entity).</p>
</div>
</div>
<div class="section" id="definitions">
<span id="gallina-definitions"></span><h3>Definitions<a class="headerlink" href="#definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Definitions extend the environment with associations of names to terms.
A definition can be seen as a way to give a meaning to a name or as a
way to abbreviate a term. In any case, the name can later be replaced at
any time by its definition.</p>
<p>The operation of unfolding a name into its definition is called
<span class="math notranslate">\(\delta\)</span>-conversion (see Section <a class="reference internal" href="cic.html#delta-reduction"><span class="std std-ref">δ-reduction</span></a>). A
definition is accepted by the system if and only if the defined term is
well-typed in the current context of the definition and if the name is
not already used. The name defined by the definition is called a
<em>constant</em> and the term it refers to is its <em>body</em>. A definition has a
type which is the type of its body.</p>
<p>A formal presentation of constants and environments is given in
Section <a class="reference internal" href="cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a>.</p>
<dl class="cmd">
<dt id="coq:cmd.definition">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.definition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command binds <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the environment,
provided that <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is well-typed.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-definition" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This variant checks that the type of <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is definitionally equal to
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and registers <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> as being of type
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and bound to value <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<dl class="exn">
<dt id="coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <span>term</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span>has</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>while</span> <span>it</span> <span>is</span> <span>expected</span> <span>to</span> <span>have</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>'.</span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-while-it-is-expected-to-have-type-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">&nbsp;:&nbsp;forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">&nbsp;:=&nbsp;fun</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">&nbsp;=&gt;&nbsp;</span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.local-definition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Local</span> <span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.local-definition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Such definitions are never made accessible through their
unqualified name by <a class="reference internal" href="gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a> and its variants.
You have to explicitly give their fully qualified name to refer to them.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.example">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>Local</span></span><span class="notation-sup">?</span></span> <span>Example</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.example" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This is equivalent to <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
</dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>, <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
<dl class="cmd">
<dt id="coq:cmd.let">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Let</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.let" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command binds the value <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the
environment of the current section. The name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> disappears when the
current section is eventually closed, and all persistent objects (such
as theorems) defined within the section and depending on <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> are
prefixed by the let-in definition <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">let</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">&nbsp;:=&nbsp;</span></span><a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span></span></code>.
Using the <a class="reference internal" href="#coq:cmd.let" title="Let"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Let</span></code></a> command out of any section is equivalent to using
<a class="reference internal" href="#coq:cmdv.local-definition" title="Local Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Local</span> <span class="pre">Definition</span></code></a>.</p>
<dl class="exn">
<dt id="coq:exn.ident-already-exists-let">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-let" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Let</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.let-fixpoint">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Let</span> <span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-fix_body"><span class="hole">fix_body</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-fix_body"><span class="hole">fix_body</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmdv.let-fixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.let-cofixpoint">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Let</span> <span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-cofix_body"><span class="hole">cofix_body</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-cofix_body"><span class="hole">cofix_body</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmdv.let-cofixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">Section <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>, commands <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>,
<a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, and tactic <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</div>
<div class="section" id="inductive-definitions">
<span id="gallina-inductive-definitions"></span><h3>Inductive definitions<a class="headerlink" href="#inductive-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>We gradually explain simple inductive types, simple annotated inductive
types, simple parametric inductive types, mutually inductive types. We
explain also co-inductive types.</p>
<div class="section" id="simple-inductive-types">
<h4>Simple inductive types<a class="headerlink" href="#simple-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.inductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.inductive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command defines a simple inductive type and its constructors.
The first <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the name of the inductively defined type
and <a class="reference internal" href="#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a> is the universe where it lives. The next <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>s
are the names of its constructors and <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> their respective types.
Depending on the universe where the inductive type <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> lives
(e.g. its type <a class="reference internal" href="#grammar-token-sort"><code class="xref std std-token docutils literal notranslate"><span class="pre">sort</span></code></a>), Coq provides a number of destructors.
Destructors are named <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_ind</span></code>, <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rec</span></code>
or <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rect</span></code> which respectively correspond to elimination
principles on <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.
The type of the destructors expresses structural induction/recursion
principles over objects of type <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.
The constant <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_ind</span></code> is always provided,
whereas <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rec</span></code> and <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a><code class="docutils literal notranslate"><span class="pre">_rect</span></code> can be
impossible to derive (for example, when <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a proposition).</p>
<dl class="exn">
<dt id="coq:exn.non-strictly-positive-occurrence-of-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Non</span> <span>strictly</span> <span>positive</span> <span>occurrence</span> <span>of</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.non-strictly-positive-occurrence-of-ident-in-type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The types of the constructors have to satisfy a <em>positivity condition</em>
(see Section <a class="reference internal" href="cic.html#positivity"><span class="std std-ref">Positivity Condition</span></a>). This condition ensures the soundness of
the inductive definition.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <span>conclusion</span> <span>of</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>is</span> <span>not</span> <span>valid;</span> <span>it</span> <span>must</span> <span>be</span> <span>built</span> <span>from</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.the-conclusion-of-type-is-not-valid-it-must-be-built-from-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The conclusion of the type of the constructors must be the inductive type
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> being defined (or <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> applied to arguments in
the case of annotated inductive types — cf. next section).</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The set of natural numbers is defined as:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">O</span><span> : </span><span class="coqdoc-var">nat</span><span>
| </span><span class="coqdoc-var">S</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd><span class="first last">nat is defined
nat_rect is defined
nat_ind is defined
nat_rec is defined</span></dd>
</dl>
</div>
<p>The type nat is defined as the least <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> containing <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and closed by
the <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> constructor. The names <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">nat</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span></code> are added to the
environment.</p>
<p>Now let us have a look at the elimination principles. They are three of them:
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code>. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nat_ind</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">nat_ind</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">O</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>This is the well known structural induction principle over natural
numbers, i.e. the second-order form of Peano’s induction principle. It
allows proving some universal property of natural numbers (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span>
<span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">n</span></span></code>) by induction on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>.</p>
<p class="last">The types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rec</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nat_rect</span></span></code> are similar, except that they pertain
to <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword namespace"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">)</span></span></code> respectively. They correspond to
primitive induction principles (allowing dependent types) respectively
over sorts <code class="docutils literal notranslate"><span class="pre">Set</span></code> and <code class="docutils literal notranslate"><span class="pre">Type</span></code>.</p>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-sort"><span class="hole">sort</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span></code></dt>
<dd><p>Constructors <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>s can come with <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> in which case,
the actual type of the constructor is <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code>.</p>
<p>In the case where inductive types have no annotations (next section
gives an example of such annotations), a constructor can be defined
by only giving the type of its arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nat</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">O</span><span> | </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">nat</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-37:
&gt; Inductive nat : Set := O | S (_:nat).
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> nat already exists.</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="simple-annotated-inductive-types">
<h4>Simple annotated inductive types<a class="headerlink" href="#simple-annotated-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>In an annotated inductive types, the universe where the inductive type
is defined is no longer a simple sort, but what is called an arity,
which is a type whose conclusion is a sort.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>As an example of annotated inductive types, let us define the
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code> predicate:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">even_0</span><span> : </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">even_SS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)).</span></dt>
<dd><span class="first last">even is defined
even_ind is defined</span></dd>
</dl>
</div>
<p>The type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code> means that even is a unary predicate (inductively
defined) over natural numbers. The type of its two constructors are the
defining clauses of the predicate even. The type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_ind</span></span></code> is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">even_ind</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">even_ind</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">O</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">even</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">even</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">From a mathematical point of view it asserts that the natural numbers satisfying
the predicate even are exactly in the smallest set of naturals satisfying the
clauses <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_0</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even_SS</span></span></code>. This is why, when we want to prove any
predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> over elements of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>, it is enough to prove it for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>
and to prove that if any natural number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> satisfies <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> its double
successor <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">))</span></span></code> satisfies also <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. This is indeed analogous to the
structural induction principle we got for <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">nat</span></span></code>.</p>
</div>
</div>
<div class="section" id="parametrized-inductive-types">
<h4>Parametrized inductive types<a class="headerlink" href="#parametrized-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In the previous example, each constructor introduces a different
instance of the predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">even</span></span></code>. In some cases, all the constructors
introduce the same generic instance of the inductive definition, in
which case, instead of an annotation, we use a context of parameters
which are <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> shared by all the constructors of the definition.</p>
<p>Parameters differ from inductive type annotations in the fact that the
conclusion of each type of constructor invoke the inductive type with
the same values of parameters as its specification.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>A typical example is the definition of polymorphic lists:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
</dl>
</div>
<p>In the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code>, we write <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword type"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span></code> and not
just <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">list</span></span></code>. The constructors <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">nil</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">cons</span></span></code> will have respectively
types:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">nil</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">cons</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Types of destructors are also quantified with <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword namespace"><span class="pre">Set</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
<p>Once again, it is possible to specify only the type of the arguments
of the constructors, and to omit the type of the conclusion:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nil</span><span> | </span><span class="coqdoc-var">cons</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-60:
&gt; Inductive list (A:Set) : Set := nil | cons (_:A) (_:list A).
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> list already exists.</span></dd>
</dl>
</div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<ul class="last">
<li><p class="first">It is possible in the type of a constructor, to
invoke recursively the inductive definition on an argument which is not
the parameter itself.</p>
<p>One can define :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil2</span><span> : </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons2</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">list2</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd><span class="first last">list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined</span></dd>
</dl>
</div>
<p>that can also be written by specifying only the type of the arguments:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">nil2</span><span> | </span><span class="coqdoc-var">cons2</span><span> (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">_</span><span>:</span><span class="coqdoc-var">list2</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)).</span></dt>
<dd><span class="first last">list2 is defined
list2_rect is defined
list2_ind is defined
list2_rec is defined</span></dd>
</dl>
</div>
<p>But the following definition will give an error:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nilw</span><span> : </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>)</span><span>
| </span><span class="coqdoc-var">consw</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">listw</span><span> (</span><span class="coqdoc-var">A</span><span>*</span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="first">The command has indeed failed with message:
Last occurrence of &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">listw</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; must have &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; as 1st argument in
 &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">listw</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)%type&quot;.</span></dd>
</dl>
</div>
<p>because the conclusion of the type of constructors should be <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">listw</span></span> <span class="name"><span class="pre">A</span></span></code>
in both cases.</p>
</li>
<li><p class="first">A parametrized inductive definition can be defined using annotations
instead of parameters but it will sometimes give a different (bigger)
sort for the inductive definition and will produce a less convenient
rule for case elimination.</p>
</li>
</ul>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">Section <a class="reference internal" href="cic.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a> and the <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> tactic.</p>
</div>
</div>
<div class="section" id="variants">
<h4>Variants<a class="headerlink" href="#variants" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.variant">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Variant</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.variant" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a> command is identical to the <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> command, except
that it disallows recursive definition of types (for instance, lists cannot
be defined using <a class="reference internal" href="#coq:cmd.variant" title="Variant"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Variant</span></code></a>). No induction scheme is generated for
this variant, unless option <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:flag.nonrecursive-elimination-schemes" title="Nonrecursive Elimination Schemes"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Nonrecursive</span> <span class="pre">Elimination</span> <span class="pre">Schemes</span></code></a> is on.</p>
<dl class="exn">
<dt id="coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <a class="reference internal" href="#grammar-token-num"><span class="hole">num</span></a> <span>th</span> <span>argument</span> <span>of</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>must</span> <span>be</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.the-num-th-argument-of-ident-must-be-ident-in-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="mutually-defined-inductive-types">
<h4>Mutually defined inductive types<a class="headerlink" href="#mutually-defined-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining a block of mutually inductive types.
It has the same semantics as the above <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a> definition for each
<a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. All <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> are simultaneously added to the environment.
Then well-typing of constructors can be checked. Each one of the <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
can be used on its own.</p>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Inductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>In this variant, the inductive definitions are parametrized
with <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a>. However, parameters correspond to a local context
in which the whole set of inductive declarations is done. For this
reason, the parameters must be strictly the same for each inductive types.</p>
</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The typical example of a mutual inductive data type is the one for trees and
forests. We assume given two types <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> as variables. It can
be declared the following way.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> : </span><span class="coqdoc-keyword">Set</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-20:
&gt; Variables A B : Set.
&gt; ^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A is declared as a local axiom [local-declaration,scope]
A is declared
Toplevel input, characters 0-20:
&gt; Variables A B : Set.
&gt; ^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> B is declared as a local axiom [local-declaration,scope]
B is declared</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined</span></dd>
</dl>
</div>
<p>This declaration generates automatically six induction principles. They are
respectively called <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rect</span></span></code>,
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_ind</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rect</span></span></code>. These ones are not the most
general ones but are just the induction principles corresponding to each
inductive part seen as a single inductive definition.</p>
<p>To illustrate this point on our example, we give the types of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tree_rec</span></span></code>
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">forest_rec</span></span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">tree_rec</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">tree_rec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">node</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">forest_rec</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">forest_rec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">leaf</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (f0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> f1 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Assume we want to parametrize our mutual inductive definitions with the
two type variables <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>, the declaration should be
done the following way:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">tree</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-171:
&gt; Inductive tree (A B:Set) : Set := node : A -&gt; forest A B -&gt; tree A B with forest (A B:Set) : Set := | leaf : B -&gt; forest A B | cons : tree A B -&gt; forest A B -&gt; forest A B.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> forest already exists.</span></dd>
</dl>
</div>
<p class="last">Assume we define an inductive definition inside a section
(cf. <a class="reference internal" href="gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>). When the section is closed, the variables
declared in the section and occurring free in the declaration are added as
parameters to the inductive definition.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">A generic command <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:cmd.scheme" title="Scheme"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span></code></a> is useful to build automatically various
mutual induction principles.</p>
</div>
</div>
<div class="section" id="co-inductive-types">
<span id="coinductive-types"></span><h4>Co-inductive types<a class="headerlink" href="#co-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The objects of an inductive type are well-founded with respect to the
constructors of the type. In other words, such objects contain only a
<em>finite</em> number of constructors. Co-inductive types arise from relaxing
this condition, and admitting types whose objects contain an infinity of
constructors. Infinite objects are introduced by a non-ending (but
effective) process of construction, defined in terms of the constructors
of the type.</p>
<dl class="cmd">
<dt id="coq:cmd.coinductive">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>CoInductive</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><span>|</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:cmd.coinductive" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command introduces a co-inductive type.
The syntax of the command is the same as the command <a class="reference internal" href="#coq:cmd.inductive" title="Inductive"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Inductive</span></code></a>.
No principle of induction is derived from the definition of a co-inductive
type, since such principles only make sense for inductive types.
For co-inductive types, the only elimination principle is case analysis.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>An example of a co-inductive type is the type of infinite sequences of
natural numbers, usually called streams.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">Stream</span><span> : </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-var">Seq</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">Stream is defined</span></dd>
</dl>
</div>
<p>The usual destructors on streams <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Stream</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">nat</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">Str</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">Str</span></span></code>
can be defined as follows:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">hd</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Stream</span><span>) := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">s</span><span>) := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">hd is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">tl</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Stream</span><span>) := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">a</span><span>,</span><span class="coqdoc-var">s</span><span>) := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">s</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">tl is defined</span></dd>
</dl>
</div>
</div>
<p>Definition of co-inductive predicates and blocks of mutually
co-inductive definitions are also allowed.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>An example of a co-inductive predicate is the extensional equality on
streams:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">CoInductive</span><span> </span><span class="coqdoc-var">EqSt</span><span> : </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-var">Stream</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">eqst</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>:</span><span class="coqdoc-var">Stream</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s1</span><span> = </span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s2</span><span> -&gt; </span><span class="coqdoc-var">EqSt</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s1</span><span>) (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s2</span><span>) -&gt; </span><span class="coqdoc-var">EqSt</span><span> </span><span class="coqdoc-var">s1</span><span> </span><span class="coqdoc-var">s2</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">EqSt is defined</span></dd>
</dl>
</div>
<p class="last">In order to prove the extensional equality of two streams <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">s1</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">s2</span></span></code>
we have to construct an infinite proof of equality, that is, an infinite
object of type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">EqSt</span></span> <span class="name"><span class="pre">s1</span></span> <span class="name"><span class="pre">s2</span></span><span class="operator"><span class="pre">)</span></span></code>. We will see how to introduce infinite
objects in Section <a class="reference internal" href="#cofixpoint"><span class="std std-ref">Definitions of recursive objects in co-inductive types</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="definition-of-recursive-functions">
<h3>Definition of recursive functions<a class="headerlink" href="#definition-of-recursive-functions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="definition-of-functions-by-recursion-over-inductive-objects">
<h4>Definition of functions by recursion over inductive objects<a class="headerlink" href="#definition-of-functions-by-recursion-over-inductive-objects" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>This section describes the primitive form of definition by recursion over
inductive objects. See the <a class="reference internal" href="gallina-extensions.html#coq:cmd.function" title="Function"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Function</span></code></a> command for more advanced
constructions.</p>
<span class="target" id="fixpoint"></span><dl class="cmd">
<dt id="coq:cmd.fixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span>struct</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.fixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command allows defining functions by pattern matching over inductive
objects using a fixed point construction. The meaning of this declaration is
to define <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> a recursive function with arguments specified by
the <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> such that <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> applied to arguments
corresponding to these <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> has type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a>, and is
equivalent to the expression <a class="reference internal" href="#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. The type of <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is
consequently <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and its value is equivalent
to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fun</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<p>To be accepted, a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition has to satisfy some syntactical
constraints on a special argument called the decreasing argument. They
are needed to ensure that the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> definition always terminates.
The point of the <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span class="pre">struct</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation is to let the user tell the
system which argument decreases along the recursive calls.</p>
<p>The <code class="docutils literal notranslate"><span class="notation"><span class="curlies"><span class="pre">{</span><span><span class="pre">struct</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span class="pre">}</span></span></span></code> annotation may be left implicit, in this case the
system tries successively arguments from left to right until it finds one
that satisfies the decreasing condition.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<ul class="last simple">
<li>Some fixpoints may have several arguments that fit as decreasing
arguments, and this choice influences the reduction of the fixpoint.
Hence an explicit annotation must be used if the leftmost decreasing
argument is not the desired one. Writing explicit annotations can also
speed up type checking of large mutual fixpoints.</li>
<li>In order to keep the strong normalization property, the fixed point
reduction will only be performed when the argument in position of the
decreasing argument (which type should be in an inductive definition)
starts with a constructor.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>One can define the addition function as :</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">add</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">add is defined
add is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
<p>The match operator matches a value (here <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>) with the various
constructors of its (inductive) type. The remaining arguments give the
respective values to be returned, as functions of the parameters of the
corresponding constructor. Thus here when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> we return
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">m</span></span></code>, and when <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> equals <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">)</span></span></code> we return <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code>.</p>
<p class="last">The match operator is formally described in
Section <a class="reference internal" href="cic.html#match-construction"><span class="std std-ref">The match ... with ... end construction</span></a>.
The system recognizes that in the inductive call <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">add</span></span> <span class="name"><span class="pre">p</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">)</span></span></code> the first
argument actually decreases because it is a <em>pattern variable</em> coming
from <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span> <span class="name"><span class="pre">n</span></span> <span class="keyword"><span class="pre">with</span></span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The following definition is not correct and generates an error message:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">wrongplus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">wrongplus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
Recursive definition of wrongplus is ill-formed.
In environment
wrongplus : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Recursive call to wrongplus has principal argument equal to 
&quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; instead of a subterm of &quot;n&quot;.
Recursive definition is:
&quot;</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                  | 0 =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
                  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">wrongplus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
                  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">&quot;.</span></dd>
</dl>
</div>
<p>because the declared decreasing argument <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> does not actually
decrease in the recursive call. The function computing the addition over
the second argument should rather be written:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">m</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">plus is defined
plus is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The recursive call may not only be on direct subterms of the recursive
variable <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code> but also on a deeper subterm and we can directly write
the function <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">mod2</span></span></code> which gives the remainder modulo 2 of a natural
number.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">mod2</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">O</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">q</span><span> =&gt; </span><span class="coqdoc-var">mod2</span><span> </span><span class="coqdoc-var">q</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">mod2 is defined
mod2 is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="curlies">{<span>struct</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a>}</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This variant allows defining simultaneously several mutual fixpoints.
It is especially useful when defining functions over mutually defined
inductive types.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The size of trees and forests can be defined the following way:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">tree_size</span><span> (</span><span class="coqdoc-var">t</span><span>:</span><span class="coqdoc-var">tree</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">node</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">f</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest_size</span><span> (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">forest</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">leaf</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; 1</span><span>
| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">f'</span><span> =&gt; (</span><span class="coqdoc-var">tree_size</span><span> </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">forest_size</span><span> </span><span class="coqdoc-var">f'</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">tree_size is defined
forest_size is defined
tree_size, forest_size are recursively defined
(decreasing respectively on 1st, 1st arguments)</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="definitions-of-recursive-objects-in-co-inductive-types">
<span id="cofixpoint"></span><h4>Definitions of recursive objects in co-inductive types<a class="headerlink" href="#definitions-of-recursive-objects-in-co-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="cmd">
<dt id="coq:cmd.cofixpoint">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.cofixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command introduces a method for constructing an infinite object of a
coinductive type. For example, the stream containing all natural numbers can
be introduced applying the following method to the number <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> (see
Section <a class="reference internal" href="#coinductive-types"><span class="std std-ref">Co-inductive types</span></a> for the definition of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Stream</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">hd</span></span></code>
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">tl</span></span></code>):</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">CoFixpoint</span><span> </span><span class="coqdoc-var">from</span><span> (</span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">Stream</span><span> := </span><span class="coqdoc-var">Seq</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">from</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)).</span></dt>
<dd><span class="first last">from is defined
from is corecursively defined</span></dd>
</dl>
</div>
<p>Oppositely to recursive ones, there is no decreasing argument in a
co-recursive definition. To be admissible, a method of construction must
provide at least one extra constructor of the infinite object for each
iteration. A syntactical guard condition is imposed on co-recursive
definitions in order to ensure this: each recursive call in the
definition must be protected by at least one constructor, and only by
constructors. That is the case in the former definition, where the single
recursive call of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">from</span></span></code> is guarded by an application of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Seq</span></span></code>.
On the contrary, the following recursive function does not satisfy the
guard condition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">CoFixpoint</span><span> </span><span class="coqdoc-var">filter</span><span> (</span><span class="coqdoc-var">p</span><span>:</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">s</span><span>:</span><span class="coqdoc-var">Stream</span><span>) : </span><span class="coqdoc-var">Stream</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s</span><span>) </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">Seq</span><span> (</span><span class="coqdoc-var">hd</span><span> </span><span class="coqdoc-var">s</span><span>) (</span><span class="coqdoc-var">filter</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s</span><span>)) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">filter</span><span> </span><span class="coqdoc-var">p</span><span> (</span><span class="coqdoc-var">tl</span><span> </span><span class="coqdoc-var">s</span><span>).</span></dt>
<dd><span class="first">The command has indeed failed with message:
Recursive definition of filter is ill-formed.
In environment
filter : (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
s : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Unguarded recursive call in &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">filter</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)&quot;.
Recursive definition is:
&quot;</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (s : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt;
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">if</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">hd</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">then</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Seq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">hd</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">filter</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)) </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">else</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">filter</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)&quot;.</span></dd>
</dl>
</div>
<p>The elimination of co-recursive definition is done lazily, i.e. the
definition is expanded only when it occurs at the head of an application
which is the argument of a case analysis expression. In any other
context, it is considered as a canonical expression which is completely
evaluated. We can test this using the command <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.eval" title="Eval"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Eval</span></code></a>, which computes
the normal forms of a term:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">from</span><span> 0).</span></dt>
<dd><span class="first">     = (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">cofix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> from (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Seq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">from</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))) 0
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">hd</span><span> (</span><span class="coqdoc-var">from</span><span> 0)).</span></dt>
<dd><span class="first">     = 0
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Eval</span><span> </span><span class="coqdoc-tactic">compute</span><span> </span><span class="coqdoc-tactic">in</span><span> (</span><span class="coqdoc-var">tl</span><span> (</span><span class="coqdoc-var">from</span><span> 0)).</span></dt>
<dd><span class="first">     = (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">cofix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> from (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Seq</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">from</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))) 1
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Stream</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>As in the <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> command, it is possible to introduce a block of
mutually dependent methods.</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="assertions-and-proofs">
<span id="assertions"></span><h3>Assertions and proofs<a class="headerlink" href="#assertions-and-proofs" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An assertion states a proposition (or a type) of which the proof (or an
inhabitant of the type) is interactively built using tactics. The interactive
proof mode is described in Chapter <a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a> and the tactics in
Chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. The basic assertion command is:</p>
<dl class="cmd">
<dt id="coq:cmd.theorem">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Theorem</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmd.theorem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>After the statement is asserted, Coq needs a proof. Once a proof of
<a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> under the assumptions represented by <a class="reference internal" href="#grammar-token-binders"><code class="xref std std-token docutils literal notranslate"><span class="pre">binders</span></code></a> is given and
validated, the proof is generalized into a proof of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">forall</span></span> <a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a><span><span class="pre">,</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> and
the theorem is bound to the name <a class="reference internal" href="#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the environment.</p>
<dl class="exn">
<dt id="coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <span>term</span> <a class="reference internal" href="#grammar-token-term"><span class="hole">term</span></a> <span>has</span> <span>type</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span>which</span> <span>should</span> <span>be</span> <span>Set,</span> <span>Prop</span> <span>or</span> <span>Type.</span></span></code><a class="headerlink" href="#coq:exn.the-term-term-has-type-type-which-should-be-set-prop-or-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.ident-already-exists-theorem">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span>already</span> <span>exists.</span></span></code><a class="headerlink" href="#coq:exn.ident-already-exists-theorem" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The name you provided is already defined. You have then to choose
another name.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.lemma">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Lemma</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.lemma" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.remark">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Remark</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.remark" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.fact">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Fact</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.fact" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.corollary">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Corollary</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.corollary" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:cmdv.proposition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Proposition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code><a class="headerlink" href="#coq:cmdv.proposition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These commands are all synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Theorem</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">:</span></span> <span><span class="pre">type</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Theorem</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This command is useful for theorems that are proved by simultaneous induction
over a mutually inductive assumption, or that assert mutually dependent
statements in some mutual co-inductive type. It is equivalent to
<a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> but using tactics to build the proof of
the statements (or the body of the specification, depending on the point of
view). The inductive or co-inductive types on which the induction or
coinduction has to be done is assumed to be non ambiguous and is guessed by
the system.</p>
<p>Like in a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> or <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> definition, the induction hypotheses
have to be used on <em>structurally smaller</em> arguments (for a <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>) or
be <em>guarded by a constructor</em> (for a <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a>). The verification that
recursive proof arguments are correct is done only at the time of registering
the lemma in the environment. To know if the use of induction hypotheses is
correct at some time of the interactive development of a proof, use the
command <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.guarded" title="Guarded"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Guarded</span></code></a>.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.lemma" title="Lemma"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Lemma</span></code></a>, <a class="reference internal" href="#coq:cmdv.remark" title="Remark"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remark</span></code></a>, etc. instead of
<a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Definition</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>This allows defining a term of type <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">type</span></code></a> using the proof editing
mode. It behaves as <a class="reference internal" href="#coq:cmd.theorem" title="Theorem"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Theorem</span></code></a> but is intended to be used in conjunction with
<a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a> in order to define a constant of which the computational
behavior is relevant.</p>
<p>The command can be used also with <a class="reference internal" href="#coq:cmdv.example" title="Example"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Example</span></code></a> instead of <a class="reference internal" href="#coq:cmd.definition" title="Definition"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Definition</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.opaque" title="Opaque"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Opaque</span></code></a>, <a class="reference internal" href="../proof-engine/vernacular-commands.html#coq:cmd.transparent" title="Transparent"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Transparent</span></code></a>, <a class="reference internal" href="../proof-engine/tactics.html#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>.</p>
</div>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Let</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span></code></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Definition</span></span> <a class="reference internal" href="#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a></span></code> except that the definition is
turned into a let-in definition generalized over the declarations depending
on it after closing the current section.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Fixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode (when a
body is omitted, its type is mandatory in the syntax). When the block
of proofs is completed, it is intended to be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>CoFixpoint</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="#grammar-token-type"><span class="hole">type</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This generalizes the syntax of <a class="reference internal" href="#coq:cmd.cofixpoint" title="CoFixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">CoFixpoint</span></code></a> so that one or more bodies
can be defined interactively using the proof editing mode.</p>
</dd></dl>

<p>A proof starts by the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a>. Then Coq enters the proof editing mode
until the proof is completed. The proof editing mode essentially contains
tactics that are described in chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. Besides tactics, there
are commands to manage the proof editing mode. They are described in Chapter
<a class="reference internal" href="../proof-engine/proof-handling.html#proofhandling"><span class="std std-ref">Proof handling</span></a>.</p>
<p>When the proof is completed it should be validated and put in the environment
using the keyword <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<ol class="last arabic simple">
<li>Several statements can be simultaneously asserted.</li>
<li>Not only other assertions but any vernacular command can be given
while in the process of proving a given assertion. In this case, the
command is understood as if it would have been given before the
statements still to be proved. Nonetheless, this practice is discouraged
and may stop working in future versions.</li>
<li>Proofs ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> are declared opaque. Their content cannot be
unfolded (see <a class="reference internal" href="../proof-engine/tactics.html#performingcomputations"><span class="std std-ref">Performing computations</span></a>), thus
realizing some form of <em>proof-irrelevance</em>. To be able to unfold a
proof, the proof should be ended by <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>.</li>
<li><a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a> is recommended but can currently be omitted. On the opposite
side, <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> (or <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmdv.defined" title="Defined"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Defined</span></code></a>) is mandatory to validate a proof.</li>
<li>One can also use <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.admitted" title="Admitted"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Admitted</span></code></a> in place of <a class="reference internal" href="../proof-engine/proof-handling.html#coq:cmd.qed" title="Qed"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Qed</span></code></a> to turn the
current asserted statement into an axiom and exit the proof editing mode.</li>
</ol>
</div>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This is similar to the expression “<em>entry</em> <span class="math notranslate">\(\{\)</span> sep <em>entry</em>
<span class="math notranslate">\(\}\)</span>” in standard BNF, or “<em>entry</em>&nbsp;<span class="math notranslate">\((\)</span> sep <em>entry</em>
<span class="math notranslate">\()\)</span>*” in the syntax of regular expressions.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>Except if the inductive type is empty in which case there is no
equation that can be used to infer the return type.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="gallina-extensions.html" class="btn btn-neutral float-right" title="Extensions of Gallina" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../credits.html" class="btn btn-neutral" title="Credits" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>