

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Calculus of Inductive Constructions &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="The Module System" href="module-system.html" />
    <link rel="prev" title="The Coq library" href="coq-library.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Calculus of Inductive Constructions</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-terms">The terms</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#sorts">Sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terms">Terms</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#typing-rules">Typing rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conversion-rules">Conversion rules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#reduction">β-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iota-reduction">ι-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#delta-reduction">δ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#zeta-reduction">ζ-reduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expansion">η-expansion</a></li>
<li class="toctree-l3"><a class="reference internal" href="#convertibility">Convertibility</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#subtyping-rules">Subtyping rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inductive-definitions">Inductive Definitions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#types-of-inductive-objects">Types of inductive objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#well-formed-inductive-definitions">Well-formed inductive definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arity-of-a-given-sort">Arity of a given sort</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arity">Arity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-constructor">Type constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#positivity-condition">Positivity Condition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#strict-positivity">Strict positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#nested-positivity">Nested Positivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="#correctness-rules">Correctness rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#template-polymorphism">Template polymorphism</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#destructors">Destructors</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-match-with-end-construction">The match ... with ... end construction</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#fixpoint-definitions">Fixpoint definitions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id27">Typing rule</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reduction-rule">Reduction rule</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#admissible-rules-for-global-environments">Admissible rules for global environments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#co-inductive-types">Co-inductive types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-calculus-of-inductive-constructions-with-impredicative-set">The Calculus of Inductive Constructions with impredicative Set</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../proof-engine/ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Calculus of Inductive Constructions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/language/cic.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="calculus-of-inductive-constructions">
<span id="calculusofinductiveconstructions"></span><h1>Calculus of Inductive Constructions<a class="headerlink" href="#calculus-of-inductive-constructions" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>The underlying formal language of <span class="smallcaps">Coq</span> is a <em>Calculus of Inductive
Constructions</em> (<span class="smallcaps">Cic</span>) whose inference rules are presented in this
chapter. The history of this formalism as well as pointers to related
work are provided in a separate chapter; see <em>Credits</em>.</p>
<div class="section" id="the-terms">
<span id="id1"></span><h2>The terms<a class="headerlink" href="#the-terms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The expressions of the <span class="smallcaps">Cic</span> are <em>terms</em> and all terms have a <em>type</em>.
There are types for functions (or programs), there are atomic types
(especially datatypes)... but also types for proofs and types for the
types themselves. Especially, any object handled in the formalism must
belong to a type. For instance, universal quantification is relative
to a type and takes the form &quot;<em>for all x of type T, P</em> &quot;. The expression
“x of type T” is written <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code>. Informally, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code> can be thought as
“x belongs to T”.</p>
<p>The types of types are <em>sorts</em>. Types and sorts are themselves terms
so that terms, types and sorts are all components of a common
syntactic language of terms which is described in Section <a class="reference internal" href="#terms"><span class="std std-ref">Terms</span></a> but,
first, we describe sorts.</p>
<div class="section" id="sorts">
<span id="id2"></span><h3>Sorts<a class="headerlink" href="#sorts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>All sorts have a type and there is an infinite well-founded typing
hierarchy of sorts whose base sorts are <span class="math notranslate">\(\Prop\)</span> and <span class="math notranslate">\(\Set\)</span>.</p>
<p>The sort <span class="math notranslate">\(\Prop\)</span> intends to be the type of logical propositions. If <span class="math notranslate">\(M\)</span> is a
logical proposition then it denotes the class of terms representing
proofs of <span class="math notranslate">\(M\)</span>. An object <span class="math notranslate">\(m\)</span> belonging to <span class="math notranslate">\(M\)</span> witnesses the fact that <span class="math notranslate">\(M\)</span> is
provable. An object of type <span class="math notranslate">\(\Prop\)</span> is called a proposition.</p>
<p>The sort <span class="math notranslate">\(\Set\)</span> intends to be the type of small sets. This includes data
types such as booleans and naturals, but also products, subsets, and
function types over these data types.</p>
<p><span class="math notranslate">\(\Prop\)</span> and <span class="math notranslate">\(\Set\)</span> themselves can be manipulated as ordinary terms.
Consequently they also have a type. Because assuming simply that <span class="math notranslate">\(\Set\)</span>
has type <span class="math notranslate">\(\Set\)</span> leads to an inconsistent theory <a class="reference internal" href="../zebibliography.html#coq86" id="id3">[Coq86]</a>, the language of
<span class="smallcaps">Cic</span> has infinitely many sorts. There are, in addition to <span class="math notranslate">\(\Set\)</span> and <span class="math notranslate">\(\Prop\)</span>
a hierarchy of universes <span class="math notranslate">\(\Type(i)\)</span> for any integer <span class="math notranslate">\(i\)</span>.</p>
<p>Like <span class="math notranslate">\(\Set\)</span>, all of the sorts <span class="math notranslate">\(\Type(i)\)</span> contain small sets such as
booleans, natural numbers, as well as products, subsets and function
types over small sets. But, unlike <span class="math notranslate">\(\Set\)</span>, they also contain large sets,
namely the sorts <span class="math notranslate">\(\Set\)</span> and <span class="math notranslate">\(\Type(j)\)</span> for <span class="math notranslate">\(j&lt;i\)</span>, and all products, subsets
and function types over these sorts.</p>
<p>Formally, we call <span class="math notranslate">\(\Sort\)</span> the set of sorts which is defined by:</p>
<div class="math notranslate">
\[\Sort \equiv \{\Prop,\Set,\Type(i)\;|\; i~∈ ℕ\}\]</div>
<p>Their properties, such as: <span class="math notranslate">\(\Prop:\Type(1)\)</span>, <span class="math notranslate">\(\Set:\Type(1)\)</span>, and
<span class="math notranslate">\(\Type(i):\Type(i+1)\)</span>, are defined in Section <a class="reference internal" href="#subtyping-rules"><span class="std std-ref">Subtyping rules</span></a>.</p>
<p>The user does not have to mention explicitly the index <span class="math notranslate">\(i\)</span> when
referring to the universe <span class="math notranslate">\(\Type(i)\)</span>. One only writes <span class="math notranslate">\(\Type\)</span>. The system
itself generates for each instance of <span class="math notranslate">\(\Type\)</span> a new index for the
universe and checks that the constraints between these indexes can be
solved. From the user point of view we consequently have <span class="math notranslate">\(\Type:\Type\)</span>. We
shall make precise in the typing rules the constraints between the
indices.</p>
<p id="implementation-issues"><strong>Implementation issues</strong> In practice, the Type hierarchy is
implemented using <em>algebraic
universes</em>. An algebraic universe <span class="math notranslate">\(u\)</span> is either a variable (a qualified
identifier with a number) or a successor of an algebraic universe (an
expression <span class="math notranslate">\(u+1\)</span>), or an upper bound of algebraic universes (an
expression <span class="math notranslate">\(\max(u 1 ,...,u n )\)</span>), or the base universe (the expression
<span class="math notranslate">\(0\)</span>) which corresponds, in the arity of template polymorphic inductive
types (see Section
<a class="reference internal" href="#well-formed-inductive-definitions"><span class="std std-ref">Well-formed inductive definitions</span></a>),
to the predicative sort <span class="math notranslate">\(\Set\)</span>. A graph of
constraints between the universe variables is maintained globally. To
ensure the existence of a mapping of the universes to the positive
integers, the graph of constraints must remain acyclic. Typing
expressions that violate the acyclicity of the graph of constraints
results in a Universe inconsistency error.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">Section <a class="reference internal" href="gallina-extensions.html#printing-universes"><span class="std std-ref">Printing universes</span></a>.</p>
</div>
</div>
<div class="section" id="terms">
<span id="id4"></span><h3>Terms<a class="headerlink" href="#terms" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Terms are built from sorts, variables, constants, abstractions,
applications, local definitions, and products. From a syntactic point
of view, types cannot be distinguished from terms, except that they
cannot start by an abstraction or a constructor. More precisely the
language of the <em>Calculus of Inductive Constructions</em> is built from
the following rules.</p>
<ol class="arabic simple">
<li>the sorts <span class="math notranslate">\(\Set\)</span>, <span class="math notranslate">\(\Prop\)</span>, <span class="math notranslate">\(\Type(i)\)</span> are terms.</li>
<li>variables, hereafter ranged over by letters <span class="math notranslate">\(x\)</span>, <span class="math notranslate">\(y\)</span>, etc., are terms</li>
<li>constants, hereafter ranged over by letters <span class="math notranslate">\(c\)</span>, <span class="math notranslate">\(d\)</span>, etc., are terms.</li>
<li>if <span class="math notranslate">\(x\)</span> is a variable and <span class="math notranslate">\(T\)</span>, <span class="math notranslate">\(U\)</span> are terms then
<span class="math notranslate">\(∀ x:T,U\)</span> (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">U</span></span></code>   in <span class="smallcaps">Coq</span> concrete syntax) is a term.
If <span class="math notranslate">\(x\)</span> occurs in <span class="math notranslate">\(U\)</span>, <span class="math notranslate">\(∀ x:T,U\)</span> reads as
“for all <span class="math notranslate">\(x\)</span> of type <span class="math notranslate">\(T\)</span>, <span class="math notranslate">\(U\)</span>”.
As <span class="math notranslate">\(U\)</span> depends on <span class="math notranslate">\(x\)</span>, one says that <span class="math notranslate">\(∀ x:T,U\)</span> is
a <em>dependent product</em>. If <span class="math notranslate">\(x\)</span> does not occur in <span class="math notranslate">\(U\)</span> then
<span class="math notranslate">\(∀ x:T,U\)</span> reads as
“if <span class="math notranslate">\(T\)</span> then <span class="math notranslate">\(U\)</span>”. A <em>non dependent product</em> can be
written: <span class="math notranslate">\(T \rightarrow U\)</span>.</li>
<li>if <span class="math notranslate">\(x\)</span> is a variable and <span class="math notranslate">\(T\)</span>, <span class="math notranslate">\(u\)</span> are terms then
<span class="math notranslate">\(λ x:T . u\)</span> (<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">u</span></span></code>
in <span class="smallcaps">Coq</span> concrete syntax) is a term. This is a notation for the
λ-abstraction of λ-calculus <a class="reference internal" href="../zebibliography.html#bar81" id="id5">[Bar81]</a>. The term <span class="math notranslate">\(λ x:T . u\)</span> is a function
which maps elements of <span class="math notranslate">\(T\)</span> to the expression <span class="math notranslate">\(u\)</span>.</li>
<li>if <span class="math notranslate">\(t\)</span> and <span class="math notranslate">\(u\)</span> are terms then <span class="math notranslate">\((t~u)\)</span> is a term
(<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span> <span class="name"><span class="pre">u</span></span></code> in <span class="smallcaps">Coq</span> concrete
syntax). The term <span class="math notranslate">\((t~u)\)</span> reads as “t applied to u”.</li>
<li>if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code> is a variable, and <span class="math notranslate">\(t\)</span>, <span class="math notranslate">\(T\)</span> and <span class="math notranslate">\(u\)</span> are
terms then <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:=</span></span><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">u</span></span></code> is
a term which denotes the term <span class="math notranslate">\(u\)</span> where the variable <span class="math notranslate">\(x\)</span> is locally bound
to <span class="math notranslate">\(t\)</span> of type <span class="math notranslate">\(T\)</span>. This stands for the common “let-in” construction of
functional programs such as ML or Scheme.</li>
</ol>
<p id="free-variables"><strong>Free variables.</strong>
The notion of free variables is defined as usual. In the expressions
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">λ</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">.</span></span> <span class="name"><span class="pre">U</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="error"><span class="pre">∀</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">U</span></span></code> the occurrences of <span class="math notranslate">\(x\)</span> in <span class="math notranslate">\(U\)</span> are bound.</p>
<p id="substitution"><strong>Substitution.</strong>
The notion of substituting a term <span class="math notranslate">\(t\)</span> to free occurrences of a variable
<span class="math notranslate">\(x\)</span> in a term <span class="math notranslate">\(u\)</span> is defined as usual. The resulting term is written
<span class="math notranslate">\(\subst{u}{x}{t}\)</span>.</p>
<p id="the-logical-vs-programming-readings"><strong>The logical vs programming readings.</strong>
The constructions of the <span class="smallcaps">Cic</span> can be used to express both logical and
programming notions, accordingly to the Curry-Howard correspondence
between proofs and programs, and between propositions and types
<a class="reference internal" href="../zebibliography.html#cur58" id="id6">[CFC58]</a><a class="reference internal" href="../zebibliography.html#how80" id="id7">[How80]</a><a class="reference internal" href="../zebibliography.html#bru72" id="id8">[dB72]</a>.</p>
<p>For instance, let us assume that <span class="math notranslate">\(\nat\)</span> is the type of natural numbers
with zero element written <span class="math notranslate">\(0\)</span> and that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">True</span></span></code> is the always true
proposition. Then <span class="math notranslate">\(→\)</span> is used both to denote <span class="math notranslate">\(\nat→\nat\)</span> which is the type
of functions from <span class="math notranslate">\(\nat\)</span> to <span class="math notranslate">\(\nat\)</span>, to denote True→True which is an
implicative proposition, to denote <span class="math notranslate">\(\nat →\Prop\)</span> which is the type of
unary predicates over the natural numbers, etc.</p>
<p>Let us assume that <code class="docutils literal notranslate"><span class="pre">mult</span></code> is a function of type <span class="math notranslate">\(\nat→\nat→\nat\)</span> and <code class="docutils literal notranslate"><span class="pre">eqnat</span></code> a
predicate of type nat→nat→ Prop. The λ-abstraction can serve to build
“ordinary” functions as in <span class="math notranslate">\(λ x:\nat.(\kw{mult}~x~x)\)</span> (i.e.
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">mult</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">x</span></span></code>
in <span class="smallcaps">Coq</span> notation) but may build also predicates over the natural
numbers. For instance <span class="math notranslate">\(λ x:\nat.(\kw{eqnat}~x~0)\)</span>
(i.e. <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">eqnat</span></span> <span class="name"><span class="pre">x</span></span> <span class="literal number integer"><span class="pre">0</span></span></code>
in <span class="smallcaps">Coq</span> notation) will represent the predicate of one variable <span class="math notranslate">\(x\)</span> which
asserts the equality of <span class="math notranslate">\(x\)</span> with <span class="math notranslate">\(0\)</span>. This predicate has type
<span class="math notranslate">\(\nat → \Prop\)</span>
and it can be applied to any expression of type <span class="math notranslate">\(\nat\)</span>, say <span class="math notranslate">\(t\)</span>, to give an
object <span class="math notranslate">\(P~t\)</span> of type <span class="math notranslate">\(\Prop\)</span>, namely a proposition.</p>
<p>Furthermore <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span></code> will represent the type of functions
which associate to each natural number <span class="math notranslate">\(n\)</span> an object of type <span class="math notranslate">\((P~n)\)</span> and
consequently represent the type of proofs of the formula “<span class="math notranslate">\(∀ x. P(x\)</span>)”.</p>
</div>
</div>
<div class="section" id="typing-rules">
<span id="id9"></span><h2>Typing rules<a class="headerlink" href="#typing-rules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>As objects of type theory, terms are subjected to <em>type discipline</em>.
The well typing of a term depends on a global environment and a local
context.</p>
<p id="local-context"><strong>Local context.</strong>
A <em>local context</em> is an ordered list of <em>local declarations</em> of names
which we call <em>variables</em>. The declaration of some variable <span class="math notranslate">\(x\)</span> is
either a <em>local assumption</em>, written <span class="math notranslate">\(x:T\)</span> (<span class="math notranslate">\(T\)</span> is a type) or a <em>local
definition</em>, written <span class="math notranslate">\(x:=t:T\)</span>. We use brackets to write local contexts.
A typical example is <span class="math notranslate">\([x:T;y:=u:U;z:V]\)</span>. Notice that the variables
declared in a local context must be distinct. If <span class="math notranslate">\(Γ\)</span> is a local context
that declares some <span class="math notranslate">\(x\)</span>, we
write <span class="math notranslate">\(x ∈ Γ\)</span>. By writing <span class="math notranslate">\((x:T) ∈ Γ\)</span> we mean that either <span class="math notranslate">\(x:T\)</span> is an
assumption in <span class="math notranslate">\(Γ\)</span> or that there exists some <span class="math notranslate">\(t\)</span> such that <span class="math notranslate">\(x:=t:T\)</span> is a
definition in <span class="math notranslate">\(Γ\)</span>. If <span class="math notranslate">\(Γ\)</span> defines some <span class="math notranslate">\(x:=t:T\)</span>, we also write <span class="math notranslate">\((x:=t:T) ∈ Γ\)</span>.
For the rest of the chapter, <span class="math notranslate">\(Γ::(y:T)\)</span> denotes the local context <span class="math notranslate">\(Γ\)</span>
enriched with the local assumption <span class="math notranslate">\(y:T\)</span>. Similarly, <span class="math notranslate">\(Γ::(y:=t:T)\)</span> denotes
the local context <span class="math notranslate">\(Γ\)</span> enriched with the local definition <span class="math notranslate">\((y:=t:T)\)</span>. The
notation <span class="math notranslate">\([]\)</span> denotes the empty local context. By <span class="math notranslate">\(Γ_1 ; Γ_2\)</span> we mean
concatenation of the local context <span class="math notranslate">\(Γ_1\)</span> and the local context <span class="math notranslate">\(Γ_2\)</span> .</p>
<p id="global-environment"><strong>Global environment.</strong>
A <em>global environment</em> is an ordered list of <em>global declarations</em>.
Global declarations are either <em>global assumptions</em> or <em>global
definitions</em>, but also declarations of inductive objects. Inductive
objects themselves declare both inductive or coinductive types and
constructors (see Section <a class="reference internal" href="#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>).</p>
<p>A <em>global assumption</em> will be represented in the global environment as
<span class="math notranslate">\((c:T)\)</span> which assumes the name <span class="math notranslate">\(c\)</span> to be of some type <span class="math notranslate">\(T\)</span>. A <em>global
definition</em> will be represented in the global environment as <span class="math notranslate">\(c:=t:T\)</span>
which defines the name <span class="math notranslate">\(c\)</span> to have value <span class="math notranslate">\(t\)</span> and type <span class="math notranslate">\(T\)</span>. We shall call
such names <em>constants</em>. For the rest of the chapter, the <span class="math notranslate">\(E;c:T\)</span> denotes
the global environment <span class="math notranslate">\(E\)</span> enriched with the global assumption <span class="math notranslate">\(c:T\)</span>.
Similarly, <span class="math notranslate">\(E;c:=t:T\)</span> denotes the global environment <span class="math notranslate">\(E\)</span> enriched with the
global definition <span class="math notranslate">\((c:=t:T)\)</span>.</p>
<p>The rules for inductive definitions (see Section
<a class="reference internal" href="#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>) have to be considered as assumption
rules to which the following definitions apply: if the name <span class="math notranslate">\(c\)</span>
is declared in <span class="math notranslate">\(E\)</span>, we write <span class="math notranslate">\(c ∈ E\)</span> and if <span class="math notranslate">\(c:T\)</span> or
<span class="math notranslate">\(c:=t:T\)</span> is declared in <span class="math notranslate">\(E\)</span>, we write <span class="math notranslate">\((c : T) ∈ E\)</span>.</p>
<p id="typing-rules2"><strong>Typing rules.</strong>
In the following, we define simultaneously two judgments. The first
one <span class="math notranslate">\(\WTEG{t}{T}\)</span> means the term <span class="math notranslate">\(t\)</span> is well-typed and has type <span class="math notranslate">\(T\)</span> in the
global environment <span class="math notranslate">\(E\)</span> and local context <span class="math notranslate">\(Γ\)</span>. The second judgment <span class="math notranslate">\(\WFE{Γ}\)</span>
means that the global environment <span class="math notranslate">\(E\)</span> is well-formed and the local
context <span class="math notranslate">\(Γ\)</span> is a valid local context in this global environment.</p>
<p>A term <span class="math notranslate">\(t\)</span> is well typed in a global environment <span class="math notranslate">\(E\)</span> iff
there exists a local context <span class="math notranslate">\(\Gamma\)</span> and a term <span class="math notranslate">\(T\)</span> such
that the judgment <span class="math notranslate">\(\WTEG{t}{T}\)</span> can be derived from the
following rules.</p>
<dl class="docutils">
<dt id="inference-w-empty">W-Empty<td><div class="first last math notranslate">
\[\frac{%
%
}{%
\WF{[]}{}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-local-assum">W-Local-Assum<td><div class="first last math notranslate">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in \Sort%
\hspace{3em}%
x \not\in \Gamma % \cup E%
}{%
\WFE{\Gamma::(x:T)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-local-def">W-Local-Def<td><div class="first last math notranslate">
\[\frac{%
\WTEG{t}{T}%
\hspace{3em}%
x \not\in \Gamma % \cup E%
}{%
\WFE{\Gamma::(x:=t:T)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-global-assum">W-Global-Assum<td><div class="first last math notranslate">
\[\frac{%
\WTE{}{T}{s}%
\hspace{3em}%
s \in \Sort%
\hspace{3em}%
c \notin E%
}{%
\WF{E;c:T}{}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-w-global-def">W-Global-Def<td><div class="first last math notranslate">
\[\frac{%
\WTE{}{t}{T}%
\hspace{3em}%
c \notin E%
}{%
\WF{E;c:=t:T}{}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-ax-prop">Ax-Prop<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
}{%
\WTEG{\Prop}{\Type(1)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-ax-set">Ax-Set<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
}{%
\WTEG{\Set}{\Type(1)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-ax-type">Ax-Type<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
}{%
\WTEG{\Type(i)}{\Type(i+1)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-var">Var<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(x:T) \in \Gamma~~\mbox{or}~~(x:=t:T) \in \Gamma~\mbox{for some $t$}%
}{%
\WTEG{x}{T}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-const">Const<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(c:T) \in E~~\mbox{or}~~(c:=t:T) \in E~\mbox{for some $t$}%
}{%
\WTEG{c}{T}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-prod-prop">Prod-Prop<td><div class="first last math notranslate">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in {\Sort}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{U}{\Prop}%
}{%
\WTEG{\forall~x:T,U}{\Prop}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-prod-set">Prod-Set<td><div class="first last math notranslate">
\[\frac{%
\WTEG{T}{s}%
\hspace{3em}%
s \in \{\Prop, \Set\}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{U}{\Set}%
}{%
\WTEG{\forall~x:T,U}{\Set}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-prod-type">Prod-Type<td><div class="first last math notranslate">
\[\frac{%
\WTEG{T}{\Type(i)}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{U}{\Type(i)}%
}{%
\WTEG{\forall~x:T,U}{\Type(i)}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-lam">Lam<td><div class="first last math notranslate">
\[\frac{%
\WTEG{\forall~x:T,U}{s}%
\hspace{3em}%
\WTE{\Gamma::(x:T)}{t}{U}%
}{%
\WTEG{\lb x:T\mto t}{\forall x:T, U}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-app">App<td><div class="first last math notranslate">
\[\frac{%
\WTEG{t}{\forall~x:U,T}%
\hspace{3em}%
\WTEG{u}{U}%
}{%
\WTEG{(t\ u)}{\subst{T}{x}{u}}%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-let">Let<td><div class="first last math notranslate">
\[\frac{%
\WTEG{t}{T}%
\hspace{3em}%
\WTE{\Gamma::(x:=t:T)}{u}{U}%
}{%
\WTEG{\letin{x}{t:T}{u}}{\subst{U}{x}{t}}%
}\]</div>
</td></dl>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p><strong>Prod-Prop</strong> and <strong>Prod-Set</strong> typing-rules make sense if we consider the
semantic difference between <span class="math notranslate">\(\Prop\)</span> and <span class="math notranslate">\(\Set\)</span>:</p>
<ul class="last simple">
<li>All values of a type that has a sort <span class="math notranslate">\(\Set\)</span> are extractable.</li>
<li>No values of a type that has a sort <span class="math notranslate">\(\Prop\)</span> are extractable.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">We may have <span class="math notranslate">\(\letin{x}{t:T}{u}\)</span> well-typed without having
<span class="math notranslate">\(((λ x:T.u) t)\)</span> well-typed (where <span class="math notranslate">\(T\)</span> is a type of
<span class="math notranslate">\(t\)</span>). This is because the value <span class="math notranslate">\(t\)</span> associated to
<span class="math notranslate">\(x\)</span> may be used in a conversion rule
(see Section <a class="reference internal" href="#conversion-rules"><span class="std std-ref">Conversion rules</span></a>).</p>
</div>
</div>
<div class="section" id="conversion-rules">
<span id="id10"></span><h2>Conversion rules<a class="headerlink" href="#conversion-rules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In <span class="smallcaps">Cic</span>, there is an internal reduction mechanism. In particular, it
can decide if two programs are <em>intentionally</em> equal (one says
<em>convertible</em>). Convertibility is described in this section.</p>
<div class="section" id="reduction">
<span id="beta-reduction"></span><h3>β-reduction<a class="headerlink" href="#reduction" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>We want to be able to identify some terms as we can identify the
application of a function to a given argument with its result. For
instance the identity function over a given type T can be written
<span class="math notranslate">\(λx:T. x\)</span>. In any global environment <span class="math notranslate">\(E\)</span> and local context
<span class="math notranslate">\(Γ\)</span>, we want to identify any object <span class="math notranslate">\(a\)</span> (of type
<span class="math notranslate">\(T\)</span>) with the application <span class="math notranslate">\(((λ x:T. x) a)\)</span>.  We define for
this a <em>reduction</em> (or a <em>conversion</em>) rule we call <span class="math notranslate">\(β\)</span>:</p>
<div class="math notranslate">
\[E[Γ] ⊢ ((λx:T. t) u)~\triangleright_β~\subst{t}{x}{u}\]</div>
<p>We say that <span class="math notranslate">\(\subst{t}{x}{u}\)</span> is the <em>β-contraction</em> of
<span class="math notranslate">\(((λx:T. t) u)\)</span> and, conversely, that <span class="math notranslate">\(((λ x:T. t) u)\)</span> is the
<em>β-expansion</em> of <span class="math notranslate">\(\subst{t}{x}{u}\)</span>.</p>
<p>According to β-reduction, terms of the <em>Calculus of Inductive
Constructions</em> enjoy some fundamental properties such as confluence,
strong normalization, subject reduction. These results are
theoretically of great importance but we will not detail them here and
refer the interested reader to <a class="reference internal" href="../zebibliography.html#coq85" id="id11">[Coq85]</a>.</p>
</div>
<div class="section" id="iota-reduction">
<span id="id12"></span><h3>ι-reduction<a class="headerlink" href="#iota-reduction" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>A specific conversion rule is associated to the inductive objects in
the global environment. We shall give later on (see Section
<a class="reference internal" href="#well-formed-inductive-definitions"><span class="std std-ref">Well-formed inductive definitions</span></a>) the precise rules but it
just says that a destructor applied to an object built from a
constructor behaves as expected. This reduction is called ι-reduction
and is more precisely studied in <a class="reference internal" href="../zebibliography.html#moh93" id="id13">[PM93]</a><a class="reference internal" href="../zebibliography.html#wer94" id="id14">[Wer94]</a>.</p>
</div>
<div class="section" id="delta-reduction">
<span id="id15"></span><h3>δ-reduction<a class="headerlink" href="#delta-reduction" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>We may have variables defined in local contexts or constants defined
in the global environment. It is legal to identify such a reference
with its value, that is to expand (or unfold) it into its value. This
reduction is called δ-reduction and shows as follows.</p>
<dl class="docutils">
<dt id="inference-delta-local">Delta-Local<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(x:=t:T) ∈ Γ%
}{%
E[Γ] ⊢ x~\triangleright_Δ~t%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-delta-global">Delta-Global<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
(c:=t:T) ∈ E%
}{%
E[Γ] ⊢ c~\triangleright_δ~t%
}\]</div>
</td></dl>
</div>
<div class="section" id="zeta-reduction">
<span id="id16"></span><h3>ζ-reduction<a class="headerlink" href="#zeta-reduction" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><span class="smallcaps">Coq</span> allows also to remove local definitions occurring in terms by
replacing the defined variable by its value. The declaration being
destroyed, this reduction differs from δ-reduction. It is called
ζ-reduction and shows as follows.</p>
<dl class="docutils">
<dt id="inference-zeta">Zeta<td><div class="first last math notranslate">
\[\frac{%
\WFE{\Gamma}%
\hspace{3em}%
\WTEG{u}{U}%
\hspace{3em}%
\WTE{\Gamma::(x:=u:U)}{t}{T}%
}{%
E[Γ] ⊢ \letin{x}{u}{t}~\triangleright_ζ~\subst{t}{x}{u}%
}\]</div>
</td></dl>
</div>
<div class="section" id="expansion">
<span id="eta-expansion"></span><h3>η-expansion<a class="headerlink" href="#expansion" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Another important concept is η-expansion. It is legal to identify any
term <span class="math notranslate">\(t\)</span> of functional type <span class="math notranslate">\(∀ x:T, U\)</span> with its so-called η-expansion</p>
<div class="math notranslate">
\[λx:T. (t~x)\]</div>
<p>for <span class="math notranslate">\(x\)</span> an arbitrary variable name fresh in <span class="math notranslate">\(t\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>We deliberately do not define η-reduction:</p>
<div class="math notranslate">
\[λ x:T. (t~x) \not\triangleright_η t\]</div>
<p>This is because, in general, the type of <span class="math notranslate">\(t\)</span> need not to be convertible
to the type of <span class="math notranslate">\(λ x:T. (t~x)\)</span>. E.g., if we take <span class="math notranslate">\(f\)</span> such that:</p>
<div class="math notranslate">
\[f : ∀ x:\Type(2),\Type(1)\]</div>
<p>then</p>
<div class="math notranslate">
\[λ x:\Type(1),(f~x) : ∀ x:\Type(1),\Type(1)\]</div>
<p>We could not allow</p>
<div class="math notranslate">
\[λ x:Type(1),(f x) \triangleright_η f\]</div>
<p class="last">because the type of the reduced term <span class="math notranslate">\(∀ x:\Type(2),\Type(1)\)</span> would not be
convertible to the type of the original term <span class="math notranslate">\(∀ x:\Type(1),\Type(1).\)</span></p>
</div>
</div>
<div class="section" id="convertibility">
<span id="id17"></span><h3>Convertibility<a class="headerlink" href="#convertibility" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Let us write <span class="math notranslate">\(E[Γ] ⊢ t \triangleright u\)</span> for the contextual closure of the
relation <span class="math notranslate">\(t\)</span> reduces to <span class="math notranslate">\(u\)</span> in the global environment
<span class="math notranslate">\(E\)</span> and local context <span class="math notranslate">\(Γ\)</span> with one of the previous
reductions β, ι, δ or ζ.</p>
<p>We say that two terms <span class="math notranslate">\(t_1\)</span> and <span class="math notranslate">\(t_2\)</span> are
<em>βιδζη-convertible</em>, or simply <em>convertible</em>, or <em>equivalent</em>, in the
global environment <span class="math notranslate">\(E\)</span> and local context <span class="math notranslate">\(Γ\)</span> iff there
exist terms <span class="math notranslate">\(u_1\)</span> and <span class="math notranslate">\(u_2\)</span> such that <span class="math notranslate">\(E[Γ] ⊢ t_1 \triangleright
… \triangleright u_1\)</span> and <span class="math notranslate">\(E[Γ] ⊢ t_2 \triangleright … \triangleright u_2\)</span> and either <span class="math notranslate">\(u_1\)</span> and
<span class="math notranslate">\(u_2\)</span> are identical, or they are convertible up to η-expansion,
i.e. <span class="math notranslate">\(u_1\)</span> is <span class="math notranslate">\(λ x:T. u_1'\)</span> and <span class="math notranslate">\(u_2 x\)</span> is
recursively convertible to <span class="math notranslate">\(u_1'\)</span> , or, symmetrically,
<span class="math notranslate">\(u_2\)</span> is <span class="math notranslate">\(λx:T. u_2'\)</span>
and <span class="math notranslate">\(u_1 x\)</span> is recursively convertible to u_2′ . We then write
<span class="math notranslate">\(E[Γ] ⊢ t_1 =_{βδιζη} t_2\)</span> .</p>
<p>Apart from this we consider two instances of polymorphic and
cumulative (see Chapter <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) inductive types
(see below) convertible</p>
<div class="math notranslate">
\[E[Γ] ⊢ t~w_1 … w_m =_{βδιζη} t~w_1' … w_m'\]</div>
<p>if we have subtypings (see below) in both directions, i.e.,</p>
<div class="math notranslate">
\[E[Γ] ⊢ t~w_1 … w_m ≤_{βδιζη} t~w_1' … w_m'\]</div>
<p>and</p>
<div class="math notranslate">
\[E[Γ] ⊢ t~w_1' … w_m' ≤_{βδιζη} t~w_1 … w_m.\]</div>
<p>Furthermore, we consider</p>
<div class="math notranslate">
\[E[Γ] ⊢ c~v_1 … v_m =_{βδιζη} c'~v_1' … v_m'\]</div>
<p>convertible if</p>
<div class="math notranslate">
\[E[Γ] ⊢ v_i =_{βδιζη} v_i'\]</div>
<p>and we have that <span class="math notranslate">\(c\)</span> and <span class="math notranslate">\(c'\)</span>
are the same constructors of different instances of the same inductive
types (differing only in universe levels) such that</p>
<div class="math notranslate">
\[E[Γ] ⊢ c~v_1 … v_m : t~w_1 … w_m\]</div>
<p>and</p>
<div class="math notranslate">
\[E[Γ] ⊢ c'~v_1' … v_m' : t'~ w_1' … w_m '\]</div>
<p>and we have</p>
<div class="math notranslate">
\[E[Γ] ⊢ t~w_1 … w_m =_{βδιζη} t~w_1' … w_m'.\]</div>
<p>The convertibility relation allows introducing a new typing rule which
says that two convertible well-formed types have the same inhabitants.</p>
</div>
</div>
<div class="section" id="subtyping-rules">
<span id="id18"></span><h2>Subtyping rules<a class="headerlink" href="#subtyping-rules" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>At the moment, we did not take into account one rule between universes
which says that any term in a universe of index i is also a term in
the universe of index i+1 (this is the <em>cumulativity</em> rule of <span class="smallcaps">Cic</span>).
This property extends the equivalence relation of convertibility into
a <em>subtyping</em> relation inductively defined by:</p>
<ol class="arabic">
<li><p class="first">if <span class="math notranslate">\(E[Γ] ⊢ t =_{βδιζη} u\)</span> then <span class="math notranslate">\(E[Γ] ⊢ t ≤_{βδιζη} u\)</span>,</p>
</li>
<li><p class="first">if <span class="math notranslate">\(i ≤ j\)</span> then <span class="math notranslate">\(E[Γ] ⊢ \Type(i) ≤_{βδιζη} \Type(j)\)</span>,</p>
</li>
<li><p class="first">for any <span class="math notranslate">\(i\)</span>, <span class="math notranslate">\(E[Γ] ⊢ \Set ≤_{βδιζη} \Type(i)\)</span>,</p>
</li>
<li><p class="first"><span class="math notranslate">\(E[Γ] ⊢ \Prop ≤_{βδιζη} \Set\)</span>, hence, by transitivity,
<span class="math notranslate">\(E[Γ] ⊢ \Prop ≤_{βδιζη} \Type(i)\)</span>, for any <span class="math notranslate">\(i\)</span></p>
</li>
<li><p class="first">if <span class="math notranslate">\(E[Γ] ⊢ T =_{βδιζη} U\)</span> and
<span class="math notranslate">\(E[Γ::(x:T)] ⊢ T' ≤_{βδιζη} U'\)</span> then
<span class="math notranslate">\(E[Γ] ⊢ ∀x:T, T′ ≤_{βδιζη} ∀ x:U, U′\)</span>.</p>
</li>
<li><p class="first">if <span class="math notranslate">\(\ind{p}{Γ_I}{Γ_C}\)</span> is a universe polymorphic and cumulative
(see Chapter <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) inductive type (see below)
and
<span class="math notranslate">\((t : ∀Γ_P ,∀Γ_{\mathit{Arr}(t)}, \Sort)∈Γ_I\)</span>
and
<span class="math notranslate">\((t' : ∀Γ_P' ,∀Γ_{\mathit{Arr}(t)}', \Sort')∈Γ_I\)</span>
are two different instances of <em>the same</em> inductive type (differing only in
universe levels) with constructors</p>
<div class="math notranslate">
\[[c_1 : ∀Γ_P ,∀ T_{1,1} … T_{1,n_1} , t~v_{1,1} … v_{1,m} ;…;
c_k : ∀Γ_P ,∀ T_{k,1} … T_{k,n_k} ,t~v_{n,1} … v_{n,m} ]\]</div>
<p>and</p>
<div class="math notranslate">
\[[c_1 : ∀Γ_P' ,∀ T_{1,1}' … T_{1,n_1}' , t'~v_{1,1}' … v_{1,m}' ;…;
c_k : ∀Γ_P' ,∀ T_{k,1}' … T_{k,n_k}' ,t'~v_{n,1}' … v_{n,m}' ]\]</div>
<p>respectively then</p>
<div class="math notranslate">
\[E[Γ] ⊢ t~w_1 … w_m ≤_{βδιζη} t'~w_1' … w_m'\]</div>
<p>(notice that <span class="math notranslate">\(t\)</span> and <span class="math notranslate">\(t'\)</span> are both
fully applied, i.e., they have a sort as a type) if</p>
<div class="math notranslate">
\[E[Γ] ⊢ w_i =_{βδιζη} w_i'\]</div>
<p>for <span class="math notranslate">\(1 ≤ i ≤ m\)</span> and we have</p>
<div class="math notranslate">
\[E[Γ] ⊢ T_{i,j} ≤_{βδιζη} T_{i,j}'\]</div>
<p>and</p>
<div class="math notranslate">
\[E[Γ] ⊢ A_i ≤_{βδιζη} A_i'\]</div>
<p>where <span class="math notranslate">\(Γ_{\mathit{Arr}(t)} = [a_1 : A_1 ;  … ; a_l : A_l ]\)</span> and
<span class="math notranslate">\(Γ_{\mathit{Arr}(t)}' = [a_1 : A_1';  … ; a_l : A_l']\)</span>.</p>
</li>
</ol>
<p>The conversion rule up to subtyping is now exactly:</p>
<dl class="docutils">
<dt id="inference-conv">Conv<td><div class="first last math notranslate">
\[\frac{%
E[Γ] ⊢ U : s%
\hspace{3em}%
E[Γ] ⊢ t : T%
\hspace{3em}%
E[Γ] ⊢ T ≤_{βδιζη} U%
}{%
E[Γ] ⊢ t : U%
}\]</div>
</td></dl>
<p id="normal-form"><strong>Normal form</strong>. A term which cannot be any more reduced is said to be in <em>normal
form</em>. There are several ways (or strategies) to apply the reduction
rules. Among them, we have to mention the <em>head reduction</em> which will
play an important role (see Chapter <a class="reference internal" href="../proof-engine/tactics.html#tactics"><span class="std std-ref">Tactics</span></a>). Any term <span class="math notranslate">\(t\)</span> can be written as
<span class="math notranslate">\(λ x_1 :T_1 . … λ x_k :T_k . (t_0~t_1 … t_n )\)</span> where <span class="math notranslate">\(t_0\)</span> is not an
application. We say then that <span class="math notranslate">\(t~0\)</span> is the <em>head of</em> <span class="math notranslate">\(t\)</span>. If we assume
that <span class="math notranslate">\(t_0\)</span> is <span class="math notranslate">\(λ x:T. u_0\)</span> then one step of β-head reduction of <span class="math notranslate">\(t\)</span> is:</p>
<div class="math notranslate">
\[λ x_1 :T_1 . … λ x_k :T_k . (λ x:T. u_0~t_1 … t_n ) \triangleright
λ (x_1 :T_1 )…(x_k :T_k ). (\subst{u_0}{x}{t_1}~t_2 … t_n )\]</div>
<p>Iterating the process of head reduction until the head of the reduced
term is no more an abstraction leads to the <em>β-head normal form</em> of <span class="math notranslate">\(t\)</span>:</p>
<div class="math notranslate">
\[t \triangleright … \triangleright λ x_1 :T_1 . …λ x_k :T_k . (v~u_1 … u_m )\]</div>
<p>where <span class="math notranslate">\(v\)</span> is not an abstraction (nor an application). Note that the head
normal form must not be confused with the normal form since some <span class="math notranslate">\(u_i\)</span>
can be reducible. Similar notions of head-normal forms involving δ, ι
and ζ reductions or any combination of those can also be defined.</p>
</div>
<div class="section" id="inductive-definitions">
<span id="id19"></span><h2>Inductive Definitions<a class="headerlink" href="#inductive-definitions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Formally, we can represent any <em>inductive definition</em> as
<span class="math notranslate">\(\ind{p}{Γ_I}{Γ_C}\)</span> where:</p>
<ul class="simple">
<li><span class="math notranslate">\(Γ_I\)</span> determines the names and types of inductive types;</li>
<li><span class="math notranslate">\(Γ_C\)</span> determines the names and types of constructors of these
inductive types;</li>
<li><span class="math notranslate">\(p\)</span> determines the number of parameters of these inductive types.</li>
</ul>
<p>These inductive definitions, together with global assumptions and
global definitions, then form the global environment. Additionally,
for any <span class="math notranslate">\(p\)</span> there always exists <span class="math notranslate">\(Γ_P =[a_1 :A_1 ;…;a_p :A_p ]\)</span> such that
each <span class="math notranslate">\(T\)</span> in <span class="math notranslate">\((t:T)∈Γ_I \cup Γ_C\)</span> can be written as: <span class="math notranslate">\(∀Γ_P , T'\)</span> where <span class="math notranslate">\(Γ_P\)</span> is
called the <em>context of parameters</em>. Furthermore, we must have that
each <span class="math notranslate">\(T\)</span> in <span class="math notranslate">\((t:T)∈Γ_I\)</span> can be written as: <span class="math notranslate">\(∀Γ_P,∀Γ_{\mathit{Arr}(t)}, S\)</span> where
<span class="math notranslate">\(Γ_{\mathit{Arr}(t)}\)</span> is called the <em>Arity</em> of the inductive type t and <span class="math notranslate">\(S\)</span> is called
the sort of the inductive type t (not to be confused with <span class="math notranslate">\(\Sort\)</span> which is the set of sorts).</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The declaration for parameterized lists is:</p>
<div class="math notranslate">
\[\begin{split}\ind{1}{[\List:\Set→\Set]}{\left[\begin{array}{rcl}
\Nil &amp; : &amp; \forall A:\Set,\List~A \\
\cons &amp; : &amp; \forall A:\Set, A→ \List~A→ \List~A
\end{array}
\right]}\end{split}\]</div>
<p>which corresponds to the result of the <span class="smallcaps">Coq</span> declaration:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The declaration for a mutual inductive definition of tree and forest
is:</p>
<div class="math notranslate">
\[\begin{split}\ind{0}{\left[\begin{array}{rcl}\tree&amp;:&amp;\Set\\\forest&amp;:&amp;\Set\end{array}\right]}
 {\left[\begin{array}{rcl}
          \node &amp;:&amp; \forest → \tree\\
          \emptyf &amp;:&amp; \forest\\
          \consf &amp;:&amp; \tree → \forest → \forest\\
                    \end{array}\right]}\end{split}\]</div>
<p>which corresponds to the result of the <span class="smallcaps">Coq</span> declaration:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">tree</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">tree</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">forest</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">emptyf</span><span> : </span><span class="coqdoc-var">forest</span><span>
| </span><span class="coqdoc-var">consf</span><span> : </span><span class="coqdoc-var">tree</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span> -&gt; </span><span class="coqdoc-var">forest</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">tree, forest are defined
tree_rect is defined
tree_ind is defined
tree_rec is defined
forest_rect is defined
forest_ind is defined
forest_rec is defined</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The declaration for a mutual inductive definition of even and odd is:</p>
<div class="math notranslate">
\[\begin{split}\ind{0}{\left[\begin{array}{rcl}\even&amp;:&amp;\nat → \Prop \\
                                \odd&amp;:&amp;\nat → \Prop \end{array}\right]}
 {\left[\begin{array}{rcl}
          \evenO &amp;:&amp; \even~0\\
          \evenS &amp;:&amp; \forall n, \odd~n -&gt; \even~(\kw{S}~n)\\
          \oddS &amp;:&amp; \forall n, \even~n -&gt; \odd~(\kw{S}~n)
                    \end{array}\right]}\end{split}\]</div>
<p>which corresponds to the result of the <span class="smallcaps">Coq</span> declaration:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">even</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">even_O</span><span> : </span><span class="coqdoc-var">even</span><span> 0</span><span>
| </span><span class="coqdoc-var">even_S</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">odd</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">even</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>)</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">odd</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">odd_S</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">even</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">odd</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 109-113:
&gt; Inductive even : nat -&gt; Prop := | even_O : even 0 | even_S : forall n, odd n -&gt; even (S n) with odd : nat -&gt; prop := | odd_S : forall n, even n -&gt; odd (S n).
&gt;                                                                                                              ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference prop was not found in the current environment.</span></dd>
</dl>
</div>
</div>
<div class="section" id="types-of-inductive-objects">
<span id="id20"></span><h3>Types of inductive objects<a class="headerlink" href="#types-of-inductive-objects" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>We have to give the type of constants in a global environment E which
contains an inductive declaration.</p>
<dl class="docutils">
<dt id="inference-ind">Ind<td><div class="first last math notranslate">
\[\frac{%
\WFE{Γ}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} ∈ E%
\hspace{3em}%
(a:A)∈Γ_I%
}{%
E[Γ] ⊢ a : A%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-constr">Constr<td><div class="first last math notranslate">
\[\frac{%
\WFE{Γ}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} ∈ E%
\hspace{3em}%
(c:C)∈Γ_C%
}{%
E[Γ] ⊢ c : C%
}\]</div>
</td></dl>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Provided that our environment <span class="math notranslate">\(E\)</span> contains inductive definitions we showed before,
these two inference rules above enable us to conclude that:</p>
<div class="last math notranslate">
\[\begin{split}\begin{array}{l}
E[Γ] ⊢ \even : \nat→\Prop\\
E[Γ] ⊢ \odd : \nat→\Prop\\
E[Γ] ⊢ \even\_O : \even~O\\
E[Γ] ⊢ \even\_S : \forall~n:\nat, \odd~n → \even~(S~n)\\
E[Γ] ⊢ \odd\_S : \forall~n:\nat, \even~n → \odd~(S~n)
\end{array}\end{split}\]</div>
</div>
</div>
<div class="section" id="well-formed-inductive-definitions">
<span id="id21"></span><h3>Well-formed inductive definitions<a class="headerlink" href="#well-formed-inductive-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>We cannot accept any inductive declaration because some of them lead
to inconsistent systems. We restrict ourselves to definitions which
satisfy a syntactic criterion of positivity. Before giving the formal
rules, we need a few definitions:</p>
<div class="section" id="arity-of-a-given-sort">
<h4>Arity of a given sort<a class="headerlink" href="#arity-of-a-given-sort" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>A type <span class="math notranslate">\(T\)</span> is an <em>arity of sort</em> <span class="math notranslate">\(s\)</span> if it converts to the sort <span class="math notranslate">\(s\)</span> or to a
product <span class="math notranslate">\(∀ x:T,U\)</span> with <span class="math notranslate">\(U\)</span> an arity of sort <span class="math notranslate">\(s\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p class="last"><span class="math notranslate">\(A→\Set\)</span> is an arity of sort <span class="math notranslate">\(\Set\)</span>. <span class="math notranslate">\(∀ A:\Prop,A→ \Prop\)</span> is an arity of sort
<span class="math notranslate">\(\Prop\)</span>.</p>
</div>
</div>
<div class="section" id="arity">
<h4>Arity<a class="headerlink" href="#arity" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>A type <span class="math notranslate">\(T\)</span> is an <em>arity</em> if there is a <span class="math notranslate">\(s∈ \Sort\)</span> such that <span class="math notranslate">\(T\)</span> is an arity of
sort <span class="math notranslate">\(s\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p class="last"><span class="math notranslate">\(A→ Set\)</span> and <span class="math notranslate">\(∀ A:\Prop,A→ \Prop\)</span> are arities.</p>
</div>
</div>
<div class="section" id="type-constructor">
<h4>Type constructor<a class="headerlink" href="#type-constructor" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>We say that T is a <em>type of constructor of I</em> in one of the following
two cases:</p>
<ul class="simple">
<li><span class="math notranslate">\(T\)</span> is <span class="math notranslate">\((I~t_1 … t_n )\)</span></li>
<li><span class="math notranslate">\(T\)</span> is <span class="math notranslate">\(∀ x:U,T'\)</span> where <span class="math notranslate">\(T'\)</span> is also a type of constructor of <span class="math notranslate">\(I\)</span></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p class="last"><span class="math notranslate">\(\nat\)</span> and <span class="math notranslate">\(\nat→\nat\)</span> are types of constructor of <span class="math notranslate">\(\nat\)</span>.
<span class="math notranslate">\(∀ A:Type,\List~A\)</span> and <span class="math notranslate">\(∀ A:Type,A→\List~A→\List~A\)</span> are types of constructor of <span class="math notranslate">\(\List\)</span>.</p>
</div>
</div>
<div class="section" id="positivity-condition">
<span id="positivity"></span><h4>Positivity Condition<a class="headerlink" href="#positivity-condition" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The type of constructor <span class="math notranslate">\(T\)</span> will be said to <em>satisfy the positivity
condition</em> for a constant <span class="math notranslate">\(X\)</span> in the following cases:</p>
<ul class="simple">
<li><span class="math notranslate">\(T=(X~t_1 … t_n )\)</span> and <span class="math notranslate">\(X\)</span> does not occur free in any <span class="math notranslate">\(t_i\)</span></li>
<li><span class="math notranslate">\(T=∀ x:U,V\)</span> and <span class="math notranslate">\(X\)</span> occurs only strictly positively in <span class="math notranslate">\(U\)</span> and the type <span class="math notranslate">\(V\)</span>
satisfies the positivity condition for <span class="math notranslate">\(X\)</span>.</li>
</ul>
</div>
<div class="section" id="strict-positivity">
<h4>Strict positivity<a class="headerlink" href="#strict-positivity" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The constant <span class="math notranslate">\(X\)</span> <em>occurs strictly positively</em> in <span class="math notranslate">\(T\)</span> in the following
cases:</p>
<ul>
<li><p class="first"><span class="math notranslate">\(X\)</span> does not occur in <span class="math notranslate">\(T\)</span></p>
</li>
<li><p class="first"><span class="math notranslate">\(T\)</span> converts to <span class="math notranslate">\((X~t_1 … t_n )\)</span> and <span class="math notranslate">\(X\)</span> does not occur in any of <span class="math notranslate">\(t_i\)</span></p>
</li>
<li><p class="first"><span class="math notranslate">\(T\)</span> converts to <span class="math notranslate">\(∀ x:U,V\)</span> and <span class="math notranslate">\(X\)</span> does not occur in type <span class="math notranslate">\(U\)</span> but occurs
strictly positively in type <span class="math notranslate">\(V\)</span></p>
</li>
<li><p class="first"><span class="math notranslate">\(T\)</span> converts to <span class="math notranslate">\((I~a_1 … a_m~t_1 … t_p )\)</span> where <span class="math notranslate">\(I\)</span> is the name of an
inductive declaration of the form</p>
<div class="math notranslate">
\[\ind{m}{I:A}{c_1 :∀ p_1 :P_1 ,… ∀p_m :P_m ,C_1 ;…;c_n :∀ p_1 :P_1 ,… ∀p_m :P_m ,C_n}\]</div>
<p>(in particular, it is
not mutually defined and it has <span class="math notranslate">\(m\)</span> parameters) and <span class="math notranslate">\(X\)</span> does not occur in
any of the <span class="math notranslate">\(t_i\)</span>, and the (instantiated) types of constructor
<span class="math notranslate">\(\subst{C_i}{p_j}{a_j}_{j=1… m}\)</span> of <span class="math notranslate">\(I\)</span> satisfy the nested positivity condition for <span class="math notranslate">\(X\)</span></p>
</li>
</ul>
</div>
<div class="section" id="nested-positivity">
<h4>Nested Positivity<a class="headerlink" href="#nested-positivity" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The type of constructor <span class="math notranslate">\(T\)</span> of <span class="math notranslate">\(I\)</span> <em>satisfies the nested positivity
condition</em> for a constant <span class="math notranslate">\(X\)</span> in the following cases:</p>
<ul class="simple">
<li><span class="math notranslate">\(T=(I~b_1 … b_m~u_1 … u_p)\)</span>, <span class="math notranslate">\(I\)</span> is an inductive definition with <span class="math notranslate">\(m\)</span>
parameters and <span class="math notranslate">\(X\)</span> does not occur in any <span class="math notranslate">\(u_i\)</span></li>
<li><span class="math notranslate">\(T=∀ x:U,V\)</span> and <span class="math notranslate">\(X\)</span> occurs only strictly positively in <span class="math notranslate">\(U\)</span> and the type <span class="math notranslate">\(V\)</span>
satisfies the nested positivity condition for <span class="math notranslate">\(X\)</span></li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>For instance, if one considers the following variant of a tree type
branching over the natural numbers:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">nattree</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">leaf</span><span> : </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">node</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; (</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>) -&gt; </span><span class="coqdoc-var">nattree</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-102:
&gt; Inductive nattree (A:Type) : Type := | leaf : nattree A | node : A -&gt; (nat -&gt; nattree A) -&gt; nattree A.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> node already exists.</span></dd>
<dt><span class="coqdoc-keyword">End</span><span> </span><span class="coqdoc-var">TreeExample</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-16:
&gt; End TreeExample.
&gt; ^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> There is nothing to end.</span></dd>
</dl>
</div>
<p>Then every instantiated constructor of <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> satisfies the nested positivity
condition for <code class="docutils literal notranslate"><span class="pre">nattree</span></code>:</p>
<ul class="last simple">
<li>Type <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> of constructor <code class="docutils literal notranslate"><span class="pre">leaf</span></code> satisfies the positivity condition for
<code class="docutils literal notranslate"><span class="pre">nattree</span></code> because <code class="docutils literal notranslate"><span class="pre">nattree</span></code> does not appear in any (real) arguments of the
type of that constructor (primarily because <code class="docutils literal notranslate"><span class="pre">nattree</span></code> does not have any (real)
arguments) ... (bullet 1)</li>
<li>Type <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">→</span> <span class="pre">(nat</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A)</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A</span></code> of constructor <code class="docutils literal notranslate"><span class="pre">node</span></code> satisfies the
positivity condition for <code class="docutils literal notranslate"><span class="pre">nattree</span></code> because:<ul>
<li><code class="docutils literal notranslate"><span class="pre">nattree</span></code> occurs only strictly positively in <code class="docutils literal notranslate"><span class="pre">A</span></code> ... (bullet 3)</li>
<li><code class="docutils literal notranslate"><span class="pre">nattree</span></code> occurs only strictly positively in <code class="docutils literal notranslate"><span class="pre">nat</span> <span class="pre">→</span> <span class="pre">nattree</span> <span class="pre">A</span></code> ... (bullet 3 + 2)</li>
<li><code class="docutils literal notranslate"><span class="pre">nattree</span></code> satisfies the positivity condition for <code class="docutils literal notranslate"><span class="pre">nattree</span> <span class="pre">A</span></code> ... (bullet 1)</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="correctness-rules">
<span id="id22"></span><h4>Correctness rules<a class="headerlink" href="#correctness-rules" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>We shall now describe the rules allowing the introduction of a new
inductive definition.</p>
<p>Let <span class="math notranslate">\(E\)</span> be a global environment and <span class="math notranslate">\(Γ_P\)</span>, <span class="math notranslate">\(Γ_I\)</span>, <span class="math notranslate">\(Γ_C\)</span> be contexts
such that <span class="math notranslate">\(Γ_I\)</span> is <span class="math notranslate">\([I_1 :∀ Γ_P ,A_1 ;…;I_k :∀ Γ_P ,A_k]\)</span>, and
<span class="math notranslate">\(Γ_C\)</span> is <span class="math notranslate">\([c_1:∀ Γ_P ,C_1 ;…;c_n :∀ Γ_P ,C_n ]\)</span>. Then</p>
<dl class="docutils">
<dt id="inference-w-ind">W-Ind<td><div class="first last math notranslate">
\[\frac{%
\WFE{Γ_P}%
\hspace{3em}%
(E[Γ_P ] ⊢ A_j : s_j )_{j=1… k}%
\hspace{3em}%
(E[Γ_I ;Γ_P ] ⊢ C_i : s_{q_i} )_{i=1… n}%
}{%
\WF{E;\ind{p}{Γ_I}{Γ_C}}{Γ}%
}\]</div>
</td></dl>
<p>provided that the following side conditions hold:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math notranslate">\(k&gt;0\)</span> and all of <span class="math notranslate">\(I_j\)</span> and <span class="math notranslate">\(c_i\)</span> are distinct names for <span class="math notranslate">\(j=1… k\)</span> and <span class="math notranslate">\(i=1… n\)</span>,</li>
<li><span class="math notranslate">\(p\)</span> is the number of parameters of <span class="math notranslate">\(\ind{p}{Γ_I}{Γ_C}\)</span> and <span class="math notranslate">\(Γ_P\)</span> is the
context of parameters,</li>
<li>for <span class="math notranslate">\(j=1… k\)</span> we have that <span class="math notranslate">\(A_j\)</span> is an arity of sort <span class="math notranslate">\(s_j\)</span> and <span class="math notranslate">\(I_j ∉ E\)</span>,</li>
<li>for <span class="math notranslate">\(i=1… n\)</span> we have that <span class="math notranslate">\(C_i\)</span> is a type of constructor of <span class="math notranslate">\(I_{q_i}\)</span> which
satisfies the positivity condition for <span class="math notranslate">\(I_1 … I_k\)</span> and <span class="math notranslate">\(c_i ∉ Γ ∪ E\)</span>.</li>
</ul>
</div></blockquote>
<p>One can remark that there is a constraint between the sort of the
arity of the inductive type and the sort of the type of its
constructors which will always be satisfied for the impredicative
sort <span class="math notranslate">\(\Prop\)</span> but may fail to define inductive definition on sort <span class="math notranslate">\(\Set\)</span> and
generate constraints between universes for inductive definitions in
the Type hierarchy.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>It is well known that the existential quantifier can be encoded as an
inductive definition. The following declaration introduces the second-
order existential quantifier <span class="math notranslate">\(∃ X.P(X)\)</span>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exProp</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">exP_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exProp</span><span> </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">exProp is defined
exProp_ind is defined</span></dd>
</dl>
</div>
<p>The same definition on <span class="math notranslate">\(\Set\)</span> is not allowed and fails:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exSet</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Set</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
</span><span class="coqdoc-var">exS_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Set</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exSet</span><span> </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd><span class="first last">The command has indeed failed with message:
Large non-propositional inductive types must be in Type.</span></dd>
</dl>
</div>
<p>It is possible to declare the same inductive definition in the
universe <span class="math notranslate">\(\Type\)</span>. The <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exType</span></span></code> inductive definition has type
<span class="math notranslate">\((\Type(i)→\Prop)→\Type(j)\)</span> with the constraint that the parameter <span class="math notranslate">\(X\)</span> of <span class="math notranslate">\(\kw{exT}_{\kw{intro}}\)</span>
has type <span class="math notranslate">\(\Type(k)\)</span> with <span class="math notranslate">\(k&lt;j\)</span> and <span class="math notranslate">\(k≤ i\)</span>.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">exType</span><span> (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-keyword">Type</span><span>-&gt;</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
</span><span class="coqdoc-var">exT_intro</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">X</span><span> -&gt; </span><span class="coqdoc-var">exType</span><span> </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd><span class="first last">exType is defined
exType_rect is defined
exType_ind is defined
exType_rec is defined</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="template-polymorphism">
<span id="id23"></span><h4>Template polymorphism<a class="headerlink" href="#template-polymorphism" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Inductive types declared in <span class="math notranslate">\(\Type\)</span> are polymorphic over their arguments
in <span class="math notranslate">\(\Type\)</span>. If <span class="math notranslate">\(A\)</span> is an arity of some sort and <span class="math notranslate">\(s\)</span> is a sort, we write <span class="math notranslate">\(A_{/s}\)</span>
for the arity obtained from <span class="math notranslate">\(A\)</span> by replacing its sort with <span class="math notranslate">\(s\)</span>.
Especially, if <span class="math notranslate">\(A\)</span> is well-typed in some global environment and local
context, then <span class="math notranslate">\(A_{/s}\)</span> is typable by typability of all products in the
Calculus of Inductive Constructions. The following typing rule is
added to the theory.</p>
<p>Let <span class="math notranslate">\(\ind{p}{Γ_I}{Γ_C}\)</span> be an inductive definition. Let
<span class="math notranslate">\(Γ_P = [p_1 :P_1 ;…;p_p :P_p ]\)</span> be its context of parameters,
<span class="math notranslate">\(Γ_I = [I_1:∀ Γ_P ,A_1 ;…;I_k :∀ Γ_P ,A_k ]\)</span> its context of definitions and
<span class="math notranslate">\(Γ_C = [c_1 :∀ Γ_P ,C_1 ;…;c_n :∀ Γ_P ,C_n]\)</span> its context of constructors,
with <span class="math notranslate">\(c_i\)</span> a constructor of <span class="math notranslate">\(I_{q_i}\)</span>. Let <span class="math notranslate">\(m ≤ p\)</span> be the length of the
longest prefix of parameters such that the <span class="math notranslate">\(m\)</span> first arguments of all
occurrences of all <span class="math notranslate">\(I_j\)</span> in all <span class="math notranslate">\(C_k\)</span> (even the occurrences in the
hypotheses of <span class="math notranslate">\(C_k\)</span>) are exactly applied to <span class="math notranslate">\(p_1 … p_m\)</span> (<span class="math notranslate">\(m\)</span> is the number
of <em>recursively uniform parameters</em> and the <span class="math notranslate">\(p−m\)</span> remaining parameters
are the <em>recursively non-uniform parameters</em>). Let <span class="math notranslate">\(q_1 , …, q_r\)</span> , with
<span class="math notranslate">\(0≤ r≤ m\)</span>, be a (possibly) partial instantiation of the recursively
uniform parameters of <span class="math notranslate">\(Γ_P\)</span> . We have:</p>
<dl class="docutils">
<dt id="inference-ind-family">Ind-Family<td><div class="first last math notranslate">
\[\begin{split}\frac{%
\left\{\begin{array}{l}%
\hspace{3em}%
\ind{p}{Γ_I}{Γ_C} \in E\\%
\hspace{3em}%
(E[]  ⊢ q_l : P'_l)_{l=1\ldots r}\\%
\hspace{3em}%
(E[]  ⊢ P'_l ≤_{βδιζη} \subst{P_l}{p_u}{q_u}_{u=1\ldots l-1})_{l=1\ldots r}\\%
\hspace{3em}%
1 \leq j \leq k%
\hspace{3em}%
\end{array}%
\hspace{3em}%
\right.%
}{%
E[] ⊢ I_j~q_1 … q_r :∀ [p_{r+1} :P_{r+1} ;…;p_p :P_p], (A_j)_{/s_j}%
}\end{split}\]</div>
</td></dl>
<p>provided that the following side conditions hold:</p>
<blockquote>
<div><ul class="simple">
<li><span class="math notranslate">\(Γ_{P′}\)</span> is the context obtained from <span class="math notranslate">\(Γ_P\)</span> by replacing each <span class="math notranslate">\(P_l\)</span> that is
an arity with <span class="math notranslate">\(P_l'\)</span> for <span class="math notranslate">\(1≤ l ≤ r\)</span> (notice that <span class="math notranslate">\(P_l\)</span> arity implies <span class="math notranslate">\(P_l'\)</span>
arity since <span class="math notranslate">\((E[] ⊢ P_l' ≤_{βδιζη} \subst{P_l}{p_u}{q_u}_{u=1\ldots l-1} )\)</span>;</li>
<li>there are sorts <span class="math notranslate">\(s_i\)</span> , for <span class="math notranslate">\(1 ≤ i ≤ k\)</span> such that, for
<span class="math notranslate">\(Γ_{I'} = [I_1 :∀ Γ_{P'} ,(A_1)_{/s_1} ;…;I_k :∀ Γ_{P'} ,(A_k)_{/s_k}]\)</span>
we have <span class="math notranslate">\((E[Γ_{I′} ;Γ_{P′}] ⊢ C_i : s_{q_i})_{i=1… n}\)</span> ;</li>
<li>the sorts <span class="math notranslate">\(s_i\)</span> are such that all eliminations, to
<span class="math notranslate">\(\Prop\)</span>, <span class="math notranslate">\(\Set\)</span> and <span class="math notranslate">\(\Type(j)\)</span>, are allowed
(see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>).</li>
</ul>
</div></blockquote>
<p>Notice that if <span class="math notranslate">\(I_j~q_1 … q_r\)</span> is typable using the rules <strong>Ind-Const</strong> and
<strong>App</strong>, then it is typable using the rule <strong>Ind-Family</strong>. Conversely, the
extended theory is not stronger than the theory without <strong>Ind-Family</strong>. We
get an equiconsistency result by mapping each <span class="math notranslate">\(\ind{p}{Γ_I}{Γ_C}\)</span>
occurring into a given derivation into as many different inductive
types and constructors as the number of different (partial)
replacements of sorts, needed for this derivation, in the parameters
that are arities (this is possible because <span class="math notranslate">\(\ind{p}{Γ_I}{Γ_C}\)</span> well-formed
implies that <span class="math notranslate">\(\ind{p}{Γ_{I'}}{Γ_{C'}}\)</span> is well-formed and has the
same allowed eliminations, where <span class="math notranslate">\(Γ_{I′}\)</span> is defined as above and
<span class="math notranslate">\(Γ_{C′} = [c_1 :∀ Γ_{P′} ,C_1 ;…;c_n :∀ Γ_{P′} ,C_n ]\)</span>). That is, the changes in the
types of each partial instance <span class="math notranslate">\(q_1 … q_r\)</span> can be characterized by the
ordered sets of arity sorts among the types of parameters, and to each
signature is associated a new inductive definition with fresh names.
Conversion is preserved as any (partial) instance <span class="math notranslate">\(I_j~q_1 … q_r\)</span> or
<span class="math notranslate">\(C_i~q_1 … q_r\)</span> is mapped to the names chosen in the specific instance of
<span class="math notranslate">\(\ind{p}{Γ_I}{Γ_C}\)</span>.</p>
<p>In practice, the rule <strong>Ind-Family</strong> is used by <span class="smallcaps">Coq</span> only when all the
inductive types of the inductive definition are declared with an arity
whose sort is in the Type hierarchy. Then, the polymorphism is over
the parameters whose type is an arity of sort in the Type hierarchy.
The sorts <span class="math notranslate">\(s_j\)</span> are chosen canonically so that each <span class="math notranslate">\(s_j\)</span> is minimal with
respect to the hierarchy <span class="math notranslate">\(\Prop ⊂ \Set_p ⊂ \Type\)</span> where <span class="math notranslate">\(\Set_p\)</span> is predicative
<span class="math notranslate">\(\Set\)</span>. More precisely, an empty or small singleton inductive definition
(i.e. an inductive definition of which all inductive types are
singleton – see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>) is set in <span class="math notranslate">\(\Prop\)</span>, a small non-singleton
inductive type is set in <span class="math notranslate">\(\Set\)</span> (even in case <span class="math notranslate">\(\Set\)</span> is impredicative – see
Section <a class="reference internal" href="#the-calculus-of-inductive-construction-with-impredicative-set">The-Calculus-of-Inductive-Construction-with-impredicative-Set</a>),
and otherwise in the Type hierarchy.</p>
<p>Note that the side-condition about allowed elimination sorts in the
rule <strong>Ind-Family</strong> is just to avoid to recompute the allowed elimination
sorts at each instance of a pattern matching (see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>). As
an example, let us consider the following definition:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">option</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">None</span><span> : </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>
| </span><span class="coqdoc-var">Some</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">option is defined
option_rect is defined
option_ind is defined
option_rec is defined</span></dd>
</dl>
</div>
</div>
<p>As the definition is set in the Type hierarchy, it is used
polymorphically over its parameters whose types are arities of a sort
in the Type hierarchy. Here, the parameter <span class="math notranslate">\(A\)</span> has this property, hence,
if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is applied to a type in <span class="math notranslate">\(\Set\)</span>, the result is in <span class="math notranslate">\(\Set\)</span>. Note that
if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is applied to a type in <span class="math notranslate">\(\Prop\)</span>, then, the result is not set in
<span class="math notranslate">\(\Prop\)</span> but in <span class="math notranslate">\(\Set\)</span> still. This is because <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">option</span></span></code> is not a singleton type
(see Section <a class="reference internal" href="#destructors"><span class="std std-ref">Destructors</span></a>) and it would lose the elimination to <span class="math notranslate">\(\Set\)</span> and <span class="math notranslate">\(\Type\)</span>
if set in <span class="math notranslate">\(\Prop\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span> =&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">option</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span> =&gt; </span><span class="coqdoc-var">option</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">option</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Here is another example.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">prod</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">pair</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">prod is defined
prod_rect is defined
prod_ind is defined
prod_rec is defined</span></dd>
</dl>
</div>
</div>
<p>As <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">prod</span></span></code> is a singleton type, it will be in <span class="math notranslate">\(\Prop\)</span> if applied twice to
propositions, in <span class="math notranslate">\(\Set\)</span> if applied twice to at least one type in <span class="math notranslate">\(\Set\)</span> and
none in <span class="math notranslate">\(\Type\)</span>, and in <span class="math notranslate">\(\Type\)</span> otherwise. In all cases, the three kind of
eliminations schemes are allowed.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span> =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">prod</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span> =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">prod</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (B : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">prod</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> (</span><span class="coqdoc-keyword">fun</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) =&gt; </span><span class="coqdoc-var">prod</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>).</span></dt>
<dd><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative first">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (B : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">prod</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Template polymorphism used to be called “sort-polymorphism of
inductive types” before universe polymorphism
(see Chapter <a class="reference internal" href="../addendum/universe-polymorphism.html#polymorphicuniverses"><span class="std std-ref">Polymorphic Universes</span></a>) was introduced.</p>
</div>
</div>
</div>
<div class="section" id="destructors">
<span id="id24"></span><h3>Destructors<a class="headerlink" href="#destructors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The specification of inductive definitions with arities and
constructors is quite natural. But we still have to say how to use an
object in an inductive type.</p>
<p>This problem is rather delicate. There are actually several different
ways to do that. Some of them are logically equivalent but not always
equivalent from the computational point of view or from the user point
of view.</p>
<p>From the computational point of view, we want to be able to define a
function whose domain is an inductively defined type by using a
combination of case analysis over the possible constructors of the
object and recursion.</p>
<p>Because we need to keep a consistent theory and also we prefer to keep
a strongly normalizing reduction, we cannot accept any sort of
recursion (even terminating). So the basic idea is to restrict
ourselves to primitive recursive functions and functionals.</p>
<p>For instance, assuming a parameter <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword namespace"><span class="pre">Set</span></span></code> exists in the local context,
we want to build a function length of type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="keyword type"><span class="pre">nat</span></span></code> which computes
the length of the list, such that <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">nil</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">))</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">O</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span>
<span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">cons</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">))</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">))</span></span></code>. We want these equalities to be
recognized implicitly and taken into account in the conversion rule.</p>
<p>From the logical point of view, we have built a type family by giving
a set of constructors. We want to capture the fact that we do not have
any other way to build an object in this type. So when trying to prove
a property about an object <span class="math notranslate">\(m\)</span> in an inductive definition it is enough
to enumerate all the cases where <span class="math notranslate">\(m\)</span> starts with a different
constructor.</p>
<p>In case the inductive definition is effectively a recursive one, we
want to capture the extra property that we have built the smallest
fixed point of this recursive equation. This says that we are only
manipulating finite objects. This analysis provides induction
principles. For instance, in order to prove <code class="code Coq docutils literal notranslate"><span class="error"><span class="pre">∀</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,(</span></span><span class="name"><span class="pre">has_length</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">l</span></span>
<span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">))</span></span></code> it is enough to prove:</p>
<ul class="simple">
<li><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">has_length</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">nil</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">nil</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)))</span></span></code></li>
<li><code class="code Coq docutils literal notranslate"><span class="error"><span class="pre">∀</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="error"><span class="pre">∀</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">has_length</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">l</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">))</span></span> <span class="error"><span class="pre">→</span></span></code>
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">has_length</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">cons</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">cons</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">)))</span></span></code></li>
</ul>
<p>which given the conversion equalities satisfied by length is the same
as proving:</p>
<ul class="simple">
<li><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">has_length</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">nil</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span></code></li>
<li><code class="code Coq docutils literal notranslate"><span class="error"><span class="pre">∀</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="error"><span class="pre">∀</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">list</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">has_length</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">l</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">))</span></span> <span class="error"><span class="pre">→</span></span></code>
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">has_length</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">cons</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">length</span></span> <span class="name"><span class="pre">l</span></span><span class="operator"><span class="pre">)))</span></span></code></li>
</ul>
<p>One conceptually simple way to do that, following the basic scheme
proposed by Martin-Löf in his Intuitionistic Type Theory, is to
introduce for each inductive definition an elimination operator. At
the logical level it is a proof of the usual induction principle and
at the computational level it implements a generic operator for doing
primitive recursion over the structure.</p>
<p>But this operator is rather tedious to implement and use. We choose in
this version of <span class="smallcaps">Coq</span> to factorize the operator for primitive recursion
into two more primitive operations as was first suggested by Th.
Coquand in <a class="reference internal" href="../zebibliography.html#coq92" id="id25">[Coq92]</a>. One is the definition by pattern matching. The
second one is a definition by guarded fixpoints.</p>
<div class="section" id="the-match-with-end-construction">
<span id="match-construction"></span><h4>The match ... with ... end construction<a class="headerlink" href="#the-match-with-end-construction" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The basic idea of this operator is that we have an object <span class="math notranslate">\(m\)</span> in an
inductive type <span class="math notranslate">\(I\)</span> and we want to prove a property which possibly
depends on <span class="math notranslate">\(m\)</span>. For this, it is enough to prove the property for
<span class="math notranslate">\(m = (c_i~u_1 … u_{p_i} )\)</span> for each constructor of <span class="math notranslate">\(I\)</span>.
The <span class="smallcaps">Coq</span> term for this proof
will be written:</p>
<div class="math notranslate">
\[\Match~m~\with~(c_1~x_{11} ... x_{1p_1} ) ⇒ f_1 | … | (c_n~x_{n1} ... x_{np_n} ) ⇒ f_n \kwend\]</div>
<p>In this expression, if <span class="math notranslate">\(m\)</span> eventually happens to evaluate to
<span class="math notranslate">\((c_i~u_1 … u_{p_i})\)</span> then the expression will behave as specified in its <span class="math notranslate">\(i\)</span>-th branch
and it will reduce to <span class="math notranslate">\(f_i\)</span> where the <span class="math notranslate">\(x_{i1} …x_{ip_i}\)</span> are replaced by the
<span class="math notranslate">\(u_1 … u_{p_i}\)</span> according to the ι-reduction.</p>
<p>Actually, for type checking a <span class="math notranslate">\(\Match…\with…\kwend\)</span> expression we also need
to know the predicate P to be proved by case analysis. In the general
case where <span class="math notranslate">\(I\)</span> is an inductively defined <span class="math notranslate">\(n\)</span>-ary relation, <span class="math notranslate">\(P\)</span> is a predicate
over <span class="math notranslate">\(n+1\)</span> arguments: the <span class="math notranslate">\(n\)</span> first ones correspond to the arguments of <span class="math notranslate">\(I\)</span>
(parameters excluded), and the last one corresponds to object <span class="math notranslate">\(m\)</span>. <span class="smallcaps">Coq</span>
can sometimes infer this predicate but sometimes not. The concrete
syntax for describing this predicate uses the <span class="math notranslate">\(\as…\In…\return\)</span>
construction. For instance, let us assume that <span class="math notranslate">\(I\)</span> is an unary predicate
with one parameter and one argument. The predicate is made explicit
using the syntax:</p>
<div class="math notranslate">
\[\Match~m~\as~x~\In~I~\_~a~\return~P~\with~
(c_1~x_{11} ... x_{1p_1} ) ⇒ f_1 | …
| (c_n~x_{n1} ... x_{np_n} ) ⇒ f_n~\kwend\]</div>
<p>The <span class="math notranslate">\(\as\)</span> part can be omitted if either the result type does not depend
on <span class="math notranslate">\(m\)</span> (non-dependent elimination) or <span class="math notranslate">\(m\)</span> is a variable (in this case, <span class="math notranslate">\(m\)</span>
can occur in <span class="math notranslate">\(P\)</span> where it is considered a bound variable). The <span class="math notranslate">\(\In\)</span> part
can be omitted if the result type does not depend on the arguments
of <span class="math notranslate">\(I\)</span>. Note that the arguments of <span class="math notranslate">\(I\)</span> corresponding to parameters <em>must</em>
be <span class="math notranslate">\(\_\)</span>, because the result type is not generalized to all possible
values of the parameters. The other arguments of <span class="math notranslate">\(I\)</span> (sometimes called
indices in the literature) have to be variables (<span class="math notranslate">\(a\)</span> above) and these
variables can occur in <span class="math notranslate">\(P\)</span>. The expression after <span class="math notranslate">\(\In\)</span> must be seen as an
<em>inductive type pattern</em>. Notice that expansion of implicit arguments
and notations apply to this pattern. For the purpose of presenting the
inference rules, we use a more compact notation:</p>
<div class="math notranslate">
\[\case(m,(λ a x . P), λ x_{11} ... x_{1p_1} . f_1~| … |~λ x_{n1} ...x_{np_n} . f_n )\]</div>
<p id="allowed-elimination-sorts"><strong>Allowed elimination sorts.</strong> An important question for building the typing rule for match is what
can be the type of <span class="math notranslate">\(λ a x . P\)</span> with respect to the type of <span class="math notranslate">\(m\)</span>. If <span class="math notranslate">\(m:I\)</span>
and <span class="math notranslate">\(I:A\)</span> and <span class="math notranslate">\(λ a x . P : B\)</span> then by <span class="math notranslate">\([I:A|B]\)</span> we mean that one can use
<span class="math notranslate">\(λ a x . P\)</span> with <span class="math notranslate">\(m\)</span> in the above match-construct.</p>
<p id="cic-notations"><strong>Notations.</strong> The <span class="math notranslate">\([I:A|B]\)</span> is defined as the smallest relation satisfying the
following rules: We write <span class="math notranslate">\([I|B]\)</span> for <span class="math notranslate">\([I:A|B]\)</span> where <span class="math notranslate">\(A\)</span> is the type of <span class="math notranslate">\(I\)</span>.</p>
<p>The case of inductive definitions in sorts <span class="math notranslate">\(\Set\)</span> or <span class="math notranslate">\(\Type\)</span> is simple.
There is no restriction on the sort of the predicate to be eliminated.</p>
<dl class="docutils">
<dt id="inference-prod">Prod<td><div class="first last math notranslate">
\[\frac{%
[(I~x):A′|B′]%
}{%
[I:∀ x:A, A′|∀ x:A, B′]%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-set-type">Set &amp; Type<td><div class="first last math notranslate">
\[\frac{%
s_1 ∈ \{\Set,\Type(j)\}%
\hspace{3em}%
s_2 ∈ \Sort%
}{%
[I:s_1 |I→ s_2 ]%
}\]</div>
</td></dl>
<p>The case of Inductive definitions of sort <span class="math notranslate">\(\Prop\)</span> is a bit more
complicated, because of our interpretation of this sort. The only
harmless allowed elimination, is the one when predicate <span class="math notranslate">\(P\)</span> is also of
sort <span class="math notranslate">\(\Prop\)</span>.</p>
<dl class="docutils">
<dt id="inference-prop">Prop<td><div class="first last math notranslate">
\[\frac{%
~%
}{%
[I:Prop|I→Prop]%
}\]</div>
</td></dl>
<p><span class="math notranslate">\(\Prop\)</span> is the type of logical propositions, the proofs of properties <span class="math notranslate">\(P\)</span> in
<span class="math notranslate">\(\Prop\)</span> could not be used for computation and are consequently ignored by
the extraction mechanism. Assume <span class="math notranslate">\(A\)</span> and <span class="math notranslate">\(B\)</span> are two propositions, and the
logical disjunction <span class="math notranslate">\(A ∨ B\)</span> is defined inductively by:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">or</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
</span><span class="coqdoc-var">or_introl</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> | </span><span class="coqdoc-var">or_intror</span><span> : </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">or is defined
or_ind is defined</span></dd>
</dl>
</div>
</div>
<p>The following definition which computes a boolean value by case over
the proof of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">B</span></span></code> is not accepted:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">choice</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">or</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>) :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">or_introl</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">a</span><span> =&gt; </span><span class="coqdoc-var">true</span><span> | </span><span class="coqdoc-var">or_intror</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; </span><span class="coqdoc-var">false</span><span> </span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
Incorrect elimination of &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; in the inductive type &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">or</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot;:
the return type has sort &quot;</span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">&quot; while it should be &quot;Prop&quot;.
Elimination of an inductive object of sort Prop
is not allowed on a predicate in sort Set
because proofs can be eliminated only to build proofs.</span></dd>
</dl>
</div>
</div>
<p>From the computational point of view, the structure of the proof of
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">or</span></span> <span class="name"><span class="pre">A</span></span> <span class="name"><span class="pre">B</span></span><span class="operator"><span class="pre">)</span></span></code> in this term is needed for computing the boolean value.</p>
<p>In general, if <span class="math notranslate">\(I\)</span> has type <span class="math notranslate">\(\Prop\)</span> then <span class="math notranslate">\(P\)</span> cannot have type <span class="math notranslate">\(I→Set,\)</span> because
it will mean to build an informative proof of type <span class="math notranslate">\((P~m)\)</span> doing a case
analysis over a non-computational object that will disappear in the
extracted program. But the other way is safe with respect to our
interpretation we can have <span class="math notranslate">\(I\)</span> a computational object and <span class="math notranslate">\(P\)</span> a
non-computational one, it just corresponds to proving a logical property
of a computational object.</p>
<p>In the same spirit, elimination on <span class="math notranslate">\(P\)</span> of type <span class="math notranslate">\(I→Type\)</span> cannot be allowed
because it trivially implies the elimination on <span class="math notranslate">\(P\)</span> of type <span class="math notranslate">\(I→ Set\)</span> by
cumulativity. It also implies that there are two proofs of the same
property which are provably different, contradicting the proof-
irrelevance property which is sometimes a useful axiom:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">proof_irrelevance</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">P</span><span>), </span><span class="coqdoc-var">x</span><span>=</span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first last">proof_irrelevance is declared</span></dd>
</dl>
</div>
</div>
<p>The elimination of an inductive definition of type <span class="math notranslate">\(\Prop\)</span> on a predicate
<span class="math notranslate">\(P\)</span> of type <span class="math notranslate">\(I→ Type\)</span> leads to a paradox when applied to impredicative
inductive definition like the second-order existential quantifier
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exProp</span></span></code> defined above, because it gives access to the two projections on
this type.</p>
<p id="empty-and-singleton-elimination"><strong>Empty and singleton elimination.</strong> There are special inductive definitions in
<span class="math notranslate">\(\Prop\)</span> for which more eliminations are allowed.</p>
<dl class="docutils">
<dt id="inference-prop-extended">Prop-extended<td><div class="first last math notranslate">
\[\frac{%
I~\kw{is an empty or singleton definition}%
\hspace{3em}%
s ∈ \Sort%
}{%
[I:Prop|I→ s]%
}\]</div>
</td></dl>
<p>A <em>singleton definition</em> has only one constructor and all the
arguments of this constructor have type <span class="math notranslate">\(\Prop\)</span>. In that case, there is a
canonical way to interpret the informative extraction on an object in
that type, such that the elimination on any sort <span class="math notranslate">\(s\)</span> is legal. Typical
examples are the conjunction of non-informative propositions and the
equality. If there is a hypothesis <span class="math notranslate">\(h:a=b\)</span> in the local context, it can
be used for rewriting not only in logical propositions but also in any
type.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">eq_rec</span><span>.</span></dt>
<dd><span class="first">eq_rec = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (P : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_rect</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (P : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
       </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">

Argument A is implicit
Argument scopes are [type_scope _ function_scope _ _ _]</span></dd>
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Extraction</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file extraction_plugin.cmxs ... done]</span></dd>
<dt><span class="coqdoc-keyword">Extraction</span><span> </span><span class="coqdoc-var">eq_rec</span><span>.</span></dt>
<dd><span class="first last">(** val eq_rec : 'a1 -&gt; 'a2 -&gt; 'a1 -&gt; 'a2 **)

let eq_rec _ f _ =
  f</span></dd>
</dl>
</div>
</div>
<p>An empty definition has no constructors, in that case also,
elimination on any sort is allowed.</p>
<p id="type-of-branches"><strong>Type of branches.</strong>
Let <span class="math notranslate">\(c\)</span> be a term of type <span class="math notranslate">\(C\)</span>, we assume <span class="math notranslate">\(C\)</span> is a type of constructor for an
inductive type <span class="math notranslate">\(I\)</span>. Let <span class="math notranslate">\(P\)</span> be a term that represents the property to be
proved. We assume <span class="math notranslate">\(r\)</span> is the number of parameters and <span class="math notranslate">\(p\)</span> is the number of
arguments.</p>
<p>We define a new type <span class="math notranslate">\(\{c:C\}^P\)</span> which represents the type of the branch
corresponding to the <span class="math notranslate">\(c:C\)</span> constructor.</p>
<div class="math notranslate">
\[\begin{split}\begin{array}{ll}
\{c:(I~p_1\ldots p_r\ t_1 \ldots t_p)\}^P &amp;\equiv (P~t_1\ldots ~t_p~c) \\
\{c:\forall~x:T,C\}^P &amp;\equiv \forall~x:T,\{(c~x):C\}^P
\end{array}\end{split}\]</div>
<p>We write <span class="math notranslate">\(\{c\}^P\)</span> for <span class="math notranslate">\(\{c:C\}^P\)</span> with <span class="math notranslate">\(C\)</span> the type of <span class="math notranslate">\(c\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>The following term in concrete syntax:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>match t as l return P&#39; with
| nil _ =&gt; t1
| cons _ hd tl =&gt; t2
end
</pre></div>
</div>
<p>can be represented in abstract syntax as</p>
<div class="math notranslate">
\[\case(t,P,f 1 | f 2 )\]</div>
<p>where</p>
<div class="math notranslate">
\begin{eqnarray*}
  P &amp; = &amp; \lambda~l~.~P^\prime\\
  f_1 &amp; = &amp; t_1\\
  f_2 &amp; = &amp; \lambda~(hd:\nat)~.~\lambda~(tl:\List~\nat)~.~t_2
\end{eqnarray*}</div><p>According to the definition:</p>
<div class="math notranslate">
\[\{(\kw{nil}~\nat)\}^P ≡ \{(\kw{nil}~\nat) : (\List~\nat)\}^P ≡ (P~(\kw{nil}~\nat))\]</div>
<div class="math notranslate">
\[\begin{split}\begin{array}{rl}
\{(\kw{cons}~\nat)\}^P &amp; ≡\{(\kw{cons}~\nat) : (\nat→\List~\nat→\List~\nat)\}^P \\
&amp; ≡∀ n:\nat, \{(\kw{cons}~\nat~n) : \List~\nat→\List~\nat)\}^P \\
&amp; ≡∀ n:\nat, ∀ l:\List~\nat, \{(\kw{cons}~\nat~n~l) : \List~\nat)\}^P \\
&amp; ≡∀ n:\nat, ∀ l:\List~\nat,(P~(\kw{cons}~\nat~n~l)).
\end{array}\end{split}\]</div>
<p class="last">Given some <span class="math notranslate">\(P\)</span> then <span class="math notranslate">\(\{(\kw{nil}~\nat)\}^P\)</span> represents the expected type of <span class="math notranslate">\(f_1\)</span> ,
and <span class="math notranslate">\(\{(\kw{cons}~\nat)\}^P\)</span> represents the expected type of <span class="math notranslate">\(f_2\)</span>.</p>
</div>
<p id="typing-rule"><strong>Typing rule.</strong>
Our very general destructor for inductive definition enjoys the
following typing rule</p>
<dl class="docutils">
<dt id="inference-match">match<td><div class="first last math notranslate">
\[\begin{split}\frac{%
\begin{array}{l}%
\hspace{3em}%
E[Γ] ⊢ c : (I~q_1 … q_r~t_1 … t_s ) \\%
\hspace{3em}%
E[Γ] ⊢ P : B \\%
\hspace{3em}%
[(I~q_1 … q_r)|B] \\%
\hspace{3em}%
(E[Γ] ⊢ f_i : \{(c_{p_i}~q_1 … q_r)\}^P)_{i=1… l}%
\hspace{3em}%
\end{array}%
}{%
E[Γ] ⊢ \case(c,P,f_1  |… |f_l ) : (P~t_1 … t_s~c)%
}\end{split}\]</div>
</td></dl>
<p>provided <span class="math notranslate">\(I\)</span> is an inductive type in a
definition <span class="math notranslate">\(\ind{r}{Γ_I}{Γ_C}\)</span> with <span class="math notranslate">\(Γ_C = [c_1 :C_1 ;…;c_n :C_n ]\)</span> and
<span class="math notranslate">\(c_{p_1} … c_{p_l}\)</span> are the only constructors of <span class="math notranslate">\(I\)</span>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Below is a typing rule for the term shown in the previous example:</p>
<dl class="last docutils">
<dt id="inference-list-example">list example<td><div class="first last math notranslate">
\[\begin{split}\frac{%
\begin{array}{l}%
\hspace{3em}%
  E[Γ] ⊢ t : (\List ~\nat) \\%
\hspace{3em}%
  E[Γ] ⊢ P : B \\%
\hspace{3em}%
  [(\List ~\nat)|B] \\%
\hspace{3em}%
  E[Γ] ⊢ f_1 : {(\kw{nil} ~\nat)}^P \\%
\hspace{3em}%
  E[Γ] ⊢ f_2 : {(\kw{cons} ~\nat)}^P%
\hspace{3em}%
\end{array}%
}{%
E[Γ] ⊢ \case(t,P,f_1 |f_2 ) : (P~t)%
}\end{split}\]</div>
</td></dl>
</div>
<p id="definition-of-reduction"><strong>Definition of ι-reduction.</strong>
We still have to define the ι-reduction in the general case.</p>
<p>An ι-redex is a term of the following form:</p>
<div class="math notranslate">
\[\case((c_{p_i}~q_1 … q_r~a_1 … a_m ),P,f_1 |… |f_l )\]</div>
<p>with <span class="math notranslate">\(c_{p_i}\)</span> the <span class="math notranslate">\(i\)</span>-th constructor of the inductive type <span class="math notranslate">\(I\)</span> with <span class="math notranslate">\(r\)</span>
parameters.</p>
<p>The ι-contraction of this term is <span class="math notranslate">\((f_i~a_1 … a_m )\)</span> leading to the
general reduction rule:</p>
<div class="math notranslate">
\[\case((c_{p_i}~q_1 … q_r~a_1 … a_m ),P,f_1 |… |f_n ) \triangleright_ι (f_i~a_1 … a_m )\]</div>
</div>
</div>
<div class="section" id="fixpoint-definitions">
<span id="id26"></span><h3>Fixpoint definitions<a class="headerlink" href="#fixpoint-definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The second operator for elimination is fixpoint definition. This
fixpoint may involve several mutually recursive definitions. The basic
concrete syntax for a recursive set of mutually recursive declarations
is (with <span class="math notranslate">\(Γ_i\)</span> contexts):</p>
<div class="math notranslate">
\[\fix~f_1 (Γ_1 ) :A_1 :=t_1 \with … \with~f_n (Γ_n ) :A_n :=t_n\]</div>
<p>The terms are obtained by projections from this set of declarations
and are written</p>
<div class="math notranslate">
\[\fix~f_1 (Γ_1 ) :A_1 :=t_1 \with … \with~f_n (Γ_n ) :A_n :=t_n \for~f_i\]</div>
<p>In the inference rules, we represent such a term by</p>
<div class="math notranslate">
\[\Fix~f_i\{f_1 :A_1':=t_1' … f_n :A_n':=t_n'\}\]</div>
<p>with <span class="math notranslate">\(t_i'\)</span> (resp. <span class="math notranslate">\(A_i'\)</span>) representing the term <span class="math notranslate">\(t_i\)</span> abstracted (resp.
generalized) with respect to the bindings in the context Γ_i , namely
<span class="math notranslate">\(t_i'=λ Γ_i . t_i\)</span> and <span class="math notranslate">\(A_i'=∀ Γ_i , A_i\)</span>.</p>
<div class="section" id="id27">
<h4>Typing rule<a class="headerlink" href="#id27" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The typing rule is the expected one for a fixpoint.</p>
<dl class="docutils">
<dt id="inference-fix">Fix<td><div class="first last math notranslate">
\[\frac{%
(E[Γ] ⊢ A_i : s_i )_{i=1… n}%
\hspace{3em}%
(E[Γ,f_1 :A_1 ,…,f_n :A_n ] ⊢ t_i : A_i )_{i=1… n}%
}{%
E[Γ] ⊢ \Fix~f_i\{f_1 :A_1 :=t_1 … f_n :A_n :=t_n \} : A_i%
}\]</div>
</td></dl>
<p>Any fixpoint definition cannot be accepted because non-normalizing
terms allow proofs of absurdity. The basic scheme of recursion that
should be allowed is the one needed for defining primitive recursive
functionals. In that case the fixpoint enjoys a special syntactic
restriction, namely one of the arguments belongs to an inductive type,
the function starts with a case analysis and recursive calls are done
on variables coming from patterns and representing subterms. For
instance in the case of natural numbers, a proof of the induction
principle of type</p>
<div class="math notranslate">
\[∀ P:\nat→\Prop, (P~O)→(∀ n:\nat, (P~n)→(P~(\kw{S}~n)))→ ∀ n:\nat, (P~n)\]</div>
<p>can be represented by the term:</p>
<div class="math notranslate">
\[\begin{split}\begin{array}{l}
λ P:\nat→\Prop. λ f:(P~O). λ g:(∀ n:\nat, (P~n)→(P~(S~n))).\\
\Fix~h\{h:∀ n:\nat, (P~n):=λ n:\nat. \case(n,P,f | λp:\nat. (g~p~(h~p)))\}
\end{array}\end{split}\]</div>
<p>Before accepting a fixpoint definition as being correctly typed, we
check that the definition is “guarded”. A precise analysis of this
notion can be found in <a class="reference internal" href="../zebibliography.html#gim94" id="id28">[Gimenez94]</a>. The first stage is to precise on which
argument the fixpoint will be decreasing. The type of this argument
should be an inductive definition. For doing this, the syntax of
fixpoints is extended and becomes</p>
<div class="math notranslate">
\[\Fix~f_i\{f_1/k_1 :A_1':=t_1' … f_n/k_n :A_n':=t_n'\}\]</div>
<p>where <span class="math notranslate">\(k_i\)</span> are positive integers. Each <span class="math notranslate">\(k_i\)</span> represents the index of
parameter of <span class="math notranslate">\(f_i\)</span> , on which <span class="math notranslate">\(f_i\)</span> is decreasing. Each <span class="math notranslate">\(A_i\)</span> should be a
type (reducible to a term) starting with at least <span class="math notranslate">\(k_i\)</span> products
<span class="math notranslate">\(∀ y_1 :B_1 ,… ∀ y_{k_i} :B_{k_i} , A_i'\)</span> and <span class="math notranslate">\(B_{k_i}\)</span> an inductive type.</p>
<p>Now in the definition <span class="math notranslate">\(t_i\)</span>, if <span class="math notranslate">\(f_j\)</span> occurs then it should be applied to
at least <span class="math notranslate">\(k_j\)</span> arguments and the <span class="math notranslate">\(k_j\)</span>-th argument should be
syntactically recognized as structurally smaller than <span class="math notranslate">\(y_{k_i}\)</span>.</p>
<p>The definition of being structurally smaller is a bit technical. One
needs first to define the notion of <em>recursive arguments of a
constructor</em>. For an inductive definition <span class="math notranslate">\(\ind{r}{Γ_I}{Γ_C}\)</span>, if the
type of a constructor <span class="math notranslate">\(c\)</span> has the form
<span class="math notranslate">\(∀ p_1 :P_1 ,… ∀ p_r :P_r, ∀ x_1:T_1, … ∀ x_r :T_r, (I_j~p_1 … p_r~t_1 … t_s )\)</span>,
then the recursive
arguments will correspond to <span class="math notranslate">\(T_i\)</span> in which one of the <span class="math notranslate">\(I_l\)</span> occurs.</p>
<p>The main rules for being structurally smaller are the following.
Given a variable <span class="math notranslate">\(y\)</span> of an inductively defined type in a declaration
<span class="math notranslate">\(\ind{r}{Γ_I}{Γ_C}\)</span> where <span class="math notranslate">\(Γ_I\)</span> is <span class="math notranslate">\([I_1 :A_1 ;…;I_k :A_k]\)</span>, and <span class="math notranslate">\(Γ_C\)</span> is
<span class="math notranslate">\([c_1 :C_1 ;…;c_n :C_n ]\)</span>, the terms structurally smaller than <span class="math notranslate">\(y\)</span> are:</p>
<ul class="simple">
<li><span class="math notranslate">\((t~u)\)</span> and <span class="math notranslate">\(λ x:u . t\)</span> when <span class="math notranslate">\(t\)</span> is structurally smaller than <span class="math notranslate">\(y\)</span>.</li>
<li><span class="math notranslate">\(\case(c,P,f_1 … f_n)\)</span> when each <span class="math notranslate">\(f_i\)</span> is structurally smaller than <span class="math notranslate">\(y\)</span>.
If <span class="math notranslate">\(c\)</span> is <span class="math notranslate">\(y\)</span> or is structurally smaller than <span class="math notranslate">\(y\)</span>, its type is an inductive
definition <span class="math notranslate">\(I_p\)</span> part of the inductive declaration corresponding to <span class="math notranslate">\(y\)</span>.
Each <span class="math notranslate">\(f_i\)</span> corresponds to a type of constructor
<span class="math notranslate">\(C_q ≡ ∀ p_1 :P_1 ,…,∀ p_r :P_r , ∀ y_1 :B_1 , … ∀ y_k :B_k , (I~a_1 … a_k )\)</span>
and can consequently be written <span class="math notranslate">\(λ y_1 :B_1' . … λ y_k :B_k'. g_i\)</span>. (<span class="math notranslate">\(B_i'\)</span> is
obtained from <span class="math notranslate">\(B_i\)</span> by substituting parameters for variables) the variables
<span class="math notranslate">\(y_j\)</span> occurring in <span class="math notranslate">\(g_i\)</span> corresponding to recursive arguments <span class="math notranslate">\(B_i\)</span> (the
ones in which one of the <span class="math notranslate">\(I_l\)</span> occurs) are structurally smaller than y.</li>
</ul>
<p>The following definitions are correct, we enter them using the <a class="reference internal" href="gallina-specification-language.html#coq:cmd.fixpoint" title="Fixpoint"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Fixpoint</span></code></a>
command and show the internal representation.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">O</span><span> =&gt; </span><span class="coqdoc-var">m</span><span>
| </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">m</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">plus is defined
plus is recursively defined (decreasing on 1st argument)</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">plus</span><span>.</span></dt>
<dd><span class="first">plus = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> plus (n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) {</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">struct</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n} : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> :=
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  | 0 =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">

Argument scopes are [nat_scope nat_scope]</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">lgth</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Set</span><span>) (</span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">l</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">l'</span><span> =&gt; </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">lgth</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">l'</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">lgth is defined
lgth is recursively defined (decreasing on 2nd argument)</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">lgth</span><span>.</span></dt>
<dd><span class="first">lgth = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> lgth (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) {</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">struct</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l} : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> :=
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ =&gt; 0
  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ _ </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">lgth</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">

Argument scopes are [type_scope _]</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">sizet</span><span> (</span><span class="coqdoc-var">t</span><span>:</span><span class="coqdoc-var">tree</span><span>) : </span><span class="coqdoc-var">nat</span><span> := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">f</span><span>) := </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">sizef</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">sizef</span><span> (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">forest</span><span>) : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-keyword">with</span><span>
| </span><span class="coqdoc-var">emptyf</span><span> =&gt; </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">consf</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">f</span><span> =&gt; </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">sizet</span><span> </span><span class="coqdoc-var">t</span><span>) (</span><span class="coqdoc-var">sizef</span><span> </span><span class="coqdoc-var">f</span><span>)</span><span>
</span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">sizet is defined
sizef is defined
sizet, sizef are recursively defined (decreasing respectively on 1st,
1st arguments)</span></dd>
<dt><span class="coqdoc-keyword">Print</span><span> </span><span class="coqdoc-var">sizet</span><span>.</span></dt>
<dd><span class="first">sizet = 
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fix</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> sizet (t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> := </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">let</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (f) := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative"> in</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sizef</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> sizef (f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">forest</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> :=
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">emptyf</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; 0
  | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">consf</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sizet</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sizef</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">for</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> sizet
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tree</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="reduction-rule">
<span id="id29"></span><h4>Reduction rule<a class="headerlink" href="#reduction-rule" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Let <span class="math notranslate">\(F\)</span> be the set of declarations:
<span class="math notranslate">\(f_1 /k_1 :A_1 :=t_1 …f_n /k_n :A_n:=t_n\)</span>.
The reduction for fixpoints is:</p>
<div class="math notranslate">
\[(\Fix~f_i \{F\} a_1 …a_{k_i}) \triangleright_ι \subst{t_i}{f_k}{\Fix~f_k \{F\}}_{k=1… n} ~a_1 … a_{k_i}\]</div>
<p>when <span class="math notranslate">\(a_{k_i}\)</span> starts with a constructor. This last restriction is needed
in order to keep strong normalization and corresponds to the reduction
for primitive recursive operators. The following reductions are now
possible:</p>
<div class="math notranslate">
{\def\plus{\mathsf{plus}}
 \def\tri{\triangleright_\iota}
 \begin{eqnarray*}
 \plus~(\nS~(\nS~\nO))~(\nS~\nO) &amp; \tri &amp; \nS~(\plus~(\nS~\nO)~(\nS~\nO))\\
                                &amp; \tri &amp; \nS~(\nS~(\plus~\nO~(\nS~\nO)))\\
                                &amp; \tri &amp; \nS~(\nS~(\nS~\nO))\\
 \end{eqnarray*}}</div><p id="mutual-induction"><strong>Mutual induction</strong></p>
<p>The principles of mutual induction can be automatically generated
using the Scheme command described in Section <a class="reference internal" href="../user-extensions/proof-schemes.html#proofschemes-induction-principles"><span class="std std-ref">Generation of induction principles with Scheme</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="admissible-rules-for-global-environments">
<span id="id30"></span><h2>Admissible rules for global environments<a class="headerlink" href="#admissible-rules-for-global-environments" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>From the original rules of the type system, one can show the
admissibility of rules which change the local context of definition of
objects in the global environment. We show here the admissible rules
that are used in the discharge mechanism at the end of a section.</p>
<p id="abstraction"><strong>Abstraction.</strong>
One can modify a global declaration by generalizing it over a
previously assumed constant <span class="math notranslate">\(c\)</span>. For doing that, we need to modify the
reference to the global declaration in the subsequent global
environment and local context by explicitly applying this constant to
the constant <span class="math notranslate">\(c'\)</span>.</p>
<p>Below, if <span class="math notranslate">\(Γ\)</span> is a context of the form <span class="math notranslate">\([y_1 :A_1 ;…;y_n :A_n]\)</span>, we write
<span class="math notranslate">\(∀x:U,\subst{Γ}{c}{x}\)</span> to mean
<span class="math notranslate">\([y_1 :∀ x:U,\subst{A_1}{c}{x};…;y_n :∀ x:U,\subst{A_n}{c}{x}]\)</span>
and <span class="math notranslate">\(\subst{E}{|Γ|}{|Γ|c}\)</span> to mean the parallel substitution
<span class="math notranslate">\(E\{y_1 /(y_1~c)\}…\{y_n/(y_n~c)\}\)</span>.</p>
<p id="first-abstracting-property"><strong>First abstracting property:</strong></p>
<div class="math notranslate">
\[\frac{\WF{E;c:U;E′;c′:=t:T;E″}{Γ}}
     {\WF{E;c:U;E′;c′:=λ x:U. \subst{t}{c}{x}:∀x:U,\subst{T}{c}{x};\subst{E″}{c′}{(c′~c)}}
     {\subst{Γ}{c}{(c~c′)}}}\]</div>
<div class="math notranslate">
\[\frac{\WF{E;c:U;E′;c′:T;E″}{Γ}}
     {\WF{E;c:U;E′;c′:∀ x:U,\subst{T}{c}{x};\subst{E″}{c′}{(c′~c)}}{Γ{c/(c~c′)}}}\]</div>
<div class="math notranslate">
\[\frac{\WF{E;c:U;E′;\ind{p}{Γ_I}{Γ_C};E″}{Γ}}
     {\WFTWOLINES{E;c:U;E′;\ind{p+1}{∀ x:U,\subst{Γ_I}{c}{x}}{∀ x:U,\subst{Γ_C}{c}{x}};
       \subst{E″}{|Γ_I ,Γ_C |}{|Γ_I ,Γ_C | c}}
      {\subst{Γ}{|Γ_I ,Γ_C|}{|Γ_I ,Γ_C | c}}}\]</div>
<p>One can similarly modify a global declaration by generalizing it over
a previously defined constant <span class="math notranslate">\(c′\)</span>. Below, if <span class="math notranslate">\(Γ\)</span> is a context of the form
<span class="math notranslate">\([y_1 :A_1 ;…;y_n :A_n]\)</span>, we write <span class="math notranslate">\(\subst{Γ}{c}{u}\)</span> to mean
<span class="math notranslate">\([y_1 :\subst{A_1} {c}{u};…;y_n:\subst{A_n} {c}{u}]\)</span>.</p>
<p id="second-abstracting-property"><strong>Second abstracting property:</strong></p>
<div class="math notranslate">
\[\frac{\WF{E;c:=u:U;E′;c′:=t:T;E″}{Γ}}
     {\WF{E;c:=u:U;E′;c′:=(\letin{x}{u:U}{\subst{t}{c}{x}}):\subst{T}{c}{u};E″}{Γ}}\]</div>
<div class="math notranslate">
\[\frac{\WF{E;c:=u:U;E′;c′:T;E″}{Γ}}
     {\WF{E;c:=u:U;E′;c′:\subst{T}{c}{u};E″}{Γ}}\]</div>
<div class="math notranslate">
\[\frac{\WF{E;c:=u:U;E′;\ind{p}{Γ_I}{Γ_C};E″}{Γ}}
     {\WF{E;c:=u:U;E′;\ind{p}{\subst{Γ_I}{c}{u}}{\subst{Γ_C}{c}{u}};E″}{Γ}}\]</div>
<p id="pruning-the-local-context"><strong>Pruning the local context.</strong>
If one abstracts or substitutes constants with the above rules then it
may happen that some declared or defined constant does not occur any
more in the subsequent global environment and in the local context.
One can consequently derive the following property.</p>
<dl class="docutils" id="first-pruning-property">
<dt id="inference-first-pruning-property">First pruning property:<td><div class="first last math notranslate">
\[\frac{%
\WF{E;c:U;E′}{Γ}%
\hspace{3em}%
c~\kw{does not occur in}~E′~\kw{and}~Γ%
}{%
\WF{E;E′}{Γ}%
}\]</div>
</td></dl>
<dl class="docutils" id="second-pruning-property">
<dt id="inference-second-pruning-property">Second pruning property:<td><div class="first last math notranslate">
\[\frac{%
\WF{E;c:=u:U;E′}{Γ}%
\hspace{3em}%
c~\kw{does not occur in}~E′~\kw{and}~Γ%
}{%
\WF{E;E′}{Γ}%
}\]</div>
</td></dl>
</div>
<div class="section" id="co-inductive-types">
<span id="id31"></span><h2>Co-inductive types<a class="headerlink" href="#co-inductive-types" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The implementation contains also co-inductive definitions, which are
types inhabited by infinite objects. More information on co-inductive
definitions can be found in <a class="reference internal" href="../zebibliography.html#gimenez95b" id="id32">[Gimenez95]</a><a class="reference internal" href="../zebibliography.html#gim98" id="id33">[Gimenez98]</a><a class="reference internal" href="../zebibliography.html#gimcas05" id="id34">[GimenezCasteran05]</a>.</p>
</div>
<div class="section" id="the-calculus-of-inductive-constructions-with-impredicative-set">
<span id="the-calculus-of-inductive-construction-with-impredicative-set"></span><h2>The Calculus of Inductive Constructions with impredicative Set<a class="headerlink" href="#the-calculus-of-inductive-constructions-with-impredicative-set" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><span class="smallcaps">Coq</span> can be used as a type checker for the Calculus of Inductive
Constructions with an impredicative sort <span class="math notranslate">\(\Set\)</span> by using the compiler
option <code class="docutils literal notranslate"><span class="pre">-impredicative-set</span></code>. For example, using the ordinary <cite>coqtop</cite>
command, the following is rejected,</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">id</span><span>: </span><span class="coqdoc-keyword">Set</span><span> := </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">X</span><span>:</span><span class="coqdoc-keyword">Set</span><span>,</span><span class="coqdoc-var">X</span><span>-&gt;</span><span class="coqdoc-var">X</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
The term &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> X : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">X</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; has type &quot;</span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot;
while it is expected to have type &quot;</span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">&quot; (universe inconsistency).</span></dd>
</dl>
</div>
</div>
<p>while it will type check, if one uses instead the <cite>coqtop</cite>
<code class="docutils literal notranslate"><span class="pre">-impredicative-set</span></code> option..</p>
<p>The major change in the theory concerns the rule for product formation
in the sort <span class="math notranslate">\(\Set\)</span>, which is extended to a domain in any sort:</p>
<dl class="docutils">
<dt id="inference-prodimp">ProdImp<td><div class="first last math notranslate">
\[\frac{%
E[Γ] ⊢ T : s%
\hspace{3em}%
s ∈ {\Sort}%
\hspace{3em}%
E[Γ::(x:T)] ⊢ U : Set%
}{%
E[Γ] ⊢ ∀ x:T,U : Set%
}\]</div>
</td></dl>
<p>This extension has consequences on the inductive definitions which are
allowed. In the impredicative system, one can build so-called <em>large
inductive definitions</em> like the example of second-order existential
quantifier (<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">exSet</span></span></code>).</p>
<p>There should be restrictions on the eliminations which can be
performed on such definitions. The elimination rules in the
impredicative system for sort <span class="math notranslate">\(\Set\)</span> become:</p>
<dl class="docutils">
<dt id="inference-set1">Set1<td><div class="first last math notranslate">
\[\frac{%
s ∈ \{Prop, Set\}%
}{%
[I:Set|I→ s]%
}\]</div>
</td></dl>
<dl class="docutils">
<dt id="inference-set2">Set2<td><div class="first last math notranslate">
\[\frac{%
I~\kw{is a small inductive definition}%
\hspace{3em}%
s ∈ \{\Type(i)\}%
}{%
[I:Set|I→ s]%
}\]</div>
</td></dl>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="module-system.html" class="btn btn-neutral float-right" title="The Module System" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="coq-library.html" class="btn btn-neutral" title="The Coq library" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>