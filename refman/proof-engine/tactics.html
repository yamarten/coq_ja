

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Tactics &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="The tactic language" href="ltac.html" />
    <link rel="prev" title="Proof handling" href="proof-handling.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof-handling.html">Proof handling</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tactics</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#invocation-of-tactics">Invocation of tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bindings-list">Bindings list</a></li>
<li class="toctree-l3"><a class="reference internal" href="#occurrence-sets-and-occurrence-clauses">Occurrence sets and occurrence clauses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#applying-theorems">Applying theorems</a></li>
<li class="toctree-l2"><a class="reference internal" href="#managing-the-local-context">Managing the local context</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-the-proof-flow">Controlling the proof flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#case-analysis-and-induction">Case analysis and induction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rewriting-expressions">Rewriting expressions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#performing-computations">Performing computations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#conversion-tactics-applied-to-hypotheses">Conversion tactics applied to hypotheses</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#automation">Automation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#controlling-automation">Controlling automation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-hints-databases-for-auto-and-eauto">The hints databases for auto and eauto</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-hint-databases">Creating Hint databases</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hint-databases-defined-in-the-coq-standard-library">Hint databases defined in the Coq standard library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hint-locality">Hint locality</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-implicit-automation-tactics">Setting implicit automation tactics</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#decision-procedures">Decision procedures</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checking-properties-of-terms">Checking properties of terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#equality">Equality</a></li>
<li class="toctree-l2"><a class="reference internal" href="#equality-and-inductive-sets">Equality and inductive sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inversion">Inversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="#classical-tactics">Classical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#automating">Automating</a></li>
<li class="toctree-l2"><a class="reference internal" href="#non-logical-tactics">Non-logical tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="#simple-tactic-macros">Simple tactic macros</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ssreflect-proof-language.html">The <span class="smallcaps">SSReflect</span> proof language</a></li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Tactics</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/tactics.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="tactics">
<span id="id1"></span><h1>Tactics<a class="headerlink" href="#tactics" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>A deduction rule is a link between some (unique) formula, that we call
the <em>conclusion</em> and (several) formulas that we call the <em>premises</em>. A
deduction rule can be read in two ways. The first one says: “if I know
this and this then I can deduce this”. For instance, if I have a proof
of A and a proof of B then I have a proof of A ∧ B. This is forward
reasoning from premises to conclusion. The other way says: “to prove
this I have to prove this and this”. For instance, to prove A ∧ B, I
have to prove A and I have to prove B. This is backward reasoning from
conclusion to premises. We say that the conclusion is the <em>goal</em> to
prove and premises are the <em>subgoals</em>. The tactics implement <em>backward
reasoning</em>. When applied to a goal, a tactic replaces this goal with
the subgoals it generates. We say that a tactic reduces a goal to its
subgoal(s).</p>
<p>Each (sub)goal is denoted with a number. The current goal is numbered
1. By default, a tactic is applied to the current goal, but one can
address a particular goal in the list by writing n:tactic which means
“apply tactic tactic to goal number n”. We can show the list of
subgoals by typing Show (see Section <a class="reference internal" href="proof-handling.html#requestinginformation"><span class="std std-ref">Requesting information</span></a>).</p>
<p>Since not every rule applies to a given statement, not every tactic can
be used to reduce a given goal. In other words, before applying a tactic
to a given goal, the system checks that some <em>preconditions</em> are
satisfied. If it is not the case, the tactic raises an error message.</p>
<p>Tactics are built from atomic tactics and tactic expressions (which
extends the folklore notion of tactical) to combine those atomic
tactics. This chapter is devoted to atomic tactics. The tactic
language will be described in Chapter <a class="reference internal" href="ltac.html#ltac"><span class="std std-ref">The tactic language</span></a>.</p>
<div class="section" id="invocation-of-tactics">
<span id="id2"></span><h2>Invocation of tactics<a class="headerlink" href="#invocation-of-tactics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A tactic is applied as an ordinary command. It may be preceded by a
goal selector (see Section <a class="reference internal" href="ltac.html#ltac-semantics"><span class="std std-ref">Semantics</span></a>). If no selector is
specified, the default selector is used.</p>
<blockquote id="tactic-invocation-grammar">
<div><pre>
<strong id="grammar-token-tactic_invocation">tactic_invocation</strong> ::=  toplevel_selector : tactic.
                       |tactic .
</pre>
</div></blockquote>
<dl class="opt">
<dt id="coq:opt.default-goal-selector">
<em class="property"><span class="sigannot">Option</span></em> <code class="descname"><span class="notation"><span>Default</span> <span>Goal</span> <span>Selector</span> <span>&quot;</span><a class="reference internal" href="ltac.html#grammar-token-toplevel_selector"><span class="hole">toplevel_selector</span></a><span>&quot;</span></span></code><a class="headerlink" href="#coq:opt.default-goal-selector" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option controls the default selector – used when no selector is
specified when applying a tactic – is set to the chosen value. The initial
value is 1, hence the tactics are, by default, applied to the first goal.
Using value <code class="docutils literal notranslate"><span class="pre">all</span></code> will make is so that tactics are, by default, applied to
every goal simultaneously. Then, to apply a tactic tac to the first goal
only, you can write <code class="docutils literal notranslate"><span class="pre">1:tac</span></code>. Although more selectors are available, only
<code class="docutils literal notranslate"><span class="pre">all</span></code> or a single natural number are valid default goal selectors.</p>
</dd></dl>

<div class="section" id="bindings-list">
<span id="bindingslist"></span><h3>Bindings list<a class="headerlink" href="#bindings-list" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Tactics that take a term as argument may also support a bindings list,
so as to instantiate some parameters of the term by name or position.
The general form of a term equipped with a bindings list is <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">with</span>
<span class="pre">bindings_list</span></code> where <code class="docutils literal notranslate"><span class="pre">bindings_list</span></code> may be of two different forms:</p>
<blockquote id="bindings-list-grammar">
<div><pre>
<strong id="grammar-token-bindings_list">bindings_list</strong> ::=  (ref := <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>) ... (ref := <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>)
                   <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> ... <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a>
</pre>
</div></blockquote>
<ul>
<li><p class="first">In a bindings list of the form <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">(ref:=</span></span> <span><span class="pre">term)</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ref</span></span></span></code> is either an
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> or a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>. The references are determined according to the type of
<code class="docutils literal notranslate"><span class="pre">term</span></code>. If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ref</span></span></span></code> is an identifier, this identifier has to be bound in the
type of <code class="docutils literal notranslate"><span class="pre">term</span></code> and the binding provides the tactic with an instance for the
parameter of this name. If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ref</span></span></span></code> is some number <code class="docutils literal notranslate"><span class="pre">n</span></code>, this number denotes
the <code class="docutils literal notranslate"><span class="pre">n</span></code>-th non dependent premise of the <code class="docutils literal notranslate"><span class="pre">term</span></code>, as determined by the type
of <code class="docutils literal notranslate"><span class="pre">term</span></code>.</p>
<dl class="exn">
<dt id="coq:exn.no-such-binder">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>binder.</span></span></code><a class="headerlink" href="#coq:exn.no-such-binder" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</li>
<li><p class="first">A bindings list can also be a simple list of terms <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>.
In that case the references to which these terms correspond are
determined by the tactic. In case of <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, <a class="reference internal" href="#coq:tacv.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a>
and <a class="reference internal" href="#coq:tacn.case" title="case"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">case</span></code></a>, the terms have to
provide instances for all the dependent products in the type of term while in
the case of <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>, or of <a class="reference internal" href="#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a> and its variants, only instances
for the dependent products that are not bound in the conclusion of the type
are required.</p>
<dl class="exn">
<dt id="coq:exn.not-the-right-number-of-missing-arguments">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>the</span> <span>right</span> <span>number</span> <span>of</span> <span>missing</span> <span>arguments.</span></span></code><a class="headerlink" href="#coq:exn.not-the-right-number-of-missing-arguments" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</li>
</ul>
</div>
<div class="section" id="occurrence-sets-and-occurrence-clauses">
<span id="occurencessets"></span><h3>Occurrence sets and occurrence clauses<a class="headerlink" href="#occurrence-sets-and-occurrence-clauses" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>An occurrence clause is a modifier to some tactics that obeys the
following syntax:</p>
<blockquote>
<div><pre>
<strong id="grammar-token-occurrence_clause">occurrence_clause</strong> ::=  in <a class="reference internal" href="#grammar-token-goal_occurrences"><code class="xref docutils literal notranslate"><span class="pre">goal_occurrences</span></code></a>
<strong id="grammar-token-goal_occurrences">goal_occurrences </strong> ::=  [<a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref docutils literal notranslate"><span class="pre">ident</span></code></a> [<a class="reference internal" href="#grammar-token-at_occurrences"><code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code></a>], ... , ident [<a class="reference internal" href="#grammar-token-at_occurrences"><code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code></a>] [|- [* [<a class="reference internal" href="#grammar-token-at_occurrences"><code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code></a>]]]]
                      | * |- [* [<a class="reference internal" href="#grammar-token-at_occurrences"><code class="xref docutils literal notranslate"><span class="pre">at_occurrences</span></code></a>]]
                      | *
<strong id="grammar-token-at_occurrences">at_occurrences   </strong> ::=  at <a class="reference internal" href="#grammar-token-occurrences"><code class="xref docutils literal notranslate"><span class="pre">occurrences</span></code></a>
<strong id="grammar-token-occurrences">occurrences      </strong> ::=  [-] <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a> ... <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref docutils literal notranslate"><span class="pre">num</span></code></a>
</pre>
</div></blockquote>
<p>The role of an occurrence clause is to select a set of occurrences of a term
in a goal. In the first case, the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">at</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">num</span></span></span><span class="notation-sup"><span class="pre">*</span></span></span></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> parts indicate
that occurrences have to be selected in the hypotheses named <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.
If no numbers are given for hypothesis <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>, then all the
occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> in the hypothesis are selected. If numbers are
given, they refer to occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> when the term is printed
using option <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a>, counting from left to right. In particular,
occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> in implicit arguments
(see <a class="reference internal" href="../language/gallina-extensions.html#implicitarguments"><span class="std std-ref">Implicit arguments</span></a>) or coercions (see <a class="reference internal" href="../language/gallina-extensions.html#coercions"><span class="std std-ref">Coercions</span></a>) are
counted.</p>
<p>If a minus sign is given between <code class="docutils literal notranslate"><span class="pre">at</span></code> and the list of occurrences, it
negates the condition so that the clause denotes all the occurrences
except the ones explicitly mentioned after the minus sign.</p>
<p>As an exception to the left-to-right order, the occurrences in
the return subexpression of a match are considered <em>before</em> the
occurrences in the matched term.</p>
<p>In the second case, the <code class="docutils literal notranslate"><span class="pre">*</span></code> on the left of <code class="docutils literal notranslate"><span class="pre">|-</span></code> means that all occurrences
of term are selected in every hypothesis.</p>
<p>In the first and second case, if <code class="docutils literal notranslate"><span class="pre">*</span></code> is mentioned on the right of <code class="docutils literal notranslate"><span class="pre">|-</span></code>, the
occurrences of the conclusion of the goal have to be selected. If some numbers
are given, then only the occurrences denoted by these numbers are selected. If
no numbers are given, all occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> in the goal are selected.</p>
<p>Finally, the last notation is an abbreviation for <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">|-</span> <span class="pre">*</span></code>. Note also
that <code class="docutils literal notranslate"><span class="pre">|-</span></code> is optional in the first case when no <code class="docutils literal notranslate"><span class="pre">*</span></code> is given.</p>
<p>Here are some tactics that understand occurrence clauses: <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a>,
<a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a>, <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#managingthelocalcontext"><span class="std std-ref">Managing the local context</span></a>, <a class="reference internal" href="#caseanalysisandinduction"><span class="std std-ref">Case analysis and induction</span></a>,
<a class="reference internal" href="../language/gallina-extensions.html#printing-constructions-full"><span class="std std-ref">Printing constructions in full</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="applying-theorems">
<span id="applyingtheorems"></span><h2>Applying theorems<a class="headerlink" href="#applying-theorems" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.exact">
<code class="descname"><span class="notation"><span>exact</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.exact" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. It gives directly the exact proof
term of the goal. Let <code class="docutils literal notranslate"><span class="pre">T</span></code> be our goal, let <code class="docutils literal notranslate"><span class="pre">p</span></code> be a term of type <code class="docutils literal notranslate"><span class="pre">U</span></code> then
<code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">p</span></code> succeeds iff <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">U</span></code> are convertible (see
<a class="reference internal" href="../language/cic.html#conversion-rules"><span class="std std-ref">Conversion rules</span></a>).</p>
<dl class="exn">
<dt id="coq:exn.not-an-exact-proof">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>an</span> <span>exact</span> <span>proof.</span></span></code><a class="headerlink" href="#coq:exn.not-an-exact-proof" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eexact">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eexact</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>.</span></span></code><a class="headerlink" href="#coq:tacv.eexact" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> but is able to handle terms and
goals with existential variables.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.assumption">
<code class="descname"><span class="notation"><span>assumption</span></span></code><a class="headerlink" href="#coq:tacn.assumption" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic looks in the local context for a hypothesis whose type is
convertible to the goal. If it is the case, the subgoal is proved.
Otherwise, it fails.</p>
<dl class="exn">
<dt id="coq:exn.no-such-assumption">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>assumption.</span></span></code><a class="headerlink" href="#coq:exn.no-such-assumption" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eassumption">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eassumption</span></span></code><a class="headerlink" href="#coq:tacv.eassumption" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.assumption" title="assumption"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">assumption</span></code></a> but is able to handle
goals with existential variables.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.refine">
<code class="descname"><span class="notation"><span>refine</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.refine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. It behaves like <a class="reference internal" href="#coq:tacn.exact" title="exact"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exact</span></code></a> with a big
difference: the user can leave some holes (denoted by <code class="docutils literal notranslate"><span class="pre">_</span></code>
or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span><span class="pre">_</span></span> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code>) in the term. <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> will generate as many
subgoals as there are holes in the term. The type of holes must be either
synthesized by the system or declared by an explicit cast
like <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">nat</span> <span class="pre">-&gt;</span> <span class="pre">Prop)</span></code>. Any subgoal that
occurs in other subgoals is automatically shelved, as if calling
<a class="reference internal" href="#coq:tacv.shelve-unifiable" title="shelve_unifiable"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">shelve_unifiable</span></code></a>. This low-level tactic can be
useful to advanced users.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Option</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">Fail</span><span> : </span><span class="coqdoc-var">Option</span><span>
| </span><span class="coqdoc-var">Ok</span><span> : </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-var">Option</span><span>.</span></dt>
<dd><span class="first last">Option is defined
Option_rect is defined
Option_ind is defined
Option_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">get</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Option</span><span>, </span><span class="coqdoc-var">x</span><span> &lt;&gt; </span><span class="coqdoc-var">Fail</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Option</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Fail</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">refine</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;(</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">Option</span><span> =&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">return</span><span> </span><span class="coqdoc-var">x</span><span> &lt;&gt; </span><span class="coqdoc-var">Fail</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">Fail</span><span> =&gt; </span><span class="coqdoc-var">_</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-var">Ok</span><span> </span><span class="coqdoc-var">b</span><span> =&gt; </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">b</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">end</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Option</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Fail</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Fail</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-var">absurd</span><span> (</span><span class="coqdoc-var">Fail</span><span> = </span><span class="coqdoc-var">Fail</span><span>); </span><span class="coqdoc-tactic">trivial</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Defined</span><span>.</span></dt>
<dd><span class="first last">get is defined</span></dd>
</dl>
</div>
</div>
<dl class="exn">
<dt id="coq:exn.invalid-argument">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Invalid</span> <span>argument.</span></span></code><a class="headerlink" href="#coq:exn.invalid-argument" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> does not know what to do with the term you gave.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.refine-passed-ill-formed-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Refine</span> <span>passed</span> <span>ill-formed</span> <span>term.</span></span></code><a class="headerlink" href="#coq:exn.refine-passed-ill-formed-term" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The term you gave is not a valid proof (not easy to debug in general). This
message may also occur in higher-level tactics that call <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a>
internally.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-infer-a-term-for-this-placeholder-refine">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>infer</span> <span>a</span> <span>term</span> <span>for</span> <span>this</span> <span>placeholder.</span></span></code><a class="headerlink" href="#coq:exn.cannot-infer-a-term-for-this-placeholder-refine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>There is a hole in the term you gave whose type cannot be inferred. Put a
cast around it.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.simple-refine">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>refine</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.simple-refine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like refine, but it does not shelve any subgoal. It does
not perform any beta-reduction either.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.notypeclasses-refine">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>notypeclasses</span> <span>refine</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.notypeclasses-refine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a> except it performs type checking without
resolution of typeclasses.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.simple-notypeclasses-refine">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>notypeclasses</span> <span>refine</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.simple-notypeclasses-refine" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacv.simple-refine" title="simple refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">refine</span></code></a> except it performs type checking
without resolution of typeclasses.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.apply">
<code class="descname"><span class="notation"><span>apply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.apply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument term is a term well-formed in
the local context. The tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tries to match the current goal
against the conclusion of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. If it succeeds, then
the tactic returns as many subgoals as the number of non-dependent premises
of the type of term. If the conclusion of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> does
not match the goal <em>and</em> the conclusion is an inductive type isomorphic to
a tuple type, then each component of the tuple is recursively matched to
the goal in the left-to-right order.</p>
<p>The tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> relies on first-order unification with dependent
types unless the conclusion of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is of the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">P</span></span> <span><span class="pre">(t</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">...</span></span> <span><span class="pre">t</span><sub><span class="pre">n</span></sub></span><span><span class="pre">)</span></span></span></code> with <code class="docutils literal notranslate"><span class="pre">P</span></code> to be instantiated. In the latter case,
the behavior depends on the form of the goal. If the goal is of the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(fun</span></span> <span><span class="pre">x</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">Q)</span></span> <span><span class="pre">u</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">...</span></span> <span><span class="pre">u</span><sub><span class="pre">n</span></sub></span></span></code> and the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span><sub><span class="pre">i</span></sub></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">u</span><sub><span class="pre">i</span></sub></span></span></code> unify,
then <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> is taken to be <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">Q</span></span><span class="operator"><span class="pre">)</span></span></code>. Otherwise, <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
tries to define <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> by abstracting over <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t_1</span></span> <span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t__n</span></span></code> in the goal.
See <a class="reference internal" href="#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a> to transform the goal so that it
gets the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(fun</span></span> <span><span class="pre">x</span></span> <span><span class="pre">=&gt;</span></span> <span><span class="pre">Q)</span></span> <span><span class="pre">u</span><sub><span class="pre">1</span></sub></span> <span><span class="pre">...</span></span> <span><span class="pre">u</span><sub><span class="pre">n</span></sub></span></span></code>.</p>
<dl class="exn">
<dt id="coq:exn.unable-to-unify-term-with-term">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Unable</span> <span>to</span> <span>unify</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.unable-to-unify-term-with-term" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tactic failed to match the conclusion of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>
and the current goal. You can help the <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> tactic by
transforming your goal with the <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a> or <a class="reference internal" href="#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a>
tactics.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.unable-to-find-an-instance-for-the-variables-ident-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Unable</span> <span>to</span> <span>find</span> <span>an</span> <span>instance</span> <span>for</span> <span>the</span> <span>variables</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span><span>.</span></span></code><a class="headerlink" href="#coq:exn.unable-to-find-an-instance-for-the-variables-ident-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This occurs when some instantiations of the premises of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> are not deducible
from the unification. This is the case, for instance, when you want to apply a
transitivity property. In this case, you have to use one of the variants below:</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Provides apply with explicit instantiations for all dependent premises of the
type of term that do not occur in the conclusion and consequently cannot be
found by unification. Notice that the collection <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> must be given
according to the order of these dependent premises of the type of term.</p>
<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>the</span> <span>right</span> <span>number</span> <span>of</span> <span>missing</span> <span>arguments.</span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>This also provides apply with values for instantiating premises. Here, variables
are referred by names and non-dependent products by increasing numbers (see
<a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is a shortcut for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a><span><span class="pre">;</span></span> <span><span class="pre">[..</span></span> <span><span class="pre">|</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">[</span></span> <span><span class="pre">..</span></span> <span><span class="pre">|</span></span> <span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">n</span></sub></span></a><span><span class="pre">]</span></span> <span><span class="pre">...</span></span> <span><span class="pre">]</span></span></span></code>,
i.e. for the successive applications of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code><sub>i+1</sub> on the last subgoal
generated by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">i</span></sub></span></a></span></code> , starting from the application of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span><sub><span class="pre">1</span></sub></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eapply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eapply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.eapply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The tactic <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> behaves like <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> but it does not fail when no
instantiations are deducible for some variables in the premises. Rather, it
turns these variables into existential variables which are variables still to
instantiate (see <a class="reference internal" href="../language/gallina-extensions.html#existential-variables"><span class="std std-ref">Existential variables</span></a>). The instantiation is
intended to be found later in the proof.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>apply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>.</span></span></code></dt>
<dd><p>This behaves like <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> but it reasons modulo conversion only on subterms
that contain no variables to instantiate. For instance, the following example
does not succeed because it would require the conversion of <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">?foo</span></code> and
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">id</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>) := </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first last">id is defined</span></dd>
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">id</span><span> </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first last">H is declared</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">O</span><span> = </span><span class="coqdoc-var">O</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">simple</span><span> </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">The command has indeed failed with message:
Unable to unify &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">id</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?M160</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?M160</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; with &quot;0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0&quot;.</span></dd>
</dl>
</div>
</div>
<p>Because it reasons modulo a limited amount of conversion, <a class="reference internal" href="#coq:tacv.simple-apply" title="simple apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">simple</span> <span class="pre">apply</span></code></a> fails
quicker than <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and it is then well-suited for uses in user-defined
tactics that backtrack often. Moreover, it does not traverse tuples as <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
does.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.simple-apply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>apply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code><a class="headerlink" href="#coq:tacv.simple-apply" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:tacv.simple-eapply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>eapply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code><a class="headerlink" href="#coq:tacv.simple-eapply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This summarizes the different syntaxes for <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.lapply">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>lapply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.lapply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal, say <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code>. The argument term has to be
well-formed in the current context, its type being reducible to a non-dependent
product <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> with <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> possibly containing products. Then it generates
two subgoals <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">G</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code>. Applying <code class="docutils literal notranslate"><span class="pre">lapply</span> <span class="pre">H</span></code> (where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> has type
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">B</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> does not start with a product) does the same as giving the
sequence <code class="docutils literal notranslate"><span class="pre">cut</span> <span class="pre">B.</span> <span class="pre">2:apply</span> <span class="pre">H.</span></code> where <code class="docutils literal notranslate"><span class="pre">cut</span></code> is described below.</p>
<dl class="warn">
<dt id="coq:warn.when-term-contains-more-than-one-non-dependent-product-the-tactic-lapply-only-takes-into-account-the-first-product">
<em class="property"><span class="sigannot">Warning</span></em> <code class="descname"><span class="notation"><span>When</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>contains</span> <span>more</span> <span>than</span> <span>one</span> <span>non</span> <span>dependent</span> <span>product</span> <span>the</span> <span>tactic</span> <span>lapply</span> <span>only</span> <span>takes</span> <span>into</span> <span>account</span> <span>the</span> <span>first</span> <span>product.</span></span></code><a class="headerlink" href="#coq:warn.when-term-contains-more-than-one-non-dependent-product-the-tactic-lapply-only-takes-into-account-the-first-product" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Assume we have a transitive relation <code class="docutils literal notranslate"><span class="pre">R</span></code> on <code class="docutils literal notranslate"><span class="pre">nat</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-32:
&gt; Variable R : nat -&gt; nat -&gt; Prop.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> R is declared as a local axiom [local-declaration,scope]
R is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">Rtrans</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">z</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-62:
&gt; Hypothesis Rtrans : forall x y z:nat, R x y -&gt; R y z -&gt; R x z.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Rtrans is declared as a local axiom [local-declaration,scope]
Rtrans is declared</span></dd>
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-22:
&gt; Variables n m p : nat.
&gt; ^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n is declared as a local axiom [local-declaration,scope]
n is declared
Toplevel input, characters 0-22:
&gt; Variables n m p : nat.
&gt; ^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> m is declared as a local axiom [local-declaration,scope]
m is declared
Toplevel input, characters 0-22:
&gt; Variables n m p : nat.
&gt; ^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> p is declared as a local axiom [local-declaration,scope]
p is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">Rnm</span><span> : </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-23:
&gt; Hypothesis Rnm : R n m.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Rnm is declared as a local axiom [local-declaration,scope]
Rnm is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">Rmp</span><span> : </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-23:
&gt; Hypothesis Rmp : R m p.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Rmp is declared as a local axiom [local-declaration,scope]
Rmp is declared</span></dd>
</dl>
</div>
<p>Consider the goal <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">n</span> <span class="pre">p)</span></code> provable using the transitivity of <code class="docutils literal notranslate"><span class="pre">R</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">R</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>The direct application of <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code> with <code class="docutils literal notranslate"><span class="pre">apply</span></code> fails because no value
for <code class="docutils literal notranslate"><span class="pre">y</span></code> in <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code> is found by <code class="docutils literal notranslate"><span class="pre">apply</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Fail</span><span> </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span>.</span></dt>
<dd><span class="first last">The command has indeed failed with message:
Unable to find an instance for the variable y.</span></dd>
</dl>
</div>
<p>A solution is to <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">(Rtrans</span> <span class="pre">n</span> <span class="pre">m</span> <span class="pre">p)</span></code> or <code class="docutils literal notranslate"><span class="pre">(Rtrans</span> <span class="pre">n</span> <span class="pre">m)</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">apply</span><span> (</span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>).</span></dt>
<dd><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">n</span></code> can be inferred from the goal, so the following would work
too.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">apply</span><span> (</span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">m</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>More elegantly, <code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">Rtrans</span> <span class="pre">with</span> <span class="pre">(y:=m)</span></code> allows only mentioning the
unknown m:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-keyword">with</span><span> (</span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">m</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Another solution is to mention the proof of <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">x</span> <span class="pre">y)</span></code> in <code class="docutils literal notranslate"><span class="pre">Rtrans</span></code></p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-keyword">with</span><span> (1 := </span><span class="coqdoc-var">Rnm</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>... or the proof of <code class="docutils literal notranslate"><span class="pre">(R</span> <span class="pre">y</span> <span class="pre">z)</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rtrans</span><span> </span><span class="coqdoc-keyword">with</span><span> (2 := </span><span class="coqdoc-var">Rmp</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>On the opposite, one can use <code class="docutils literal notranslate"><span class="pre">eapply</span></code> which postpones the problem of
finding <code class="docutils literal notranslate"><span class="pre">m</span></code>. Then one can apply the hypotheses <code class="docutils literal notranslate"><span class="pre">Rnm</span></code> and <code class="docutils literal notranslate"><span class="pre">Rmp</span></code>. This
instantiates the existential variable and completes the proof.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">eapply</span><span> </span><span class="coqdoc-var">Rtrans</span><span>.</span></dt>
<dd><span class="first">2 focused subgoals
(shelved: 1)
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rnm</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">Rmp</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">When the conclusion of the type of the term to <code class="docutils literal notranslate"><span class="pre">apply</span></code> is an inductive
type isomorphic to a tuple type and <code class="docutils literal notranslate"><span class="pre">apply</span></code> looks recursively whether a
component of the tuple matches the goal, it excludes components whose
statement would result in applying an universal lemma of the form
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">A,</span> <span class="pre">...</span> <span class="pre">-&gt;</span> <span class="pre">A</span></code>. Excluding this kind of lemma can be avoided by
setting the following option:</p>
</div>
<dl class="flag">
<dt id="coq:flag.universal-lemma-under-conjunction">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Universal</span> <span>Lemma</span> <span>Under</span> <span>Conjunction</span></span></code><a class="headerlink" href="#coq:flag.universal-lemma-under-conjunction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option, which preserves compatibility with versions of Coq prior to
8.4 is also available for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> (see <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a>).</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.apply-in">
<code class="descname"><span class="notation"><span>apply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.apply-in" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is a term
well-formed in the local context and the argument <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is an
hypothesis of the context.
The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> tries to match the conclusion of the
type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> against a non-dependent premise of the type
of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, trying them from right to left. If it succeeds, the
statement of hypothesis <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is replaced by the conclusion of
the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. The tactic also returns as many subgoals as the
number of other non-dependent premises in the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> and of
the non-dependent premises of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. If the conclusion
of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> does not match the goal <em>and</em> the conclusion
is an inductive type isomorphic to a tuple type, then
the tuple is (recursively) decomposed and the first component of the tuple
of which a non-dependent premise matches the conclusion of the type of
<a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. Tuples are decomposed in a width-first left-to-right order
(for instance if the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H1</span></span></code> is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">&lt;-&gt;</span></span> <span class="name"><span class="pre">B</span></span></code> and the type of
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span></code> is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code> then <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">apply</span></span> <span class="name"><span class="pre">H1</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">H2</span></span></code> transforms the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H2</span></span></code>
into <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code>). The tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> relies on first-order pattern matching
with dependent types.</p>
<dl class="exn">
<dt id="coq:exn.statement-without-assumptions">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Statement</span> <span>without</span> <span>assumptions.</span></span></code><a class="headerlink" href="#coq:exn.statement-without-assumptions" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This happens if the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> has no non-dependent premise.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.unable-to-apply">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Unable</span> <span>to</span> <span>apply.</span></span></code><a class="headerlink" href="#coq:exn.unable-to-apply" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This happens if the conclusion of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> does not match any of
the non-dependent premises of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This applies each <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> in sequence in <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This does the same but uses the bindings in each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code> to
instantiate the parameters of the corresponding type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>
(see <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eapply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This works as <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a> but turns unresolved bindings into
existential variables, if any, instead of failing.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.apply-in-as">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code><a class="headerlink" href="#coq:tacv.apply-in-as" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This works as <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a> then applies the <code class="xref std std-token docutils literal notranslate"><span class="pre">intro_pattern</span></code>
to the hypothesis <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>apply</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This behaves like <a class="reference internal" href="#coq:tacn.apply-in" title="apply ... in"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span> <span class="pre">...</span> <span class="pre">in</span></code></a> but it reasons modulo conversion
only on subterms that contain no variables to instantiate. For instance,
if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">id</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">x</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span><span class="operator"><span class="pre">:</span></span> <span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">id</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">True</span></span></code> and
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H0</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">O</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">O</span></span></code> then <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">simple</span></span> <span class="keyword"><span class="pre">apply</span></span> <span class="name"><span class="pre">H</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">H0</span></span></code> does not succeed because it
would require the conversion of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">id</span></span> <span class="operator"><span class="pre">?</span></span><span class="name"><span class="pre">x</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">O</span></span></code> where <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">?</span></span><span class="name"><span class="pre">x</span></span></code> is
an existential variable to instantiate.
Tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> does not
either traverse tuples as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> does.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>apply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">intro_pattern</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>simple</span></span><span class="notation-sup">?</span></span> <span>eapply</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">intro_pattern</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This summarizes the different syntactic variants of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">eapply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">in</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.constructor">
<code class="descname"><span class="notation"><span>constructor</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code><a class="headerlink" href="#coq:tacn.constructor" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to a goal such that its conclusion is an inductive
type (say <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>). The argument <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> must be less or equal to the
numbers of constructor(s) of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>. Let <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">c</span><sub><span class="pre">i</span></sub></span></span></code> be the i-th
constructor of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>, then <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">constructor</span></span> <span class="name"><span class="pre">i</span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros;</span></span> <span><span class="pre">apply</span></span> <span><span class="pre">c</span><sub><span class="pre">i</span></sub></span></span></code>.</p>
<dl class="exn">
<dt id="coq:exn.not-an-inductive-product">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>product.</span></span></code><a class="headerlink" href="#coq:exn.not-an-inductive-product" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.not-enough-constructors">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>enough</span> <span>constructors.</span></span></code><a class="headerlink" href="#coq:exn.not-enough-constructors" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>constructor</span></span></code></dt>
<dd><p>This tries <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">constructor</span></span> <span class="literal number integer"><span class="pre">1</span></span></code> then <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">constructor</span></span> <span class="literal number integer"><span class="pre">2</span></span></code>, ..., then
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">constructor</span></span> <span class="name"><span class="pre">n</span></span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of constructors of the head
of the goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>constructor</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="pre">c</span></code> be the i-th constructor of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>, then
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">i</span></span> <span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros;</span></span> <span><span class="pre">apply</span></span> <span><span class="pre">c</span></span> <span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">The terms in the <a class="reference internal" href="#grammar-token-bindings_list"><code class="xref std std-token docutils literal notranslate"><span class="pre">bindings_list</span></code></a> are checked in the context
where constructor is executed and not in the context where <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>
is executed (the introductions are not taken into account).</p>
</div>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.split">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>split</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.split" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This applies only if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has a single constructor. It is then
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">1</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>. It is
typically used in the case of a conjunction <span class="math notranslate">\(A \wedge B\)</span>.</p>
<dl class="tacv">
<dt id="coq:tacv.exists">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>exists</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code><a class="headerlink" href="#coq:tacv.exists" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This applies only if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has a single constructor. It is then equivalent
to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros;</span></span> <span><span class="pre">constructor</span></span> <span><span class="pre">1</span></span> <span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a><span><span class="pre">.</span></span></span></code> It is typically used in
the case of an existential quantification <span class="math notranslate">\(\exists x, P(x).\)</span></p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>exists</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This iteratively applies <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exists</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span></code>.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.not-an-inductive-goal-with-1-constructor">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>goal</span> <span>with</span> <span>1</span> <span>constructor.</span></span></code><a class="headerlink" href="#coq:exn.not-an-inductive-goal-with-1-constructor" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.left">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>left</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.left" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:tacv.right">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>right</span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.right" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These tactics apply only if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has two constructors, for
instance in the case of a disjunction <span class="math notranslate">\(A \vee B\)</span>.
Then, they are respectively equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">1</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">constructor</span></span> <span><span class="pre">2</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>.</p>
<dl class="exn">
<dt id="coq:exn.not-an-inductive-goal-with-2-constructors">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>goal</span> <span>with</span> <span>2</span> <span>constructors.</span></span></code><a class="headerlink" href="#coq:exn.not-an-inductive-goal-with-2-constructors" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.econstructor">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>econstructor</span></span></code><a class="headerlink" href="#coq:tacv.econstructor" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:tacv.eexists">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eexists</span></span></code><a class="headerlink" href="#coq:tacv.eexists" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:tacv.esplit">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>esplit</span></span></code><a class="headerlink" href="#coq:tacv.esplit" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:tacv.eleft">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eleft</span></span></code><a class="headerlink" href="#coq:tacv.eleft" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:tacv.eright">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eright</span></span></code><a class="headerlink" href="#coq:tacv.eright" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These tactics and their variants behave like <a class="reference internal" href="#coq:tacn.constructor" title="constructor"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">constructor</span></code></a>,
<a class="reference internal" href="#coq:tacv.exists" title="exists"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">exists</span></code></a>, <a class="reference internal" href="#coq:tacv.split" title="split"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">split</span></code></a>, <a class="reference internal" href="#coq:tacv.left" title="left"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">left</span></code></a>, <a class="reference internal" href="#coq:tacv.right" title="right"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">right</span></code></a> and their
variants but they introduce existential variables instead of failing
when the instantiation of a variable cannot be found
(cf. <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> and <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>).</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="managing-the-local-context">
<span id="managingthelocalcontext"></span><h2>Managing the local context<a class="headerlink" href="#managing-the-local-context" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.intro">
<code class="descname"><span class="notation"><span>intro</span></span></code><a class="headerlink" href="#coq:tacn.intro" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to a goal that is either a product or starts with a
let-binder. If the goal is a product, the tactic implements the &quot;Lam&quot; rule
given in <a class="reference internal" href="../language/cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a> <a class="footnote-reference" href="#id16" id="id3">[1]</a>. If the goal starts with a let-binder,
then the tactic implements a mix of the &quot;Let&quot; and &quot;Conv&quot;.</p>
<p>If the current goal is a dependent product <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">U</span></span></code>
(resp <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:=</span></span><span class="name"><span class="pre">t</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">U</span></span></code>) then <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> puts <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code> (resp <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:=</span></span><span class="name"><span class="pre">t</span></span></code>)
in the local context. The new subgoal is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code>.</p>
<p>If the goal is a non-dependent product <span class="math notranslate">\(T \rightarrow U\)</span>, then it
puts in the local context either <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Hn</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code> (if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> is of type <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code>
or <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>) or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Xn</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span></code> (if the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> is <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>).
The optional index <code class="docutils literal notranslate"><span class="pre">n</span></code> is such that <code class="docutils literal notranslate"><span class="pre">Hn</span></code> or <code class="docutils literal notranslate"><span class="pre">Xn</span></code> is a fresh
identifier. In both cases, the new subgoal is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code>.</p>
<p>If the goal is neither a product nor starting with a let definition,
the tactic <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> applies the tactic <a class="reference internal" href="#coq:tacn.hnf" title="hnf"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">hnf</span></code></a> until the
tactic <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> can be applied or the goal is not head-reducible.</p>
<dl class="exn">
<dt id="coq:exn.no-product-even-after-head-reduction">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>product</span> <span>even</span> <span>after</span> <span>head-reduction.</span></span></code><a class="headerlink" href="#coq:exn.no-product-even-after-head-reduction" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intro</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This applies <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> but forces <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> to be the name of
the introduced hypothesis.</p>
<dl class="exn">
<dt id="coq:exn.ident-is-already-used">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>already</span> <span>used.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-already-used" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If a name used by intro hides the base name of a global constant then
the latter can still be referred to by a qualified name
(see <a class="reference internal" href="../language/gallina-extensions.html#qualified-names"><span class="std std-ref">Qualified names</span></a>).</p>
</div>
<dl class="tacv">
<dt id="coq:tacv.intros">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intros</span></span></code><a class="headerlink" href="#coq:tacv.intros" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This repeats <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> until it meets the head-constant. It never
reduces head-constants and it never fails.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intros</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span><span>.</span></span></code></dt>
<dd><p>This is equivalent to the composed tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">intro</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intros</span> <span>until</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This repeats intro until it meets a premise of the goal having the
form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole"><span class="pre">type</span></span></a><span><span class="pre">)</span></span></span></code> and discharges the variable
named <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> of the current goal.</p>
<dl class="exn">
<dt id="coq:exn.no-such-hypothesis-in-current-goal">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis</span> <span>in</span> <span>current</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.no-such-hypothesis-in-current-goal" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intros</span> <span>until</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This repeats <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> until the <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a>-th non-dependent
product.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>On the subgoal <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">:</span></span> <span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code> the
tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span><span class="pre">1</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">x</span></span> <span><span class="pre">y</span></span> <span><span class="pre">H</span></span></span></code>,
as <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code> is the first non-dependent product.</p>
<p class="last">On the subgoal <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span> <span class="operator"><span class="pre">:</span></span> <span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code> the
tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <span><span class="pre">1</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">x</span></span> <span><span class="pre">y</span></span> <span><span class="pre">z</span></span></span></code>
as the product on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">z</span></span></code> can be rewritten as a non-dependent
product: <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">:</span></span> <span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="keyword type"><span class="pre">nat</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">x</span></span></code>.</p>
</div>
<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis</span> <span>in</span> <span>current</span> <span>goal.</span></span></code></dt>
<dd><p>This happens when <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> is 0 or is greater than the number of
non-dependent products of the goal.</p>
</dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a></span><span class="notation-sup">?</span></span> <span>after</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a></span><span class="notation-sup">?</span></span> <span>before</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a></span><span class="notation-sup">?</span></span> <span>at</span> <span>top</span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intro</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a></span><span class="notation-sup">?</span></span> <span>at</span> <span>bottom</span></span></code></dt>
<dd><p>These tactics apply <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code> and move the freshly
introduced hypothesis respectively after the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code>,
before the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code>, at the top of the local context,
or at the bottom of the local context. All hypotheses on which the new
hypothesis depends are moved too so as to respect the order of
dependencies between hypotheses. It is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>
followed by the appropriate call to <a class="reference internal" href="#coq:tacn.move-after" title="move ... after ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">after</span> <span class="pre">...</span></code></a>,
<a class="reference internal" href="#coq:tacv.move-before" title="move ... before ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">before</span> <span class="pre">...</span></code></a>, <a class="reference internal" href="#coq:tacv.move-at-top" title="move ... at top"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">at</span> <span class="pre">top</span></code></a>,
or <a class="reference internal" href="#coq:tacv.move-at-bottom" title="move ... at bottom"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">at</span> <span class="pre">bottom</span></code></a>.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <span><span class="pre">at</span></span> <span><span class="pre">bottom</span></span></span></code> is a synonym for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span></span></code> with no argument.</p>
</div>
<dl class="exn">
<dt id="coq:exn.no-such-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.no-such-hypothesis-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.intros">
<code class="descname"><span class="notation"><span>intros</span> <span class="hole">intro_pattern_list</span></span></code><a class="headerlink" href="#coq:tacn.intros" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This extension of the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span></span></code> allows to apply tactics on the fly
on the variables or hypotheses which have been introduced. An
<em>introduction pattern list</em> <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intro_pattern_list</span></span></span></code> is a list of
introduction patterns possibly containing the filling introduction
patterns <cite>*</cite> and <cite>**</cite>. An <em>introduction pattern</em> is either:</p>
<ul class="simple">
<li>a <em>naming introduction pattern</em>, i.e. either one of:<ul>
<li>the pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span></span></code></li>
<li>the pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?ident</span></span></span></code></li>
<li>an identifier</li>
</ul>
</li>
<li>an <em>action introduction pattern</em> which itself classifies into:<ul>
<li>a <em>disjunctive/conjunctive introduction pattern</em>, i.e. either one of<ul>
<li>a disjunction of lists of patterns
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span><span class="hole"><span class="pre">intro_pattern_list</span></span> <span><span class="pre">|</span></span> <span><span class="pre">...</span></span> <span><span class="pre">|</span></span> <span class="hole"><span class="pre">intro_pattern_list</span></span><span><span class="pre">]</span></span></span></code></li>
<li>a conjunction of patterns: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span><span><span class="pre">)</span></span></span></code></li>
<li>a list of patterns
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">&amp;</span></span></span><span><span class="pre">)</span></span></span></code>
for sequence of right-associative binary constructs</li>
</ul>
</li>
<li>an <em>equality introduction pattern</em>, i.e. either one of:<ul>
<li>a pattern for decomposing an equality: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[=</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">]</span></span></span></code></li>
<li>the rewriting orientations: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">-&gt;</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">&lt;-</span></span></span></code></li>
</ul>
</li>
<li>the on-the-fly application of lemmas: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">%term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code>
itself is not a pattern for on-the-fly application of lemmas (note:
syntax is in experimental stage)</li>
</ul>
</li>
<li>the wildcard: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">_</span></span></span></code></li>
</ul>
<p>Assuming a goal of type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Q</span></span> <span class="error"><span class="pre">→</span></span> <span class="name"><span class="pre">P</span></span></code> (non-dependent product), or of type
<span class="math notranslate">\(\forall\)</span><code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">P</span></span></code> (dependent product), the behavior of
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">p</span></span></span></code> is defined inductively over the structure of the introduction
pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code>:</p>
<p>Introduction on <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span></span></code> performs the introduction, and lets Coq choose a fresh
name for the variable;</p>
<p>Introduction on <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> performs the introduction, and lets Coq choose a
fresh name for the variable based on <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>;</p>
<p>Introduction on <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> behaves as described in <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a></p>
<p>Introduction over a disjunction of list of patterns
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span><span class="hole"><span class="pre">intro_pattern_list</span></span> <span><span class="pre">|</span></span> <span><span class="pre">...</span></span> <span><span class="pre">|</span></span> <span class="hole"><span class="pre">intro_pattern_list</span></span> <span><span class="pre">]</span></span></span></code> expects the product
to be over an inductive type whose number of constructors is <cite>n</cite> (or more
generally over a type of conclusion an inductive type built from <cite>n</cite>
constructors, e.g. <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">C</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">\/</span></span><span class="name"><span class="pre">B</span></span></code> with <cite>n=2</cite> since <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">\/</span></span><span class="name"><span class="pre">B</span></span></code> has <cite>2</cite>
constructors): it destructs the introduced hypothesis as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span></span></code> (see
<a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>) would and applies on each generated subgoal the
corresponding tactic;</p>
<p>The introduction patterns in <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intro_pattern_list</span></span></span></code> are expected to consume
no more than the number of arguments of the <cite>i</cite>-th constructor. If it
consumes less, then Coq completes the pattern so that all the arguments of
the constructors of the inductive type are introduced (for instance, the
list of patterns <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span><span class="pre">|</span></span> <span><span class="pre">]</span></span> <span><span class="pre">H</span></span></span></code> applied on goal <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">=</span></span><span class="literal number integer"><span class="pre">0</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="literal number integer"><span class="pre">0</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">x</span></span></code>
behaves the same as the list of patterns <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span><span class="pre">|</span></span> <span><span class="pre">?</span></span> <span><span class="pre">]</span></span> <span><span class="pre">H</span></span></span></code>);</p>
<p>Introduction over a conjunction of patterns <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span><span><span class="pre">)</span></span></span></code> expects
the goal to be a product over an inductive type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> with a single
constructor that itself has at least <cite>n</cite> arguments: It performs a case
analysis over the hypothesis, as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span></span></code> would, and applies the
patterns <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to the arguments of the constructor of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> (observe
that <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">)</span></span></span></code> is an alternative notation for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">]</span></span></span></code>);</p>
<p>Introduction via <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">&amp;</span></span></span><span><span class="pre">)</span></span></span></code> is a shortcut for introduction via
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(p,(</span></span> <span><span class="pre">...</span></span> <span><span class="pre">,(</span></span> <span><span class="pre">...,</span></span> <span><span class="pre">p</span></span> <span><span class="pre">)</span></span> <span><span class="pre">...</span></span> <span><span class="pre">))</span></span></span></code>; it expects the hypothesis to be a sequence of
right-associative binary inductive constructors such as <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">conj</span></span></code> or
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">ex_intro</span></span></code>; for instance, a hypothesis with type
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">/\(</span></span><span class="keyword"><span class="pre">exists</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">B</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">C</span></span> <span class="operator"><span class="pre">/\</span></span> <span class="name"><span class="pre">D</span></span><span class="operator"><span class="pre">)</span></span></code> can be introduced via pattern
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(a</span></span> <span><span class="pre">&amp;</span></span> <span><span class="pre">x</span></span> <span><span class="pre">&amp;</span></span> <span><span class="pre">b</span></span> <span><span class="pre">&amp;</span></span> <span><span class="pre">c</span></span> <span><span class="pre">&amp;</span></span> <span><span class="pre">d)</span></span></span></code>;</p>
<p>If the product is over an equality type, then a pattern of the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[=</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">]</span></span></span></code> applies either <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> or <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>
instead of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>; if <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> is applicable, the patterns
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code> are used on the hypotheses generated by <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a>; if the
number of patterns is smaller than the number of hypotheses generated, the
pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">?</span></span></span></code> is used to complete the list.</p>
<p>Introduction over <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> (respectively over <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>)
expects the hypothesis to be an equality and the right-hand-side
(respectively the left-hand-side) is replaced by the left-hand-side
(respectively the right-hand-side) in the conclusion of the goal;
the hypothesis itself is erased; if the term to substitute is a variable, it
is substituted also in the context of goal and the variable is removed too.</p>
<p>Introduction over a pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">%term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> first applies <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>
on the hypothesis to be introduced (as in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">term</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code>) prior to the
application of the introduction pattern <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code>;</p>
<p>Introduction on the wildcard depends on whether the product is dependent or not:
in the non-dependent case, it erases the corresponding hypothesis (i.e. it
behaves as an <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a> followed by a <a class="reference internal" href="#coq:tacn.clear" title="clear"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">clear</span></code></a>) while in the
dependent case, it succeeds and erases the variable only if the wildcard is part
of a more complex list of introduction patterns that also erases the hypotheses
depending on this variable;</p>
<p>Introduction over <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">*</span></span></span></code> introduces all forthcoming quantified variables
appearing in a row; introduction over <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">**</span></span></span></code> introduces all forthcoming
quantified variables or hypotheses until the goal is not any more a
quantification or an implication.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> \/ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">C</span><span> -&gt; (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>) -&gt; </span><span class="coqdoc-var">C</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A B C : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> * [</span><span class="coqdoc-var">a</span><span> | (</span><span class="coqdoc-var">_</span><span>,</span><span class="coqdoc-var">c</span><span>)] </span><span class="coqdoc-var">f</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">p</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> is not equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">p;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">intros</span></span> <span><span class="pre">p</span></span></span></code>
for the following reason: If one of the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code> is a wildcard pattern, it
might succeed in the first case because the further hypotheses it
depends on are eventually erased too while it might fail in the second
case because of dependencies in hypotheses which are not yet
introduced (and a fortiori not yet erased).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p>In <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span class="hole"><span class="pre">intro_pattern_list</span></span></span></code>, if the last introduction pattern
is a disjunctive or conjunctive pattern
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span><span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">intro_pattern_list</span></span></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">|</span></span></span><span><span class="pre">]</span></span></span></code>, the completion of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intro_pattern_list</span></span></span></code>
so that all the arguments of the i-th constructors of the corresponding
inductive type are introduced can be controlled with the following option:</p>
<dl class="last flag">
<dt id="coq:flag.bracketing-last-introduction-pattern">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Bracketing</span> <span>Last</span> <span>Introduction</span> <span>Pattern</span></span></code><a class="headerlink" href="#coq:flag.bracketing-last-introduction-pattern" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Force completion, if needed, when the last introduction pattern is a
disjunctive or conjunctive pattern (on by default).</p>
</dd></dl>

</div>
<dl class="tacn">
<dt id="coq:tacn.clear">
<code class="descname"><span class="notation"><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.clear" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic erases the hypothesis named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the local context of
the current goal. As a consequence, <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is no more displayed and no
more usable in the proof development.</p>
<dl class="exn">
<dt id="coq:exn.no-such-hypothesis">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code><a class="headerlink" href="#coq:exn.no-such-hypothesis" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.ident-is-used-in-the-conclusion">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>used</span> <span>in</span> <span>the</span> <span>conclusion.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-the-conclusion" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.ident-is-used-in-the-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>used</span> <span>in</span> <span>the</span> <span>hypothesis</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-the-hypothesis-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>clear</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">clear</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">.</span></span> <span><span class="pre">...</span></span> <span><span class="pre">clear</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">.</span></span></span></code></p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>clear</span> <span>-</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This variant clears all the hypotheses except the ones depending in the
hypotheses named <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> and in the goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>clear</span></span></code></dt>
<dd><p>This variants clears all the hypotheses except the ones the goal depends on.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>clear</span> <span>dependent</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This clears the hypothesis <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and all the hypotheses that
depend on it.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.clearbody">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>clearbody</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacv.clearbody" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic expects <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to be local definitions and clears
their respective bodies.
In other words, it turns the given definitions into assumptions.</p>
<dl class="exn">
<dt id="coq:exn.ident-is-not-a-local-definition">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>not</span> <span>a</span> <span>local</span> <span>definition.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-not-a-local-definition" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.revert">
<code class="descname"><span class="notation"><span>revert</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.revert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This applies to any goal with variables <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>. It moves the hypotheses
(possibly defined) to the goal, if this respects dependencies. This tactic is
the inverse of <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a>.</p>
<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code></dt>
<dd></dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span>is</span> <span>used</span> <span>in</span> <span>the</span> <span>hypothesis</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a><span>.</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.revert-dependent">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>revert</span> <span>dependent</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacv.revert-dependent" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This moves to the goal the hypothesis <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and all the
hypotheses that depend on it.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.move-after">
<code class="descname"><span class="notation"><span>move</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span>after</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span></code><a class="headerlink" href="#coq:tacn.move-after" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This moves the hypothesis named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> in the local context after
the hypothesis named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code>, where “after” is in reference to the
direction of the move. The proof term is not changed.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> comes before <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> in the order of dependencies,
then all the hypotheses between <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> that
(possibly indirectly) depend on <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> are moved too, and all of
them are thus moved after <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> in the order of dependencies.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> comes after <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> in the order of dependencies,
then all the hypotheses between <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> that
(possibly indirectly) occur in the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> are moved too,
and all of them are thus moved before <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> in the order of
dependencies.</p>
<dl class="tacv">
<dt id="coq:tacv.move-before">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>move</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span>before</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span></code><a class="headerlink" href="#coq:tacv.move-before" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This moves <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> towards and just before the hypothesis
named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code>.  As for <a class="reference internal" href="#coq:tacn.move-after" title="move ... after ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">move</span> <span class="pre">...</span> <span class="pre">after</span> <span class="pre">...</span></code></a>, dependencies
over <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> (when <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> comes before <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> in
the order of dependencies) or in the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code>
(when <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> comes after <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> in the order of
dependencies) are moved too.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.move-at-top">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>move</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>at</span> <span>top</span></span></code><a class="headerlink" href="#coq:tacv.move-at-top" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This moves <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> at the top of the local context (at the beginning
of the context).</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.move-at-bottom">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>move</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>at</span> <span>bottom</span></span></code><a class="headerlink" href="#coq:tacv.move-at-bottom" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This moves <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> at the bottom of the local context (at the end of
the context).</p>
</dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-move-ident-after-ident-it-occurs-in-the-type-of-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>move</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span>after</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a><span>:</span> <span>it</span> <span>occurs</span> <span>in</span> <span>the</span> <span>type</span> <span>of</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-move-ident-after-ident-it-occurs-in-the-type-of-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-move-ident-after-ident-it-depends-on-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>move</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span>after</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a><span>:</span> <span>it</span> <span>depends</span> <span>on</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-move-ident-after-ident-it-depends-on-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> :</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> = 0 -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">y</span><span>=</span><span class="coqdoc-var">y</span><span>-&gt; 0=</span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">H0</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  z, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">after</span><span> </span><span class="coqdoc-var">H0</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  z, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  z, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">before</span><span> </span><span class="coqdoc-var">H0</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  z, y, x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  z, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">H0</span><span> </span><span class="coqdoc-keyword">after</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  z, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">H0</span><span> </span><span class="coqdoc-keyword">before</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.rename">
<code class="descname"><span class="notation"><span>rename</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span>into</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span></code><a class="headerlink" href="#coq:tacn.rename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This renames hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a></span></code> into <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> in the current
context. The name of the hypothesis in the proof-term, however, is left
unchanged.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>rename</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>i</sub></span></a> <span>into</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>j</sub></span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This renames the variables <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">i</span></sub></span></a></span></code> into <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">j</span></sub></span></a></span></code> in parallel.
In particular, the target identifiers may contain identifiers that exist in
the source context, as long as the latter are also renamed by the same
tactic.</p>
</dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis.</span></span></code></dt>
<dd></dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>already</span> <span>used.</span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.set">
<code class="descname"><span class="notation"><span>set</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span></span></code><a class="headerlink" href="#coq:tacn.set" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This replaces <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> by <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> in the conclusion of the
current goal and adds the new definition <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> to the
local context.</p>
<p>If <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> has holes (i.e. subexpressions of the form “<cite>_</cite>”), the
tactic first checks that all subterms matching the pattern are compatible
before doing the replacement using the leftmost subterm matching the
pattern.</p>
<dl class="exn">
<dt id="coq:exn.the-variable-ident-is-already-defined">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <span>variable</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>already</span> <span>defined.</span></span></code><a class="headerlink" href="#coq:exn.the-variable-ident-is-already-defined" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>set</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span> <span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></code></dt>
<dd><p>This notation allows specifying which occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> have
to be substituted in the context. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span></code> clause
is an occurrence clause whose syntax and behavior are described in
<a class="reference internal" href="#occurencessets"><span class="std std-ref">goal occurences</span></a>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>set</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binders"><span class="hole">binders</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>set</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>
but <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is generated by Coq.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eset">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eset</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.eset" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:tacv.">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eset</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv." title="この定義へのパーマリンク">¶</a></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a> expect that no existential
variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.eset" title="eset"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eset</span></code></a> removes this
constraint. In practice, this is relevant only when <a class="reference internal" href="#coq:tacv.eset" title="eset"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eset</span></code></a> is
used as a synonym of <a class="reference internal" href="#coq:tacv.epose" title="epose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">epose</span></code></a>, i.e. when the <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> does
not occur in the goal.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.remember">
<code class="descname"><span class="notation"><span>remember</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.remember" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">1</span></sub></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span></span></code>, using a logical
(Leibniz’s) equality instead of a local definition.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span><sub><span class="pre">2</span></sub></span></a></span></code> is provided, it will be the name of the new equation.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>remember</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span><span class="notation-sup">?</span></span> <span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></code></dt>
<dd><p>This is a more general form of <a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a> that remembers the
occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> specified by an occurrence set.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eremember">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eremember</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>1</sub></span></a> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident<sub>2</sub></span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.eremember" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacn.remember" title="remember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">remember</span></code></a> expect that no
existential variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.eremember" title="eremember"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eremember</span></code></a>
removes this constraint.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.pose">
<code class="descname"><span class="notation"><span>pose</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span></span></code><a class="headerlink" href="#coq:tacn.pose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This adds the local definition <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> to the current context
without performing any replacement in the goal or in the hypotheses. It is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">set</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span> <span><span class="pre">in</span></span> <span><span class="pre">|-</span></span></span></code>.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pose</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binders"><span class="hole">binders</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">fun</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binders"><span class="hole"><span class="pre">binders</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pose</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code> but <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is
generated by Coq.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>epose</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binders"><span class="hole">binders</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.epose">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>epose</span> <span>term</span></span></code><a class="headerlink" href="#coq:tacv.epose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>While the different variants of <a class="reference internal" href="#coq:tacn.pose" title="pose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span></code></a> expect that no
existential variables are generated by the tactic, <a class="reference internal" href="#coq:tacv.epose" title="epose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">epose</span></code></a>
removes this constraint.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.decompose">
<code class="descname"><span class="notation"><span>decompose</span> <span>[</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span><span>]</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.decompose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic recursively decomposes a complex proposition in order to
obtain atomic ones.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">A</span><span> /\ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">C</span><span> \/ </span><span class="coqdoc-var">B</span><span> /\ </span><span class="coqdoc-var">C</span><span> \/ </span><span class="coqdoc-var">C</span><span> /\ </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">C</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> A B C : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-var">decompose</span><span> [</span><span class="coqdoc-var">and</span><span> </span><span class="coqdoc-var">or</span><span>] </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">3 subgoals
  
  A, B, C : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">B</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H3 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
subgoal 3 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">C</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-tactic">assumption</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd><span class="first last">Unnamed_thm is defined</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#coq:tacn.decompose" title="decompose"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">decompose</span></code></a> does not work on right-hand sides of implications or
products.</p>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>decompose</span> <span>sum</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This decomposes sum types (like <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">or</span></span></code>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>decompose</span> <span>record</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This decomposes record types (inductive types with one constructor,
like <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">and</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">exists</span></span></code> and those defined with the <a class="reference internal" href="../language/gallina-extensions.html#coq:cmd.record" title="Record"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Record</span></code></a>
command.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="controlling-the-proof-flow">
<span id="controllingtheproofflow"></span><h2>Controlling the proof flow<a class="headerlink" href="#controlling-the-proof-flow" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.assert">
<code class="descname"><span class="notation"><span>assert</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <span>form)</span></span></code><a class="headerlink" href="#coq:tacn.assert" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(H</span></span> <span><span class="pre">:</span></span> <span><span class="pre">U)</span></span></span></code> adds a new hypothesis
of name <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">H</span></span></span></code> asserting <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> to the current goal and opens a new subgoal
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> <a class="footnote-reference" href="#id17" id="id4">[2]</a>. The subgoal <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code> comes first in the list of subgoals remaining to
prove.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.not-a-proposition-or-a-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>a</span> <span>proposition</span> <span>or</span> <span>a</span> <span>type.</span></span></code><a class="headerlink" href="#coq:exn.not-a-proposition-or-a-type" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Arises when the argument form is neither of type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code> nor
<code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>assert</span> <span>form</span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:</span></span> <span><span class="pre">form)</span></span></span></code> but <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is generated by
Coq.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>assert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span></span></code> but applies tactic to solve the subgoals
generated by assert.</p>
<dl class="exn">
<dt id="coq:exn.proof-is-not-complete-assert">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Proof</span> <span>is</span> <span>not</span> <span>complete.</span></span></code><a class="headerlink" href="#coq:exn.proof-is-not-complete-assert" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>assert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span></code> is a naming introduction pattern (see <a class="reference internal" href="#coq:tacn.intro" title="intro"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intro</span></code></a>),
the hypothesis is named after this introduction pattern (in particular, if
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span></code> is <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, the tactic behaves like
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:</span></span> <span><span class="pre">form)</span></span></span></code>). If <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span></code> is an action
introduction pattern, the tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">form</span></span></span></code> followed by
the action done by this introduction pattern.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>assert</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a> <span>as</span> <span class="hole">intro_pattern</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This combines the two previous variants of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>assert</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>)</span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:</span></span> <span><span class="pre">type)</span></span> <span><span class="pre">by</span></span> <span><span class="pre">exact</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">type</span></span></code> is
the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">term</span></span></code>. This is deprecated in favor of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">proof</span></span></span></code>. If the
head of term is <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, the tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">specialize</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<dl class="exn">
<dt id="coq:exn.variable-ident-is-already-declared">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Variable</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>already</span> <span>declared.</span></span></code><a class="headerlink" href="#coq:exn.variable-ident-is-already-declared" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eassert">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eassert</span> <span>form</span> <span>as</span> <span>intro</span><span>_</span><span>pattern</span> <span>by</span> <span>tactic</span></span></code><a class="headerlink" href="#coq:tacv.eassert" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>assert</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span></span></code></dt>
<dd><p>While the different variants of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span></span></code> expect that no existential
variables are generated by the tactic, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">eassert</span></span></span></code> removes this constraint.
This allows not to specify the asserted statement completeley before starting
to prove it.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.pose-proof">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pose</span> <span>proof</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.pose-proof" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">T</span></span> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">as</span></span> <span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span><span class="notation-sup"><span class="pre">?</span></span></span> <span><span class="pre">by</span></span> <span><span class="pre">exact</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> is the type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">term</span></span></code>. In particular,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">proof</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">as</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">)</span></span></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">proof</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">as</span></span> <span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span></code> is the same as applying the
intro_pattern to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>epose</span> <span>proof</span> <span>term</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>While <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pose</span></span> <span><span class="pre">proof</span></span></span></code> expects that no existential variables are generated by
the tactic, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">epose</span></span> <span><span class="pre">proof</span></span></span></code> removes this constraint.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.enough">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>enough</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <span>form)</span></span></code><a class="headerlink" href="#coq:tacv.enough" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This adds a new hypothesis of name <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> asserting <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">form</span></span></span></code> to the
goal the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span></span></code> is applied to. A new subgoal stating <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">form</span></span></span></code> is
inserted after the initial goal rather than before it as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span></span></code> would do.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>enough</span> <span>form</span></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:</span></span> <span><span class="pre">form)</span></span></span></code> with the name <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> of
the hypothesis generated by Coq.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>enough</span> <span>form</span> <span>as</span> <span>intro</span><span>_</span><span>pattern</span></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <span><span class="pre">form</span></span></span></code> using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span></code> to name or
destruct the new hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>enough</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a><span>)</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>enough</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>enough</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a> <span>as</span> <span class="hole">intro_pattern</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This behaves as above but with <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">tactic</span></span></span></code> expected to solve the initial goal
after the extra assumption <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">form</span></span></span></code> is added and possibly destructed. If the
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">as</span></span> <span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span></code> clause generates more than one subgoal, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">tactic</span></span></span></code> is
applied to all of them.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eenough">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eenough</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <span>form)</span> <span>by</span> <span>tactic</span></span></code><a class="headerlink" href="#coq:tacv.eenough" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eenough</span> <span>form</span> <span>by</span> <span>tactic</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eenough</span> <span>form</span> <span>as</span> <span>intro</span><span>_</span><span>pattern</span> <span>by</span> <span>tactic</span></span></code></dt>
<dd><p>While the different variants of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span></span></code> expect that no existential
variables are generated by the tactic, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">eenough</span></span></span></code> removes this constraint.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.cut">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cut</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a></span></code><a class="headerlink" href="#coq:tacv.cut" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. It implements the non-dependent case of
the “App” rule given in <a class="reference internal" href="../language/cic.html#typing-rules"><span class="std std-ref">Typing rules</span></a>. (This is Modus Ponens inference
rule.) <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cut</span></span> <span><span class="pre">U</span></span></span></code> transforms the current goal <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> into the two following
subgoals: <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">T</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span></code>. The subgoal <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">U</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">T</span></span></code> comes first in the
list of remaining subgoal to prove.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>specialize</span> <span>(ident</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">*</span></span><span>)</span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.specialize">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>specialize</span> <span>ident</span> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.specialize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">specialize</span></span></span></code> works on local hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>. The
premises of this hypothesis (either universal quantifications or
non-dependent implications) are instantiated by concrete terms coming either
from arguments <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code> or from a <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>.
In the first form the application to <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code>  can be partial. The
first form is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">assert</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span><span><span class="pre">)</span></span></span></code>. In the
second form, instantiation elements can also be partial. In this case the
uninstantiated arguments are inferred by unification if possible or left
quantified in the hypothesis otherwise. With the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">as</span></span></span></code> clause, the local
hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is left unchanged and instead, the modified hypothesis
is introduced as specified by the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span><span><span class="pre">_</span></span><span><span class="pre">pattern</span></span></span></code>. The name <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
can also refer to a global lemma or hypothesis. In this case, for
compatibility reasons, the behavior of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">specialize</span></span></span></code> is close to that of
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span></span></code>: the instantiated statement becomes an additional premise of
the goal. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">as</span></span></span></code> clause is especially useful in this case to immediately
introduce the instantiated statement as a local hypothesis.</p>
<dl class="exn">
<dt id="coq:exn.ident-is-used-in-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>used</span> <span>in</span> <span>hypothesis</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-hypothesis-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.ident-is-used-in-conclusion">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>used</span> <span>in</span> <span>conclusion.</span></span></code><a class="headerlink" href="#coq:exn.ident-is-used-in-conclusion" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.generalize">
<code class="descname"><span class="notation"><span>generalize</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.generalize" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. It generalizes the conclusion with
respect to some term.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">nat</span><span>, 0 &lt;= </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Proof</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-tactic">intros</span><span> *.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Show</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">generalize</span><span> (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">y</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>If the goal is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> is a subterm of type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> in the goal,
then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <span><span class="pre">t</span></span></span></code> replaces the goal by <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">G</span></span><span class="error"><span class="pre">′</span></span></code> where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span><span class="error"><span class="pre">′</span></span></code>
is obtained from <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code> by replacing all occurrences of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> by <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code>. The
name of the variable (here <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span></code>) is chosen based on <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code>.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>generalize</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">generalize</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.
Note that the sequence of term <sub>i</sub> 's are processed from n to 1.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>generalize</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but it generalizes only over the
specified occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> (counting from left to right on the
expression printed using option <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>generalize</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but it uses <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> to name
the generalized hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>generalize</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span> <span>as</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is the most general form of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">generalize</span></span></span></code> that combines the previous
behaviors.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>generalize</span> <span>dependent</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This generalizes term but also <em>all</em> hypotheses that depend on <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. It
clears the generalized hypotheses.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.evar">
<code class="descname"><span class="notation"><span>evar</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span></span></code><a class="headerlink" href="#coq:tacn.evar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">evar</span></span></span></code> tactic creates a new local definition named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> with type
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> in the context. The body of this binding is a fresh existential
variable.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.instantiate">
<code class="descname"><span class="notation"><span>instantiate</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>)</span></span></code><a class="headerlink" href="#coq:tacn.instantiate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The instantiate tactic refines (see <a class="reference internal" href="#coq:tacn.refine" title="refine"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">refine</span></code></a>) an existential variable
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> with the term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. It is equivalent to only [ident]:
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">refine</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> (preferred alternative).</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">To be able to refer to an existential variable by name, the user
must have given the name explicitly (see <a class="reference internal" href="../language/gallina-extensions.html#existential-variables"><span class="std std-ref">Existential variables</span></a>).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">When you are referring to hypotheses which you did not name
explicitly, be aware that Coq may make a different decision on how to
name the variable in the current goal and in the context of the
existential variable. This can lead to surprising behaviors.</p>
</div>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>instantiate</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>)</span></span></code></dt>
<dd><p>This variant allows to refer to an existential variable which was not named
by the user. The <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> argument is the position of the existential variable
from right to left in the goal. Because this variant is not robust to slight
changes in the goal, its use is strongly discouraged.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>instantiate</span> <span>(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>)</span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>instantiate</span> <span>(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>)</span> <span>in</span> <span>(</span> <span>Value</span> <span>of</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>)</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>instantiate</span> <span>(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>)</span> <span>in</span> <span>(</span> <span>Type</span> <span>of</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>)</span></span></code></dt>
<dd><p>These allow to refer respectively to existential variables occurring in a
hypothesis or in the body or the type of a local definition.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>instantiate</span></span></code></dt>
<dd><p>Without argument, the instantiate tactic tries to solve as many existential
variables as possible, using information gathered from other tactics in the
same tactical. This is automatically done after each complete tactic (i.e.
after a dot in proof mode), but not, for example, between each tactic when
they are sequenced by semicolons.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.admit">
<code class="descname"><span class="notation"><span>admit</span></span></code><a class="headerlink" href="#coq:tacn.admit" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The admit tactic allows temporarily skipping a subgoal so as to
progress further in the rest of the proof. A proof containing admitted
goals cannot be closed with <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Qed</span></span></code> but only with <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Admitted</span></span></code>.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>give</span><span>_</span><span>up</span></span></code></dt>
<dd><p>Synonym of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">admit</span></span></span></code>.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.absurd">
<code class="descname"><span class="notation"><span>absurd</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.absurd" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument term is any proposition
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> of type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>. This tactic applies False elimination, that is it
deduces the current goal from False, and generates as subgoals <code class="code Coq docutils literal notranslate"><span class="error"><span class="pre">∼</span></span><span class="name"><span class="pre">P</span></span></code> and
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. It is very useful in proofs by cases, where some cases are
impossible. In most cases, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="error"><span class="pre">∼</span></span><span class="name"><span class="pre">P</span></span></code> is one of the hypotheses of the
local context.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.contradiction">
<code class="descname"><span class="notation"><span>contradiction</span></span></code><a class="headerlink" href="#coq:tacn.contradiction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The contradiction tactic attempts to
find in the current context (after all intros) a hypothesis that is
equivalent to an empty inductive type (e.g. <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">False</span></span></code>), to the negation of
a singleton inductive type (e.g. <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">True</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">x</span></span></code>), or two contradictory
hypotheses.</p>
</dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>assumption.</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>contradiction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>The proof of False is searched in the hypothesis named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.contradict">
<code class="descname"><span class="notation"><span>contradict</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.contradict" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic allows manipulating negated hypothesis and goals. The name
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> should correspond to a hypothesis. With <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">contradict</span></span> <span><span class="pre">H</span></span></span></code>, the
current goal and context is transformed in the following way:</p>
<ul class="simple">
<li>H:¬A ⊢ B becomes ⊢ A</li>
<li>H:¬A ⊢ ¬B becomes H: B ⊢ A</li>
<li>H: A ⊢ B becomes ⊢ ¬A</li>
<li>H: A ⊢ ¬B becomes H: B ⊢ ¬A</li>
</ul>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.exfalso">
<code class="descname"><span class="notation"><span>exfalso</span></span></code><a class="headerlink" href="#coq:tacn.exfalso" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic implements the “ex falso quodlibet” logical principle: an
elimination of False is performed on the current goal, and the user is
then required to prove that False is indeed provable in the current
context. This tactic is a macro for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elimtype</span></span> <span><span class="pre">False</span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="case-analysis-and-induction">
<span id="caseanalysisandinduction"></span><h2>Case analysis and induction<a class="headerlink" href="#case-analysis-and-induction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The tactics presented in this section implement induction or case
analysis on inductive or co-inductive objects (see <a class="reference internal" href="../language/cic.html#inductive-definitions"><span class="std std-ref">Inductive Definitions</span></a>).</p>
<dl class="tacn">
<dt id="coq:tacn.destruct">
<code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.destruct" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> must be of
inductive or co-inductive type and the tactic generates subgoals, one
for each possible form of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, i.e. one for each constructor of the
inductive or co-inductive type. Unlike <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>, no induction
hypothesis is generated by <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>If <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> denotes a quantified variable of the conclusion
of the goal, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> behaves
as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>. If <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is not
anymore dependent in the goal after application of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, it
is erased (to avoid erasure, use parentheses, as in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">)</span></span></span></code>).</p>
<p>If <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a hypothesis of the context, and <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>
is not anymore dependent in the goal after application
of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a>, it is erased (to avoid erasure, use parentheses, as
in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">)</span></span></span></code>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><blockquote>
<div><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>
followed by destruct applied to the last introduced hypothesis.</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">For destruction of a numeral, use syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a><span><span class="pre">)</span></span></span></code> (not
very interesting anyway).</p>
</div>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a></span></code></dt>
<dd><p>The argument of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> can also be a pattern of which holes are
denoted by “_”. In this case, the tactic checks that all subterms
matching the pattern in the conclusion and the hypotheses are compatible
and performs case analysis using this subterm.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is a shortcut for <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">...;</span></span> <span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span> <span class="hole">disj_conj_intro_pattern</span></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but uses the names
in <code class="xref std std-token docutils literal notranslate"><span class="pre">disj_conj_intro_pattern</span></code> to name the variables introduced in the
context. The <code class="xref std std-token docutils literal notranslate"><span class="pre">disj_conj_intro_pattern</span></code> must have the
form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[p11</span></span> <span><span class="pre">...</span></span> <span><span class="pre">p1n</span></span> <span><span class="pre">|</span></span> <span><span class="pre">...</span></span> <span><span class="pre">|</span></span> <span><span class="pre">pm1</span></span> <span><span class="pre">...</span></span> <span><span class="pre">pmn</span></span> <span><span class="pre">]</span></span></span></code> with <code class="docutils literal notranslate"><span class="pre">m</span></code> being the
number of constructors of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. Each variable
introduced by <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> in the context of the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th goal
gets its name from the list <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pi1</span></span> <span><span class="pre">...</span></span> <span><span class="pre">pin</span></span></span></code> in order. If there are not
enough names, <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> invents names for the remaining variables
to introduce. More generally, the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pij</span></span></span></code> can be any introduction
pattern (see <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>). This provides a concise notation for
chaining destruction of a hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.destruct-eqn">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>eqn:</span><span class="hole">naming_intro_pattern</span></span></code><a class="headerlink" href="#coq:tacv.destruct-eqn" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but adds an equation
between <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> and the value that it takes in each of the
possible cases. The name of the equation is specified
by <code class="xref std std-token docutils literal notranslate"><span class="pre">naming_intro_pattern</span></code> (see <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>),
in particular <code class="docutils literal notranslate"><span class="pre">?</span></code> can be used to let Coq generate a fresh name.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> providing explicit instances for
the dependent premises of the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.edestruct">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>edestruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.edestruct" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> except that it does not
fail if the instance of a dependent premises of the type
of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is not inferable. Instead, the unresolved instances
are left as existential variables to be inferred later, in the same way
as <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> does.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is synonym of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">using</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span class="repeat-wrapper"><span class="repeat"><span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span><span class="notation-sup"><span class="pre">?</span></span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></code></dt>
<dd><p>This syntax is used for selecting which occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>
the case analysis has to be done on. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span></code>
clause is an occurrence clause whose syntax and behavior is described
in <a class="reference internal" href="#occurencessets"><span class="std std-ref">occurences sets</span></a>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">disj_conj_intro_pattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><span class="hole">naming_intro_pattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>edestruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <span class="hole">disj_conj_intro_pattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>eqn:</span><span class="hole">naming_intro_pattern</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>These are the general forms of <a class="reference internal" href="#coq:tacn.destruct" title="destruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">destruct</span></code></a> and <a class="reference internal" href="#coq:tacv.edestruct" title="edestruct"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">edestruct</span></code></a>.
They combine the effects of the <code class="docutils literal notranslate"><span class="pre">with</span></code>, <code class="docutils literal notranslate"><span class="pre">as</span></code>, <code class="docutils literal notranslate"><span class="pre">eqn:</span></code>, <code class="docutils literal notranslate"><span class="pre">using</span></code>,
and <code class="docutils literal notranslate"><span class="pre">in</span></code> clauses.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.case">
<code class="descname"><span class="notation"><span>case</span> <span>term</span></span></code><a class="headerlink" href="#coq:tacn.case" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">case</span></span></span></code> is a more basic tactic to perform case analysis without
recursion. It behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but using a case-analysis
elimination principle and not a recursive one.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>case</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>Analogous to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span></code> above.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.ecase">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>ecase</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.ecase" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>In case the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> has dependent premises, or dependent premises
whose values are not inferable from the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">with</span></span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span></code> clause,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ecase</span></span></span></code> turns them into existential variables to be resolved later on.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.simple-destruct">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacv.simple-destruct" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">case</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> when <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
is a quantified variable of the goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>destruct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">case</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
is the name given by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> to the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> -th
non-dependent premise of the goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>case</span><span>_</span><span>eq</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">case</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span></span></code> is a variant of the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">case</span></span></span></code> tactic that allows to
perform case analysis on a term without completely forgetting its original
form. This is done by generating equalities between the original form of the
term and the outcomes of the case analysis.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.induction">
<code class="descname"><span class="notation"><span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.induction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> must be of
inductive type and the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code> generates subgoals, one for
each possible form of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, i.e. one for each constructor of the
inductive type.</p>
<p>If the argument is dependent in either the conclusion or some
hypotheses of the goal, the argument is replaced by the appropriate
constructor form in each of the resulting subgoals and induction
hypotheses are added to the local context using names whose prefix
is <strong>IH</strong>.</p>
<p>There are particular cases:</p>
<ul>
<li><p class="first">If term is an identifier <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> denoting a quantified variable of the
conclusion of the goal, then inductionident behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span>
</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">induction</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>. If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is not anymore dependent in the
goal after application of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code>, it is erased (to avoid erasure,
use parentheses, as in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">)</span></span></span></code>).</p>
</li>
<li><p class="first">If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> followed by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code> applied to the last
introduced hypothesis.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">For simple induction on a numeral, use syntax induction (num)
(not very interesting anyway).</p>
</div>
</li>
<li><p class="first">In case term is a hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> of the context, and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
is not anymore dependent in the goal after application of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span></span></code>,
it is erased (to avoid erasure, use parentheses, as in
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">)</span></span></span></code>).</p>
</li>
<li><p class="first">The argument <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> can also be a pattern of which holes are denoted
by “_”. In this case, the tactic checks that all subterms matching the
pattern in the conclusion and the hypotheses are compatible and
performs induction using this subterm.</p>
</li>
</ul>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">induction_test</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">n</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  H : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>an</span> <span>inductive</span> <span>product.</span></span></code></dt>
<dd></dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Unable</span> <span>to</span> <span>find</span> <span>an</span> <span>instance</span> <span>for</span> <span>the</span> <span>variables</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>...</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code></dt>
<dd><p>Use in this case the variant <a class="reference internal" href="#coq:tacv.elim-with" title="elim ... with"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span> <span class="pre">...</span> <span class="pre">with</span></code></a> below.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span> <span class="hole">disj_conj_intro_pattern</span></span></code></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> but uses the names in
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">disj_conj_intro_pattern</span></span></span></code> to name the variables introduced in the
context. The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">disj_conj_intro_pattern</span></span></span></code> must typically be of the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span><span class="pre">p</span></span></span></code> <sub>11</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code> <sub>1n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">|</span></span> <span><span class="pre">...</span></span> <span><span class="pre">|</span></span> <span><span class="pre">p</span></span></span></code><sub>m1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>mn</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>
with <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">m</span></span></span></code> being the number of constructors of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. Each
variable introduced by induction in the context of the i-th goal gets its
name from the list <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>i1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>in</sub> in order. If there are
not enough names, induction invents names for the remaining variables to
introduce. More generally, the <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>ij</sub> can be any
disjunctive/conjunctive introduction pattern (see <a class="reference internal" href="#coq:tacn.intros" title="intros ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span> <span class="pre">...</span></code></a>). For
instance, for an inductive type with  one constructor, the pattern notation
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(p</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">,</span></span> <span><span class="pre">...</span></span> <span><span class="pre">,</span></span> <span><span class="pre">p</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">)</span></span></span></code> can be used instead of
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[</span></span> <span><span class="pre">p</span></span></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>This behaves like <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> providing explicit instances for the
premises of the type of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">term</span></span></span></code> (see <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.einduction">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>einduction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.einduction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves like <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> except that it does not fail if
some dependent premise of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is not inferable. Instead,
the unresolved premises are posed as existential variables to be inferred
later, in the same way as <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> does.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.induction-using">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.induction-using" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>  but using <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> as induction scheme.
It does not expect the conclusion of the type of the first <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> to be
inductive.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacv.induction-using" title="induction ... using ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span> <span class="pre">...</span> <span class="pre">using</span> <span class="pre">...</span></code></a> but also providing instances
for the premises of the type of the second <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>induction</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code></dt>
<dd><p>This syntax is used for the case <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> denotes an induction principle
with complex predicates as the induction principles generated by
<code class="docutils literal notranslate"><span class="pre">Function</span></code> or <code class="docutils literal notranslate"><span class="pre">Functional</span> <span class="pre">Scheme</span></code> may be.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></code></dt>
<dd><p>This syntax is used for selecting which occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> the
induction has to be carried on. The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span></code> clause is an
occurrence clause whose syntax and behavior is described in
<a class="reference internal" href="#occurencessets"><span class="std std-ref">occurences sets</span></a>. If variables or hypotheses not
mentioning <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> in their type are listed in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole"><span class="pre">goal_occurrences</span></span></a></span></code>,
those are generalized as well in the statement to prove.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">comm</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">x</span><span> |-   *.</span></dt>
<dd><span class="first">2 subgoals
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Show</span><span> 2.</span></dt>
<dd><span class="first">subgoal 2 is:
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  IHy : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a> <span>as</span> <span class="hole">disj_conj_intro_pattern</span> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>einduction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a> <span>as</span> <span class="hole">disj_conj_intro_pattern</span> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a> <span>in</span> <a class="reference internal" href="#grammar-token-goal_occurrences"><span class="hole">goal_occurrences</span></a></span></code></dt>
<dd><p>These are the most general forms of <code class="docutils literal notranslate"><span class="pre">induction</span></code> and <code class="docutils literal notranslate"><span class="pre">einduction</span></code>. It combines the
effects of the with, as, using, and in clauses.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.elim">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>elim</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.elim" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This is a more basic induction tactic. Again, the type of the argument
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> must be an inductive type. Then, according to the type of the
goal, the tactic <code class="docutils literal notranslate"><span class="pre">elim</span></code> chooses the appropriate destructor and applies it
as the tactic <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> would do. For instance, if the proof context
contains <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span></code> and the current goal is <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> of type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>, then
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <span><span class="pre">n</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span><span class="pre">nat</span></span><span><span class="pre">_</span></span><span><span class="pre">ind</span></span> <span><span class="pre">with</span></span> <span><span class="pre">(n:=n)</span></span></span></code>. The tactic
<code class="docutils literal notranslate"><span class="pre">elim</span></code> does not modify the context of the goal, neither introduces the
induction loading into the context of hypotheses. More generally,
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> also works when the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a statement
with premises and whose conclusion is inductive. In that case the tactic
performs induction on the conclusion of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and leaves the
non-dependent premises of the type as subgoals. In the case of dependent
products, the tactic tries to find an instance for which the elimination
lemma applies and fails otherwise.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.elim-with">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>elim</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code><a class="headerlink" href="#coq:tacv.elim-with" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Allows to give explicit instances to the premises of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
(see <a class="reference internal" href="#bindingslist"><span class="std std-ref">bindings list</span></a>).</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.eelim">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eelim</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.eelim" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>In case the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> has dependent premises, this turns them into
existential variables to be resolved later on.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>elim</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>elim</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>Allows the user to give explicitly an induction principle <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> that
is not the standard one for the underlying inductive type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. The
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="#grammar-token-bindings_list"><span class="hole"><span class="pre">bindings_list</span></span></a></span></code> clause allows instantiating premises of the type of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>elim</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>eelim</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>These are the most general forms of <code class="docutils literal notranslate"><span class="pre">elim</span></code> and <code class="docutils literal notranslate"><span class="pre">eelim</span></code>. It combines the
effects of the <code class="docutils literal notranslate"><span class="pre">using</span></code> clause and of the two uses of the <code class="docutils literal notranslate"><span class="pre">with</span></code> clause.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.elimtype">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>elimtype</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-form"><span class="hole">form</span></a></span></code><a class="headerlink" href="#coq:tacv.elimtype" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The argument <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">form</span></span></span></code> must be inductively defined. <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elimtype</span></span> <span><span class="pre">I</span></span></span></code> is
equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cut</span></span> <span><span class="pre">I.</span></span> <span><span class="pre">intro</span></span> <span><span class="pre">Hn;</span></span> <span><span class="pre">elim</span></span> <span><span class="pre">Hn;</span></span> <span><span class="pre">clear</span></span> <span><span class="pre">Hn.</span></span></span></code> Therefore the
hypothesis <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Hn</span></span></code> will not appear in the context(s) of the subgoal(s).
Conversely, if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> is a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> of (inductive) type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> that does
not occur in the goal, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elim</span></span> <span><span class="pre">t</span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">elimtype</span></span> <span><span class="pre">I;</span></span> <span><span class="pre">2:exact</span></span> <span><span class="pre">t.</span></span></span></code></p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.simple-induction">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacv.simple-induction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">elim</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> when
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is a quantified variable of the goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This tactic behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">elim</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
is the name given by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> to the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>-th non-dependent
premise of the goal.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.double-induction">
<code class="descname"><span class="notation"><span>double</span> <span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.double-induction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic is deprecated and should be replaced by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">induction</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> (or
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">;</span></span> <span><span class="pre">destruct</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> depending on the exact needs).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>double</span> <span>induction</span> <span>num1</span> <span>num2</span></span></code></dt>
<dd><p>This tactic is deprecated and should be replaced by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">num1;</span></span> <span><span class="pre">induction</span></span> <span><span class="pre">num3</span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">num3</span></span></span></code> is the result
of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">num2</span></span> <span><span class="pre">-</span></span> <span><span class="pre">num1</span></span></span></code></p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.dependent-induction">
<code class="descname"><span class="notation"><span>dependent</span> <span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.dependent-induction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The <em>experimental</em> tactic dependent induction performs induction-
inversion on an instantiated inductive predicate. One needs to first
require the Coq.Program.Equality module to use this tactic. The tactic
is based on the BasicElim tactic by Conor McBride
<a class="reference internal" href="../zebibliography.html#dblp-conf-types-mcbride00" id="id5">[McB00]</a> and the work of Cristina Cornes around
inversion <a class="reference internal" href="../zebibliography.html#dblp-conf-types-cornest95" id="id6">[CT95]</a>. From an instantiated
inductive predicate and a goal, it generates an equivalent goal where
the hypothesis has been generalized over its indexes which are then
constrained by equalities to be the right instances. This permits to
state lemmas without resorting to manually adding these equalities and
still get enough information in the proofs.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">le_minus</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> &lt; 1 -&gt; </span><span class="coqdoc-var">n</span><span> = 0.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">H</span><span> ; </span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
<p>Here we did not get any information on the indexes to help fulfill
this proof. The problem is that, when we use the <code class="docutils literal notranslate"><span class="pre">induction</span></code> tactic, we
lose information on the hypothesis instance, notably that the second
argument is 1 here. Dependent induction solves this problem by adding
the corresponding equality to the context.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Program.Equality</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">le_minus</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> &lt; 1 -&gt; </span><span class="coqdoc-var">n</span><span> = 0.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">H</span><span> ; </span><span class="coqdoc-tactic">dependent</span><span> </span><span class="coqdoc-tactic">induction</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
<p>The subgoal is cleaned up as the tactic tries to automatically
simplify the subgoals with respect to the generated equalities. In
this enriched context, it becomes possible to solve this subgoal.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">reflexivity</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  IHle : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
<p>Now we are in a contradictory context and the proof can be solved.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
<p class="last">This technique works with any inductive predicate. In fact, the
<code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code> tactic is just a wrapper around the <code class="docutils literal notranslate"><span class="pre">induction</span></code>
tactic. One can make its own variant by just writing a new tactic
based on the definition found in <code class="docutils literal notranslate"><span class="pre">Coq.Program.Equality</span></code>.</p>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>induction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>generalizing</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This performs dependent induction on the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> but first
generalizes the goal by the given variables so that they are universally
quantified in the goal. This is generally what one wants to do with the
variables that are inside some constructors in the induction hypothesis. The
other ones need not be further generalized.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.dependent-destruction">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>destruction</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacv.dependent-destruction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This performs the generalization of the instance <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> but uses
<code class="docutils literal notranslate"><span class="pre">destruct</span></code> instead of induction on the generalized hypothesis. This gives
results equivalent to <code class="docutils literal notranslate"><span class="pre">inversion</span></code> or <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span></code> if the
hypothesis is dependent.</p>
</dd></dl>

<p>See also the larger example of <a class="reference internal" href="#coq:tacn.dependent-induction" title="dependent induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">induction</span></code></a>
and an explanation of the underlying technique.</p>
<dl class="tacn">
<dt id="coq:tacn.function-induction">
<code class="descname"><span class="notation"><span>function</span> <span>induction</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span><span>)</span></span></code><a class="headerlink" href="#coq:tacn.function-induction" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The tactic functional induction performs case analysis and induction
following the definition of a function. It makes use of a principle
generated by <code class="docutils literal notranslate"><span class="pre">Function</span></code> (see <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>) or
<code class="docutils literal notranslate"><span class="pre">Functional</span> <span class="pre">Scheme</span></code> (see <a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a>).
Note that this tactic is only available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">FunInd</span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file extraction_plugin.cmxs ... done]
[Loading ML file recdef_plugin.cmxs ... done]</span></dd>
<dt><span class="coqdoc-keyword">Functional Scheme</span><span> </span><span class="coqdoc-var">minus_ind</span><span> := </span><span class="coqdoc-keyword">Induction</span><span> </span><span class="coqdoc-keyword">for</span><span> </span><span class="coqdoc-var">minus</span><span> </span><span class="coqdoc-keyword">Sort</span><span> </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">sub_equation is defined
minus_ind is defined</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">minus_ind</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">minus_ind</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m k : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) 0 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m k : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
        </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
        </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">le_minus</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">n</span><span> - </span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">functional</span><span> </span><span class="coqdoc-tactic">induction</span><span> (</span><span class="coqdoc-var">minus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">minus_ind</span><span>; </span><span class="coqdoc-tactic">simpl</span><span>; </span><span class="coqdoc-tactic">auto</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd><span class="first last">le_minus is defined</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span><span><span class="pre">)</span></span></span></code> must be a correct full application
of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code>. In particular, the rules for implicit arguments are the
same as usual. For example use <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> if you want to write implicit
arguments explicitly.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Parentheses around <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> are not mandatory and can be skipped.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">functional</span></span> <span><span class="pre">induction</span></span> <span><span class="pre">(f</span></span> <span><span class="pre">x1</span></span> <span><span class="pre">x2</span></span> <span><span class="pre">x3)</span></span></span></code> is actually a wrapper for
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">x1,</span></span> <span><span class="pre">x2,</span></span> <span><span class="pre">x3,</span></span> <span><span class="pre">(f</span></span> <span><span class="pre">x1</span></span> <span><span class="pre">x2</span></span> <span><span class="pre">x3)</span></span> <span><span class="pre">using</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> followed by a cleaning
phase, where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> is the induction principle registered for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span></code>
(by the <code class="docutils literal notranslate"><span class="pre">Function</span></code> (see <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>) or
<code class="docutils literal notranslate"><span class="pre">Functional</span> <span class="pre">Scheme</span></code> (see <a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a>)
command) corresponding to the sort of the goal. Therefore
<code class="docutils literal notranslate"><span class="pre">functional</span> <span class="pre">induction</span></code> may fail if the induction scheme <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> is not
defined. See also <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a> for the function
terms accepted by <code class="docutils literal notranslate"><span class="pre">Function</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">There is a difference between obtaining an induction scheme
for a function by using <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Function</span></span></code> (see <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>)
and by using <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Functional</span></span> <span class="name"><span class="pre">Scheme</span></span></code> after a normal definition using
<code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Fixpoint</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Definition</span></span></code>. See <a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>
for details.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>, <a class="reference internal" href="../user-extensions/proof-schemes.html#functional-scheme"><span class="std std-ref">Generation of induction principles with Functional Scheme</span></a> and <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a></p>
</div>
<dl class="exn">
<dt id="coq:exn.cannot-find-induction-information-on-qualid">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>induction</span> <span>information</span> <span>on</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-induction-information-on-qualid" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.not-the-right-number-of-induction-arguments">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>the</span> <span>right</span> <span>number</span> <span>of</span> <span>induction</span> <span>arguments.</span></span></code><a class="headerlink" href="#coq:exn.not-the-right-number-of-induction-arguments" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>functional</span> <span>induction</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span><span>)</span> <span>as</span> <span class="hole">disj_conj_intro_pattern</span> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>Similarly to <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a> and <a class="reference internal" href="#coq:tacv.elim" title="elim"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">elim</span></code></a>, this allows giving
explicitly the name of the introduced variables, the induction principle, and
the values of dependent premises of the elimination scheme, including
<em>predicates</em> for mutual induction when <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> is part of a mutually
recursive definition.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.discriminate">
<code class="descname"><span class="notation"><span>discriminate</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.discriminate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic proves any goal from an assumption stating that two
structurally different <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">terms</span></span></span></code> of an inductive set are equal. For
example, from <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">))=(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span></code> we can derive by absurdity any
proposition.</p>
<p>The argument <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is assumed to be a proof of a statement of
conclusion <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> with the two terms being elements of an
inductive set. To build the proof, the tactic traverses the normal forms
<a class="footnote-reference" href="#id18" id="id7">[3]</a> of the terms looking for a couple of subterms <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">w</span></span></code> (<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code>
subterm of the normal form of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">w</span></span></code> subterm of the normal
form of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>), placed at the same positions and whose head symbols are
two different constructors. If such a couple of subterms exists, then the
proof of the current goal is completed, otherwise the tactic fails.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The syntax <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> can be used to refer to a hypothesis
quantified in the goal. In this case, the quantified hypothesis whose name is
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is first introduced in the local context using
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</div>
<dl class="exn">
<dt id="coq:exn.no-primitive-equality-found">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>primitive</span> <span>equality</span> <span>found.</span></span></code><a class="headerlink" href="#coq:exn.no-primitive-equality-found" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.not-a-discriminable-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>a</span> <span>discriminable</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.not-a-discriminable-equality" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>discriminate</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> followed by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the identifier for the last
introduced hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>discriminate</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but using the given
bindings to instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>ediscriminate</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.ediscriminate">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>ediscriminate</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.ediscriminate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This works the same as <code class="docutils literal notranslate"><span class="pre">discriminate</span></code> but if the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, or the
type of the hypothesis referred to by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>, has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>discriminate</span></span></code></dt>
<dd><p>This behaves like <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> if ident is the name of an
hypothesis to which <code class="docutils literal notranslate"><span class="pre">discriminate</span></code> is applicable; if the current goal is of
the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">&lt;&gt;</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, this behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">discriminate</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
<dl class="exn">
<dt id="coq:exn.no-discriminable-equalities">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>discriminable</span> <span>equalities.</span></span></code><a class="headerlink" href="#coq:exn.no-discriminable-equalities" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.injection">
<code class="descname"><span class="notation"><span>injection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.injection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The injection tactic exploits the property that constructors of
inductive types are injective, i.e. that if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> is a constructor of an
inductive type and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">t</span></span></code><sub>2</sub> are equal then
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>1</sub> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>2</sub> are equal too.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a proof of a statement of conclusion <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>,
then <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> applies the injectivity of constructors as deep as
possible to derive the equality of all the subterms of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> at positions where the terms start to differ. For example, from
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">q</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">))</span></span></code> we may derive <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">q</span></span></code> and
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">m</span></span></code>. For this tactic to work, the terms should be typed with an
inductive type and they should be neither convertible, nor having a different
head constructor. If these conditions are satisfied, the tactic derives the
equality of all the subterms at positions where they differ and adds them as
antecedents to the conclusion of the current goal.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Consider the following goal:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> : </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">list</span><span>
| </span><span class="coqdoc-var">cons</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">list</span><span> -&gt; </span><span class="coqdoc-var">list</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">list</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">P is declared</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">nil</span><span> -&gt; </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">cons</span><span> 0 </span><span class="coqdoc-var">nil</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">l</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">intros</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">injection</span><span> </span><span class="coqdoc-var">H0</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Beware that injection yields an equality in a sigma type whenever the
injected object has a dependent type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code> with its two instances in
different types <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>n</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span></code> and
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">u</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">u</span></span></code><sub>n</sub> <sub>)</sub>. If <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>1</sub> and
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code><sub>1</sub> are the same and have for type an inductive type for which a decidable
equality has been declared using the command <a class="reference internal" href="../user-extensions/proof-schemes.html#coq:cmdv.scheme-equality" title="Scheme Equality"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Scheme</span> <span class="pre">Equality</span></code></a>
(see <a class="reference internal" href="../user-extensions/proof-schemes.html#proofschemes-induction-principles"><span class="std std-ref">Generation of induction principles with Scheme</span></a>),
the use of a sigma type is avoided.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If some quantified hypothesis of the goal is named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>,
then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> first introduces the hypothesis in the local
context using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</div>
<dl class="exn">
<dt id="coq:exn.not-a-projectable-equality-but-a-discriminable-one">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>a</span> <span>projectable</span> <span>equality</span> <span>but</span> <span>a</span> <span>discriminable</span> <span>one.</span></span></code><a class="headerlink" href="#coq:exn.not-a-projectable-equality-but-a-discriminable-one" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.nothing-to-do-it-is-an-equality-between-convertible-terms">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Nothing</span> <span>to</span> <span>do,</span> <span>it</span> <span>is</span> <span>an</span> <span>equality</span> <span>between</span> <span>convertible</span> <span class="hole">terms</span><span>.</span></span></code><a class="headerlink" href="#coq:exn.nothing-to-do-it-is-an-equality-between-convertible-terms" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.not-a-primitive-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>a</span> <span>primitive</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.not-a-primitive-equality" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.nothing-to-inject">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Nothing</span> <span>to</span> <span>inject.</span></span></code><a class="headerlink" href="#coq:exn.nothing-to-inject" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>injection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> followed by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the identifier for the last
introduced hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>injection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>This does the same as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but using the given bindings to
instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.einjection">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>einjection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code><a class="headerlink" href="#coq:tacv.einjection" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>einjection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This works the same as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span></span></code> but if the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, or the
type of the hypothesis referred to by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>, has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>injection</span></span></code></dt>
<dd><p>If the current goal is of the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">&lt;&gt;</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> , this behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">injection</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
<dl class="exn">
<dt id="coq:exn.goal-does-not-satisfy-the-expected-preconditions">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>goal</span> <span>does</span> <span>not</span> <span>satisfy</span> <span>the</span> <span>expected</span> <span>preconditions.</span></span></code><a class="headerlink" href="#coq:exn.goal-does-not-satisfy-the-expected-preconditions" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>injection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">intro_pattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>injection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>injection</span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>einjection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>einjection</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>einjection</span> <span>as</span> <span class="repeat-wrapper"><span class="repeat"><span>intro</span><span>_</span><span>pattern</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<p>These variants apply <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="hole"><span class="pre">intro_pattern</span></span></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> after the call to
<a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> or <a class="reference internal" href="#coq:tacv.einjection" title="einjection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">einjection</span></code></a> so that all equalities generated are moved in
the context of hypotheses. The number of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intro_pattern</span></span></span></code> must not exceed
the number of equalities newly generated. If it is smaller, fresh
names are automatically generated to adjust the list of <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intro_pattern</span></span></span></code>
to the number of new equalities. The original equality is erased if it
corresponds to a hypothesis.</p>
<dl class="flag">
<dt id="coq:flag.structural-injection">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Structural</span> <span>Injection</span></span></code><a class="headerlink" href="#coq:flag.structural-injection" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option ensure that <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> erases the original hypothesis
and leaves the generated equalities in the context rather than putting them
as antecedents of the current goal, as if giving <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">as</span></span></span></code>
(with an empty list of names). This option is off by default.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.keep-proof-equalities">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Keep</span> <span>Proof</span> <span>Equalities</span></span></code><a class="headerlink" href="#coq:flag.keep-proof-equalities" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>By default, <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> only creates new equalities between <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">terms</span></span></span></code>
whose type is in sort <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Type</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Set</span></span></code>, thus implementing a special
behavior for objects that are proofs of a statement in <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>. This option
controls this behavior.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.inversion">
<code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.inversion" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Let the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the local context be <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code>
is a (co)inductive predicate. Then, <code class="docutils literal notranslate"><span class="pre">inversion</span></code> applied to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
derives for each possible constructor <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">i</span></span></code> of <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, all the
necessary conditions that should hold for the instance <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> to be
proved by <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">i</span></span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> does not denote a hypothesis in the local context but
refers to a hypothesis quantified in the goal, then the latter is
first introduced in the local context using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">As <code class="docutils literal notranslate"><span class="pre">inversion</span></code> proofs may be large in size, we recommend the
user to stock the lemmas whenever the same instance needs to be
inverted several times. See <a class="reference internal" href="../user-extensions/proof-schemes.html#derive-inversion"><span class="std std-ref">Generation of inversion principles with Derive Inversion</span></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">Part of the behavior of the <code class="docutils literal notranslate"><span class="pre">inversion</span></code> tactic is to generate
equalities between expressions that appeared in the hypothesis that is
being processed. By default, no equalities are generated if they
relate two proofs (i.e. equalities between <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">terms</span></span></span></code> whose type is in sort
<code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">Prop</span></span></code>). This behavior can be turned off by using the option
:flag`Keep Proof Equalities`.</p>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the identifier for the last introduced hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span></span></code> and then erases <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> from the context.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code></dt>
<dd><p>This generally behaves as inversion but using names in <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intro_pattern</span></span></span></code>
for naming hypotheses. The <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">intro_pattern</span></span></span></code> must have the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[p</span></span></span></code><sub>11</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>1n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">|</span></span> <span><span class="pre">...</span></span> <span><span class="pre">|</span></span> <span><span class="pre">p</span></span></span></code><sub>m1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>mn</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>
with <cite>m</cite> being the number of constructors of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>. Be
careful that the list must be of length <cite>m</cite> even if <code class="docutils literal notranslate"><span class="pre">inversion</span></code> discards
some cases (which is precisely one of its roles): for the discarded
cases, just use an empty list (i.e. <cite>n = 0</cite>).The arguments of the i-th
constructor and the equalities that <code class="docutils literal notranslate"><span class="pre">inversion</span></code> introduces in the
context of the goal corresponding to the i-th constructor, if it
exists, get their names from the list <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>i1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>in</sub> in
order. If there are not enough names, <code class="docutils literal notranslate"><span class="pre">inversion</span></code> invents names for the
remaining variables to introduce. In case an equation splits into several
equations (because <code class="docutils literal notranslate"><span class="pre">inversion</span></code> applies <code class="docutils literal notranslate"><span class="pre">injection</span></code> on the equalities it
generates), the corresponding name <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">p</span></span></span></code><sub>ij</sub> in the list must be
replaced by a sublist of the form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[p</span></span></span></code><sub>ij1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">...</span></span> <span><span class="pre">p</span></span></span></code><sub>ijq</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">]</span></span></span></code>
(or, equivalently, <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(p</span></span></span></code><sub>ij1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">,</span></span> <span><span class="pre">...,</span></span> <span><span class="pre">p</span></span></span></code><sub>ijq</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">)</span></span></span></code>) where
<cite>q</cite> is the number of subequalities obtained from splitting the original
equation. Here is an example. The <code class="docutils literal notranslate"><span class="pre">inversion</span> <span class="pre">...</span> <span class="pre">as</span></code> variant of
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> generally behaves in a slightly more expectable way than
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> (no artificial duplication of some hypotheses referring to
other hypotheses). To take benefit of these improvements, it is enough to use
<code class="docutils literal notranslate"><span class="pre">inversion</span> <span class="pre">...</span> <span class="pre">as</span> <span class="pre">[]</span></code>, letting the names being finally chosen by Coq.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">contains0</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">in_hd</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span>, </span><span class="coqdoc-var">contains0</span><span> (0 :: </span><span class="coqdoc-var">l</span><span>)</span><span>
| </span><span class="coqdoc-var">in_tl</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">contains0</span><span> </span><span class="coqdoc-var">l</span><span> -&gt; </span><span class="coqdoc-var">contains0</span><span> (</span><span class="coqdoc-var">b</span><span> :: </span><span class="coqdoc-var">l</span><span>).</span></dt>
<dd><span class="first last">contains0 is defined
contains0_ind is defined</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span>:</span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">contains0</span><span> (1 :: </span><span class="coqdoc-var">l</span><span>) -&gt; </span><span class="coqdoc-var">contains0</span><span> </span><span class="coqdoc-var">l</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">contains0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (1 </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">contains0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">as</span><span> [ | </span><span class="coqdoc-var">l'</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">Hl'</span><span> [</span><span class="coqdoc-var">Heqp</span><span> </span><span class="coqdoc-var">Heql'</span><span>] ].</span></dt>
<dd><span class="first">1 subgoal
  
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">contains0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (1 </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  l' : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hl' : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">contains0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Heqp : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1
  Heql' : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l'</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">contains0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> in the
context.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced by <code class="docutils literal notranslate"><span class="pre">inversion_clear</span></code> in the
context. Notice that hypothesis names can be provided as if <code class="docutils literal notranslate"><span class="pre">inversion</span></code>
were called, even though the <code class="docutils literal notranslate"><span class="pre">inversion_clear</span></code> will eventually erase the
hypotheses.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> be identifiers in the local context. This tactic behaves as
generalizing <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, and then performing <code class="docutils literal notranslate"><span class="pre">inversion</span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> be identifiers in the local context. This tactic behaves
as generalizing <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, and then performing <code class="docutils literal notranslate"><span class="pre">inversion_clear</span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span><span><span class="pre">_</span></span><span><span class="pre">clear</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.dependent-inversion">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacv.dependent-inversion" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>That must be used when <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> appears in the current goal. It acts like
<code class="docutils literal notranslate"><span class="pre">inversion</span></code> and then substitutes <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> for the corresponding
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">&#64;</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> in the goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>Like <code class="docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span></code>, except that <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is cleared from the
local context.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span><span><span class="pre">_</span></span><span><span class="pre">clear</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.dependent-inversion-with">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.dependent-inversion-with" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This variant allows you to specify the generalization of the goal. It is
useful when the system fails to generalize the goal automatically. If
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> has type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> has type <span class="math notranslate">\(\forall\)</span>
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">s</span></span></code>, then <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> must be of type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span><span class="operator"><span class="pre">:</span></span></code><span class="math notranslate">\(\forall\)</span>
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">T</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">s'</span></span></code> where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">s'</span></span></code> is the type of the goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">with</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Like <a class="reference internal" href="#coq:tacv.dependent-inversion-with" title="dependent inversion ... with ..."><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">inversion</span> <span class="pre">...</span> <span class="pre">with</span> <span class="pre">...</span></code></a> with but clears <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> from the
local context.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>inversion</span><span>_</span><span>clear</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">dependent</span></span> <span><span class="pre">inversion</span></span><span><span class="pre">_</span></span><span><span class="pre">clear</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">with</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.simple-inversion">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacv.simple-inversion" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>It is a very primitive inversion tactic that derives all the necessary
equalities but it does not simplify the constraints as <code class="docutils literal notranslate"><span class="pre">inversion</span></code> does.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simple</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>as</span> <span class="hole">intro_pattern</span></span></code></dt>
<dd><p>This allows naming the hypotheses introduced in the context by
<code class="docutils literal notranslate"><span class="pre">simple</span> <span class="pre">inversion</span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> have type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">I</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> (<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">I</span></span></code> an inductive predicate) in the
local context, and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> be a (dependent) inversion lemma. Then, this
tactic refines the current goal with the specified lemma.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>using</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This tactic behaves as generalizing <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, then doing
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">using</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>inversion</span><span>_</span><span>sigma</span></span></code></dt>
<dd><p>This tactic turns equalities of dependent pairs (e.g.,
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">q</span></span></code>, frequently left over by inversion on
a dependent type family) into pairs of equalities (e.g., a hypothesis
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span></code> and a hypothesis of type <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">rew</span></span> <span class="name"><span class="pre">H</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">p</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">q</span></span></code>); these
hypotheses can subsequently be simplified using <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>, without ever
invoking any kind of axiom asserting uniqueness of identity proofs. If you
want to explicitly specify the hypothesis to be inverted, or name the
generated hypotheses, you can invoke
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">induction</span></span> <span><span class="pre">H</span></span> <span><span class="pre">as</span></span> <span><span class="pre">[H1</span></span> <span><span class="pre">H2]</span></span> <span><span class="pre">using</span></span> <span><span class="pre">eq</span></span><span><span class="pre">_</span></span><span><span class="pre">sigT</span></span><span><span class="pre">_</span></span><span><span class="pre">rect.</span></span></span></code> This tactic also works for
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">sig</span></span></code>, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">sigT2</span></span></code>, and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">sig2</span></span></code>, and there are similar <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq_sig</span></span></code>
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">***_</span></span><span class="name"><span class="pre">rect</span></span></code> induction lemmas.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<p><em>Non-dependent inversion</em>.</p>
<p>Let us consider the relation Le over natural numbers and the following
variables:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Le</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">LeO</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> 0 </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">LeS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>).</span></dt>
<dd><span class="first last">Le is defined
Le_rect is defined
Le_ind is defined
Le_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 0-32:
&gt; Variable P : nat -&gt; nat -&gt; Prop.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> P is declared as a local axiom [local-declaration,scope]
P is declared</span></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 0-44:
&gt; Variable Q : forall n m:nat, Le n m -&gt; Prop.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Q is declared as a local axiom [local-declaration,scope]
Q is declared</span></dd>
</dl>
</div>
<p>Let us consider the following goal:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Le is defined
Le_rect is defined
Le_ind is defined
Le_rec is defined
Toplevel input, characters -78--46:
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P is declared as a local axiom [local-declaration,scope]
P is declared
Toplevel input, characters -45--1:
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Q is declared as a local axiom [local-declaration,scope]
Q is declared
1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-tactic">intros</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Show</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>To prove the goal, we may need to reason by cases on H and to derive
that m is necessarily of the form (S m 0 ) for certain m 0 and that
(Le n m 0 ). Deriving these conditions corresponds to proving that the
only possible constructor of (Le (S n) m) isLeS and that we can invert
the-&gt; in the type of LeS. This inversion is possible because Le is the
smallest set closed by the constructors LeO and LeS.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">inversion_clear</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m, m0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>Note that m has been substituted in the goal for (S m0) and that the
hypothesis (Le n m0) has been added to the context.</p>
<p>Sometimes it is interesting to have the equality m=(S m0) in the
context to use it after. In that case we can use inversion that does
not clear the equalities:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n0, m0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H1 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p><em>Dependent inversion.</em></p>
<p>Let us consider the following goal:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Le</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Set</span><span> :=</span><span>
| </span><span class="coqdoc-var">LeO</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> 0 </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">LeS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">Le is defined
Le_rect is defined
Le_ind is defined
Le_rec is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-32:
&gt; Variable P : nat -&gt; nat -&gt; Prop.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> P is declared as a local axiom [local-declaration,scope]
P is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">Le</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-44:
&gt; Variable Q : forall n m:nat, Le n m -&gt; Prop.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Q is declared as a local axiom [local-declaration,scope]
Q is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span>:</span><span class="coqdoc-var">Le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span>), </span><span class="coqdoc-var">Q</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-tactic">intros</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Show</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>As H occurs in the goal, we may want to reason by cases on its
structure and so, we would like inversion tactics to substitute H by
the corresponding &#64;term in constructor form. Neither <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> nor
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">inversion</span></span><span><span class="pre">_</span></span><span><span class="pre">clear</span></span></span></code> do such a substitution. To have such a behavior we
use the dependent inversion tactics:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">dependent</span><span> </span><span class="coqdoc-tactic">inversion_clear</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m, m0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Le</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">LeS</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p class="last">Note that H has been substituted by (LeS n m0 l) andm by (S m0).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p><em>Using inversion_sigma.</em></p>
<p>Let us consider the following inductive type of
length-indexed lists, and a lemma about inverting equality of cons:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Coq.Logic.Eqdep_dec</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">nil</span><span> : </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">O</span><span>
| </span><span class="coqdoc-var">cons</span><span> {</span><span class="coqdoc-var">n</span><span>} (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">xs</span><span> : </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">vec</span><span> </span><span class="coqdoc-var">A</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>).</span></dt>
<dd><span class="first last">vec is defined
vec_rect is defined
vec_ind is defined
vec_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">invert_cons</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">xs</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">ys</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#64;</span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">xs</span><span> = &#64;</span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">ys</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&gt; </span><span class="coqdoc-var">xs</span><span> = </span><span class="coqdoc-var">ys</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (xs : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (y : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (ys : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Proof</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-tactic">intros</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">xs</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">ys</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  xs : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ys : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>After performing inversion, we are left with an equality of existTs:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">inversion</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  xs : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ys : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">existT</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
       </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">existT</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>We can turn this equality into a usable form with inversion_sigma:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">inversion_sigma</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  xs : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ys : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_rect</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>To finish cleaning up the proof, we will need to use the fact that
that all proofs of n = n for n a nat are eq_refl:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">H</span><span> := </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-keyword">end</span><span> </span><span class="coqdoc-tactic">in</span><span>
</span><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">proof</span><span> (</span><span class="coqdoc-var">Eqdep_dec.UIP_refl_nat</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">H</span><span>); </span><span class="coqdoc-tactic">subst</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  xs : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ys : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_rect</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">eq_refl</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">simpl</span><span> </span><span class="coqdoc-tactic">in</span><span> *.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  xs : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ys : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">vec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">cons</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H3 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">xs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ys</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Finally, we can finish the proof:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">assumption</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd><span class="first last">invert_cons is defined</span></dd>
</dl>
</div>
</div>
<dl class="tacn">
<dt id="coq:tacn.fix">
<code class="descname"><span class="notation"><span>fix</span> <span>ident</span> <span>num</span></span></code><a class="headerlink" href="#coq:tacn.fix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic is a primitive tactic to start a proof by induction. In
general, it is easier to rely on higher-level induction tactics such
as the ones described in <a class="reference internal" href="#coq:tacn.induction" title="induction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">induction</span></code></a>.</p>
<p>In the syntax of the tactic, the identifier <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the name given to
the induction hypothesis. The natural number <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> tells on which
premise of the current goal the induction acts, starting from 1,
counting both dependent and non dependent products, but skipping local
definitions. Especially, the current lemma must be composed of at
least <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> products.</p>
<p>Like in a fix expression, the induction hypotheses have to be used on
structurally smaller arguments. The verification that inductive proof
arguments are correct is done only at the time of registering the
lemma in the environment. To know if the use of induction hypotheses
is correct at some time of the interactive development of a proof, use
the command <code class="docutils literal notranslate"><span class="pre">Guarded</span></code> (see Section <a class="reference internal" href="proof-handling.html#requestinginformation"><span class="std std-ref">Requesting information</span></a>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>fix</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>(ident</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">+</span></span> <span>[</span><span class="curlies">{<span>struct</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a>}</span><span>]</span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This starts a proof by mutual induction. The statements to be simultaneously
proved are respectively <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">binder</span></span> <span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">binder</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">type</span></span></code>.
The identifiers <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> are the names of the induction hypotheses. The identifiers
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> are the respective names of the premises on which the induction
is performed in the statements to be simultaneously proved (if not given, the
system tries to guess itself what they are).</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.cofix">
<code class="descname"><span class="notation"><span>cofix</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.cofix" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic starts a proof by coinduction. The identifier <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the
name given to the coinduction hypothesis. Like in a cofix expression,
the use of induction hypotheses have to guarded by a constructor. The
verification that the use of co-inductive hypotheses is correct is
done only at the time of registering the lemma in the environment. To
know if the use of coinduction hypotheses is correct at some time of
the interactive development of a proof, use the command <code class="docutils literal notranslate"><span class="pre">Guarded</span></code>
(see Section <a class="reference internal" href="proof-handling.html#requestinginformation"><span class="std std-ref">Requesting information</span></a>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cofix</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-binder"><span class="hole">binder</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-type"><span class="hole">type</span></a><span>)</span></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This starts a proof by mutual coinduction. The statements to be
simultaneously proved are respectively <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">binder</span></span> <span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">binder</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">type</span></span></code>
The identifiers <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> are the names of the coinduction hypotheses.</p>
</dd></dl>

</div>
<div class="section" id="rewriting-expressions">
<span id="rewritingexpressions"></span><h2>Rewriting expressions<a class="headerlink" href="#rewriting-expressions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>These tactics use the equality <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code> defined in
file <code class="docutils literal notranslate"><span class="pre">Logic.v</span></code> (see <a class="reference internal" href="../language/coq-library.html#coq-library-logic"><span class="std std-ref">Logic</span></a>). The notation for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">T</span></span> <span class="name"><span class="pre">t</span></span> <span class="name"><span class="pre">u</span></span></code> is
simply <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code> dropping the implicit type of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span></code>.</p>
<dl class="tacn">
<dt id="coq:tacn.rewrite">
<code class="descname"><span class="notation"><span>rewrite</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.rewrite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> must have the form</p>
<p><code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(x</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">:A</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">)</span> <span class="pre">...</span> <span class="pre">(x</span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="pre">:A</span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="pre">).</span> <span class="pre">eq</span> <span class="pre">term</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">term</span></code><sub>2</sub> <code class="docutils literal notranslate"><span class="pre">.</span></code></p>
<p>where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span></code> is the Leibniz equality or a registered setoid equality.</p>
<p>Then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> finds the first subterm matching <cite>term</cite><sub>1</sub> in the goal,
resulting in instances <cite>term</cite><sub>1</sub>' and <cite>term</cite><sub>2</sub>' and then
replaces every occurrence of <cite>term</cite><sub>1</sub>' by <cite>term</cite><sub>2</sub>'.
Hence, some of the variables <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span></code><sub>i</sub> are solved by unification,
and some of the types <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code><sub>1</sub><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">...,</span></span> <span class="name"><span class="pre">A</span></span></code><sub>n</sub> become new
subgoals.</p>
<dl class="exn">
<dt id="coq:exn.the-term-provided-does-not-end-with-an-equation">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>provided</span> <span>does</span> <span>not</span> <span>end</span> <span>with</span> <span>an</span> <span>equation.</span></span></code><a class="headerlink" href="#coq:exn.the-term-provided-does-not-end-with-an-equation" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.tactic-generated-a-subgoal-identical-to-the-original-goal-this-happens-if-term-does-not-occur-in-the-goal">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Tactic</span> <span>generated</span> <span>a</span> <span>subgoal</span> <span>identical</span> <span>to</span> <span>the</span> <span>original</span> <span>goal.</span> <span>This</span> <span>happens</span> <span>if</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>does</span> <span>not</span> <span>occur</span> <span>in</span> <span>the</span> <span>goal.</span></span></code><a class="headerlink" href="#coq:exn.tactic-generated-a-subgoal-identical-to-the-original-goal-this-happens-if-term-does-not-occur-in-the-goal" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>rewrite</span> <span>-&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>rewrite</span> <span>&lt;-</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Uses the equality <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> <sub>2</sub> from right to left</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>rewrite</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <span>clause</span></span></code></dt>
<dd><p>Analogous to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but rewriting is done following clause
(similarly to <a class="reference internal" href="#performingcomputations"><span class="std std-ref">performing computations</span></a>). For instance:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H</span></span></span></code><sub>1</sub> will rewrite <cite>H</cite> in the hypothesis
<cite>H</cite><sub>1</sub> instead of the current goal.</li>
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H</span></span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">at</span></span> <span class="literal number integer"><span class="pre">1</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">H</span></span></code><sub>2</sub> <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">at</span></span> <span class="operator"><span class="pre">-</span></span> <span class="literal number integer"><span class="pre">2</span></span> <span class="operator"><span class="pre">|-</span></span> <span class="operator"><span class="pre">*</span></span></code> means
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H;</span></span> <span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H</span></span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">at</span></span> <span class="literal number integer"><span class="pre">1</span></span><span class="operator"><span class="pre">;</span></span> <span class="keyword"><span class="pre">rewrite</span></span> <span class="name"><span class="pre">H</span></span> <span class="keyword"><span class="pre">in</span></span> <span class="name"><span class="pre">H</span></span></code><sub>2</sub> <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">at</span></span> <span class="operator"><span class="pre">-</span></span> <span class="literal number integer"><span class="pre">2</span></span><span class="operator"><span class="pre">.</span></span></code>
In particular a failure will happen if any of these three simpler tactics
fails.</li>
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span> <span><span class="pre">|-</span></span></span></code> will do <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">H</span></span></span></code><sub>i</sub> for all hypotheses
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code><sub>i</sub> different from <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code>.
A success will happen as soon as at least one of these simpler tactics succeeds.</li>
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span></span></code> is a combination of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">H</span></span> <span><span class="pre">in</span></span> <span><span class="pre">*</span></span> <span><span class="pre">|-</span></span></span></code>
that succeeds if at least one of these two tactics succeeds.</li>
</ul>
<p>Orientation <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">-&gt;</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">&lt;-</span></span></code> can be inserted before the <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to rewrite.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>rewrite</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>at</span> <span>occurrences</span></span></code></dt>
<dd><p>Rewrite only the given occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. Occurrences are
specified from left to right as for pattern (<a class="reference internal" href="#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a>). The rewrite is
always performed using setoid rewriting, even for Leibniz’s equality, so one
has to <code class="docutils literal notranslate"><span class="pre">Import</span> <span class="pre">Setoid</span></code> to use this variant.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>rewrite</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>by</span> <span>tactic</span></span></code></dt>
<dd><p>Use tactic to completely solve the side-conditions arising from the
<a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Is equivalent to the <cite>n</cite> successive tactics <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span><span class="pre">rewrite</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">;</span></span></span></span></code>, each one
working on the first subgoal generated by the previous one. Orientation
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">-&gt;</span></span></code> or <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">&lt;-</span></span></code> can be inserted before each <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to rewrite.  One
unique clause can be added at the end after the keyword in; it will then
affect all rewrite operations.</p>
</dd></dl>

<p>In all forms of rewrite described above, a <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> to rewrite can be
immediately prefixed by one of the following modifiers:</p>
<ul class="simple">
<li><cite>?</cite> : the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <span><span class="pre">?</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> performs the rewrite of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> as many
times as possible (perhaps zero time). This form never fails.</li>
<li><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a><span><span class="pre">?</span></span></span></code> : works similarly, except that it will do at most <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> rewrites.</li>
<li><cite>!</cite> : works as <cite>?</cite>, except that at least one rewrite should succeed, otherwise
the tactic fails.</li>
<li><code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a><span><span class="pre">!</span></span></span></code> (or simply <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>) : precisely <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> rewrites of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> will be done,
leading to failure if these <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> rewrites are not possible.</li>
</ul>
<dl class="tacv">
<dt id="coq:tacv.erewrite">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>erewrite</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.erewrite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic works as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">rewrite</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but turning
unresolved bindings into existential variables, if any, instead of
failing. It has the same variants as <a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> has.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.replace">
<code class="descname"><span class="notation"><span>replace</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>’</span></span></code><a class="headerlink" href="#coq:tacn.replace" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. It replaces all free occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
in the current goal with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> and generates an equality <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code>
as a subgoal. This equality is automatically solved if it occurs among
the assumptions, or if its symmetric form occurs. It is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cut</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’;</span></span> <span><span class="pre">[intro</span></span> <span><span class="pre">H</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">;</span></span> <span><span class="pre">rewrite</span></span> <span><span class="pre">&lt;-</span></span> <span><span class="pre">H</span></span></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">;</span></span> <span><span class="pre">clear</span></span> <span><span class="pre">H</span></span></span></code><sub>n</sub><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">||</span></span> <span><span class="pre">assumption</span></span> <span><span class="pre">||</span></span> <span><span class="pre">symmetry;</span></span> <span><span class="pre">try</span></span> <span><span class="pre">assumption]</span></span></span></code>.</p>
<dl class="exn">
<dt id="coq:exn.terms-do-not-have-convertible-types">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Terms</span> <span>do</span> <span>not</span> <span>have</span> <span>convertible</span> <span>types.</span></span></code><a class="headerlink" href="#coq:exn.terms-do-not-have-convertible-types" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>replace</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>’</span> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This acts as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">replace</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">with</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> but applies <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> to solve the generated
subgoal <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>replace</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> using the first assumption whose type has
the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>replace</span> <span>-&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> using the first assumption whose type has
the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code></p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>replace</span> <span>&lt;-</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> using the first assumption whose type has
the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>replace</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>in</span> <span>clause</span> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>replace</span> <span>-&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <span>clause</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>replace</span> <span>&lt;-</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <span>clause</span></span></code></dt>
<dd><p>Acts as before but the replacements take place in the specified clause (see
<a class="reference internal" href="#performingcomputations"><span class="std std-ref">Performing computations</span></a>) and not only in the conclusion of the goal. The
clause argument must not contain any <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">of</span></code> nor <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">of</span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.cutrewrite">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cutrewrite</span> <span>&lt;-</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>’)</span></span></code><a class="headerlink" href="#coq:tacv.cutrewrite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic is deprecated. It can be replaced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’)</span></span> <span><span class="pre">as</span></span> <span><span class="pre">&lt;-</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cutrewrite</span> <span>-&gt;</span> <span>(</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>’)</span></span></code></dt>
<dd><p>This tactic is deprecated. It can be replaced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">enough</span></span> <span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’)</span></span> <span><span class="pre">as</span></span> <span><span class="pre">-&gt;</span></span></span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.subst">
<code class="descname"><span class="notation"><span>subst</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.subst" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to a goal that has <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in its context and (at
least) one hypothesis, say <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code>, of type <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> not occurring in <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>. Then it replaces <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> by
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> everywhere in the goal (in the hypotheses and in the conclusion) and
clears <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> from the context.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is a local definition of the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">t</span></span></span></code>, it is also
unfolded and cleared.</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<ul class="last simple">
<li>When several hypotheses have the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, the
first one is used.</li>
<li>If <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">H</span></span></code> is itself dependent in the goal, it is replaced by the proof of
reflexivity of equality.</li>
</ul>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>subst</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">subst</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>1</sub><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">;</span></span> <span><span class="pre">...;</span></span> <span><span class="pre">subst</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>n</sub>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>subst</span></span></code></dt>
<dd><p>This applies subst repeatedly from top to bottom to all identifiers of the
context for which an equality of the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">t</span></span></span></code> exists, with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> not occurring in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.regular-subst-tactic">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Regular</span> <span>Subst</span> <span>Tactic</span></span></code><a class="headerlink" href="#coq:flag.regular-subst-tactic" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option controls the behavior of <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>. When it is
activated (it is by default), <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a> also deals with the following corner cases:</p>
<ul class="simple">
<li>A context with ordered hypotheses <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>2</sub>
and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">t</span></span></span></code>, or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t′</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>1`</sub> with <cite>t′</cite> not
a variable, and no other hypotheses of the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>2</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">u</span></span></span></code>
or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">u</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>2</sub>; without the option, a second call to
subst would be necessary to replace <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>2</sub> by <cite>t</cite> or
<cite>t′</cite> respectively.</li>
<li>The presence of a recursive equation which without the option would
be a cause of failure of <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>.</li>
<li>A context with cyclic dependencies as with hypotheses <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">f</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>2</sub>
and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>2</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span></span> <span><span class="pre">g</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code><sub>1</sub> which without the
option would be a cause of failure of <a class="reference internal" href="#coq:tacn.subst" title="subst"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">subst</span></code></a>.</li>
</ul>
<p>Additionally, it prevents a local definition such as <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <span><span class="pre">t</span></span></span></code> to be
unfolded which otherwise it would exceptionally unfold in configurations
containing hypotheses of the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">=</span></span> <span><span class="pre">u</span></span></span></code>, or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">u′</span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
with <cite>u′</cite> not a variable. Finally, it preserves the initial order of
hypotheses, which without the option it may break.
default.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.stepl">
<code class="descname"><span class="notation"><span>stepl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.stepl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic is for chaining rewriting steps. It assumes a goal of the
form <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">R</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="pre">R</span></code> is a binary relation and relies on a
database of lemmas of the form <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">z</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">z</span></span> <span class="name"><span class="pre">y</span></span></code>
where <cite>eq</cite> is typically a setoid equality. The application of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">stepl</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
then replaces the goal by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">R</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and adds a new goal stating
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">eq</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<dl class="cmd">
<dt id="coq:cmd.declare-left-step">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Declare</span> <span>Left</span> <span>Step</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.declare-left-step" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> to the database used by <a class="reference internal" href="#coq:tacn.stepl" title="stepl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">stepl</span></code></a>.</p>
</dd></dl>

<p>This tactic is especially useful for parametric setoids which are not accepted
as regular setoids for <a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> and <a class="reference internal" href="../addendum/generalized-rewriting.html#coq:tacv.setoid-replace" title="setoid_replace"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">setoid_replace</span></code></a> (see
<a class="reference internal" href="../addendum/generalized-rewriting.html#generalizedrewriting"><span class="std std-ref">Generalized rewriting</span></a>).</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>stepl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>This applies <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">stepl</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> then applies <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> to the second goal.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.stepr">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>stepr</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>stepr</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>by</span> <span>tactic</span></span></code><a class="headerlink" href="#coq:tacv.stepr" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This behaves as <a class="reference internal" href="#coq:tacn.stepl" title="stepl"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">stepl</span></code></a> but on the right-hand-side of the binary
relation. Lemmas are expected to be of the form
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span><span class="operator"><span class="pre">,</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">eq</span></span> <span class="name"><span class="pre">y</span></span> <span class="name"><span class="pre">z</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">R</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">z</span></span></code>.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.declare-right-step">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Declare</span> <span>Right</span> <span>Step</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmd.declare-right-step" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> to the database used by <a class="reference internal" href="#coq:tacv.stepr" title="stepr"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">stepr</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.change">
<code class="descname"><span class="notation"><span>change</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.change" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. It implements the rule <code class="docutils literal notranslate"><span class="pre">Conv</span></code> given in
<a class="reference internal" href="../language/cic.html#subtyping-rules"><span class="std std-ref">Subtyping rules</span></a>. <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">change</span></span> <span class="name"><span class="pre">U</span></span></code> replaces the current goal <cite>T</cite>
with <cite>U</cite> providing that <cite>U</cite> is well-formed and that <cite>T</cite> and <cite>U</cite> are
convertible.</p>
<dl class="exn">
<dt id="coq:exn.not-convertible">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>convertible.</span></span></code><a class="headerlink" href="#coq:exn.not-convertible" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>change</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>’</span></span></code></dt>
<dd><p>This replaces the occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> in the current goal.
The term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> must be convertible.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>change</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>’</span></span></code></dt>
<dd><p>This replaces the occurrences numbered <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code>
in the current goal. The terms <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">’</span></span></span></code> must be convertible.</p>
<dl class="exn">
<dt id="coq:exn.too-few-occurrences">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Too</span> <span>few</span> <span>occurrences.</span></span></code><a class="headerlink" href="#coq:exn.too-few-occurrences" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>change</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This applies the <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a> tactic not to the goal but to the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#performingcomputations"><span class="std std-ref">Performing computations</span></a></p>
</div>
</dd></dl>

</div>
<div class="section" id="performing-computations">
<span id="performingcomputations"></span><h2>Performing computations<a class="headerlink" href="#performing-computations" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>This set of tactics implements different specialized usages of the
tactic <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a>.</p>
<p>All conversion tactics (including <a class="reference internal" href="#coq:tacn.change" title="change"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">change</span></code></a>) can be parameterized by the
parts of the goal where the conversion can occur. This is done using
<em>goal clauses</em> which consists in a list of hypotheses and, optionally,
of a reference to the conclusion of the goal. For defined hypothesis
it is possible to specify if the conversion should occur on the type
part, the body part or both (default).</p>
<p>Goal clauses are written after a conversion tactic (tactics <a class="reference internal" href="#coq:tacn.set" title="set"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">set</span></code></a>,
<a class="reference internal" href="#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>, <a class="reference internal" href="#coq:tacn.replace" title="replace"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">replace</span></code></a> and <a class="reference internal" href="#coq:tacn.autorewrite" title="autorewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">autorewrite</span></code></a> also use goal
clauses) and are introduced by the keyword <cite>in</cite>. If no goal clause is
provided, the default is to perform the conversion only in the
conclusion.</p>
<p>The syntax and description of the various goal clauses is the
following:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">|-</span></span></span></code>  only in hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code></li>
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">|-</span></span> <span><span class="pre">*</span></span></span></code> in hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> and in the
conclusion</li>
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span><span class="pre">*</span></span> <span><span class="pre">|-</span></span></span></code> in every hypothesis</li>
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span><span class="pre">*</span></span></span></code> (equivalent to in <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">*</span></span> <span><span class="pre">|-</span></span> <span><span class="pre">*</span></span></span></code>) everywhere</li>
<li><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span><span class="pre">(type</span></span> <span><span class="pre">of</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">)</span></span> <span><span class="pre">(value</span></span> <span><span class="pre">of</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">)</span></span> <span><span class="pre">...</span></span> <span><span class="pre">|-</span></span></span></code> in type part of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, in the value part of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>, etc.</li>
</ul>
<p>For backward compatibility, the notation <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">in</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> performs
the conversion in hypotheses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
<dl class="tacn">
<dt id="coq:tacn.cbv">
<code class="descname"><span class="notation"><span>cbv</span> <span class="repeat-wrapper"><span class="repeat"><span>flag</span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.cbv" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.lazy">
<code class="descname"><span class="notation"><span>lazy</span> <span class="repeat-wrapper"><span class="repeat"><span>flag</span></span><span class="notation-sup">*</span></span></span></code><a class="headerlink" href="#coq:tacn.lazy" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.compute">
<code class="descname"><span class="notation"><span>compute</span></span></code><a class="headerlink" href="#coq:tacn.compute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These parameterized reduction tactics apply to any goal and perform
the normalization of the goal according to the specified flags. In
correspondence with the kinds of reduction considered in Coq namely
<span class="math notranslate">\(\beta\)</span> (reduction of functional application), <span class="math notranslate">\(\delta\)</span>
(unfolding of transparent constants, see <a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>),
<span class="math notranslate">\(\iota\)</span> (reduction of
pattern matching over a constructed term, and unfolding of <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fix</span></span></code> and
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">cofix</span></span></code> expressions) and <span class="math notranslate">\(\zeta\)</span> (contraction of local definitions), the
flags are either <code class="docutils literal notranslate"><span class="pre">beta</span></code>, <code class="docutils literal notranslate"><span class="pre">delta</span></code>, <code class="docutils literal notranslate"><span class="pre">match</span></code>, <code class="docutils literal notranslate"><span class="pre">fix</span></code>, <code class="docutils literal notranslate"><span class="pre">cofix</span></code>,
<code class="docutils literal notranslate"><span class="pre">iota</span></code> or <code class="docutils literal notranslate"><span class="pre">zeta</span></code>. The <code class="docutils literal notranslate"><span class="pre">iota</span></code> flag is a shorthand for <code class="docutils literal notranslate"><span class="pre">match</span></code>, <code class="docutils literal notranslate"><span class="pre">fix</span></code>
and <code class="docutils literal notranslate"><span class="pre">cofix</span></code>. The <code class="docutils literal notranslate"><span class="pre">delta</span></code> flag itself can be refined into
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">delta</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> or <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">delta</span></span> <span><span class="pre">-</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>, restricting in the first
case the constants to unfold to the constants listed, and restricting in the
second case the constant to unfold to all but the ones explicitly mentioned.
Notice that the <code class="docutils literal notranslate"><span class="pre">delta</span></code> flag does not apply to variables bound by a let-in
construction inside the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> itself (use here the <code class="docutils literal notranslate"><span class="pre">zeta</span></code> flag). In
any cases, opaque constants are not unfolded (see <a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>).</p>
<p>Normalization according to the flags is done by first evaluating the
head of the expression into a <em>weak-head</em> normal form, i.e. until the
evaluation is blocked by a variable (or an opaque constant, or an
axiom), as e.g. in <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">u1</span></span> <span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">un</span></span></code> , or <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">match</span></span> <span class="name"><span class="pre">x</span></span> <span class="keyword"><span class="pre">with</span></span> <span class="operator"><span class="pre">...</span></span> <span class="keyword"><span class="pre">end</span></span></code>, or
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">fix</span></span> <span class="name"><span class="pre">f</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">{</span></span><span class="keyword"><span class="pre">struct</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">}</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="operator"><span class="pre">...)</span></span> <span class="name"><span class="pre">x</span></span></code>, or is a constructed form (a
<span class="math notranslate">\(\lambda\)</span>-expression, a constructor, a cofixpoint, an inductive type, a
product type, a sort), or is a redex that the flags prevent to reduce. Once a
weak-head normal form is obtained, subterms are recursively reduced using the
same strategy.</p>
<p>Reduction to weak-head normal form can be done using two strategies:
<em>lazy</em> (<code class="docutils literal notranslate"><span class="pre">lazy</span></code> tactic), or <em>call-by-value</em> (<code class="docutils literal notranslate"><span class="pre">cbv</span></code> tactic). The lazy
strategy is a call-by-need strategy, with sharing of reductions: the
arguments of a function call are weakly evaluated only when necessary,
and if an argument is used several times then it is weakly computed
only once. This reduction is efficient for reducing expressions with
dead code. For instance, the proofs of a proposition <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">exists</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">.</span></span> <span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span></code>
reduce to a pair of a witness <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>, and a proof that <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> satisfies the
predicate <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span></code>. Most of the time, <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code> may be computed without computing
the proof of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, thanks to the lazy strategy.</p>
<p>The call-by-value strategy is the one used in ML languages: the
arguments of a function call are systematically weakly evaluated
first. Despite the lazy strategy always performs fewer reductions than
the call-by-value strategy, the latter is generally more efficient for
evaluating purely computational expressions (i.e. with little dead code).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>compute</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cbv</span></span></code></dt>
<dd><p>These are synonyms for <code class="docutils literal notranslate"><span class="pre">cbv</span> <span class="pre">beta</span> <span class="pre">delta</span> <span class="pre">iota</span> <span class="pre">zeta</span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>lazy</span></span></code></dt>
<dd><p>This is a synonym for <code class="docutils literal notranslate"><span class="pre">lazy</span> <span class="pre">beta</span> <span class="pre">delta</span> <span class="pre">iota</span> <span class="pre">zeta</span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>compute</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cbv</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>These are synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbv</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>compute</span> <span>-</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cbv</span> <span>-</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>These are synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbv</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">-</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>lazy</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>lazy</span> <span>-</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>These are respectively synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">lazy</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">lazy</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">-</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.vm-compute">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>vm</span><span>_</span><span>compute</span></span></code><a class="headerlink" href="#coq:tacv.vm-compute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic evaluates the goal using the optimized call-by-value evaluation
bytecode-based virtual machine described in <a class="reference internal" href="../zebibliography.html#compiledstrongreduction" id="id8">[GregoireL02]</a>.
This algorithm is dramatically more efficient than the algorithm used for the
<code class="docutils literal notranslate"><span class="pre">cbv</span></code> tactic, but it cannot be fine-tuned. It is specially interesting for
full evaluation of algebraic objects. This includes the case of
reflection-based tactics.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.native-compute">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>native</span><span>_</span><span>compute</span></span></code><a class="headerlink" href="#coq:tacv.native-compute" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic evaluates the goal by compilation to Objective Caml as described
in <a class="reference internal" href="../zebibliography.html#fullreduction" id="id9">[BDenesGregoire11]</a>. If Coq is running in native code, it can be
typically two to five times faster than <code class="docutils literal notranslate"><span class="pre">vm_compute</span></code>. Note however that the
compilation cost is higher, so it is worth using only for intensive
computations.</p>
<dl class="flag">
<dt id="coq:flag.nativecompute-profiling">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>NativeCompute</span> <span>Profiling</span></span></code><a class="headerlink" href="#coq:flag.nativecompute-profiling" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>On Linux, if you have the <code class="docutils literal notranslate"><span class="pre">perf</span></code> profiler installed, this option makes
it possible to profile <code class="docutils literal notranslate"><span class="pre">native_compute</span></code> evaluations.</p>
</dd></dl>

<dl class="opt">
<dt id="coq:opt.nativecompute-profile-filename">
<em class="property"><span class="sigannot">Option</span></em> <code class="descname"><span class="notation"><span>NativeCompute</span> <span>Profile</span> <span>Filename</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code><a class="headerlink" href="#coq:opt.nativecompute-profile-filename" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option specifies the profile output; the default is
<code class="docutils literal notranslate"><span class="pre">native_compute_profile.data</span></code>. The actual filename used
will contain extra characters to avoid overwriting an existing file; that
filename is reported to the user.
That means you can individually profile multiple uses of
<code class="docutils literal notranslate"><span class="pre">native_compute</span></code> in a script. From the Linux command line, run <code class="docutils literal notranslate"><span class="pre">perf</span> <span class="pre">report</span></code>
on the profile file to see the results. Consult the <code class="docutils literal notranslate"><span class="pre">perf</span></code> documentation
for more details.</p>
</dd></dl>

</dd></dl>

<dl class="flag">
<dt id="coq:flag.debug-cbv">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Debug</span> <span>Cbv</span></span></code><a class="headerlink" href="#coq:flag.debug-cbv" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option makes <a class="reference internal" href="#coq:tacn.cbv" title="cbv"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbv</span></code></a> (and its derivative <a class="reference internal" href="#coq:tacn.compute" title="compute"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">compute</span></code></a>) print
information about the constants it encounters and the unfolding decisions it
makes.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.red">
<code class="descname"><span class="notation"><span>red</span></span></code><a class="headerlink" href="#coq:tacn.red" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to a goal that has the form:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall (x:T1) ... (xk:Tk), T
</pre></div>
</div>
<p>with <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span><span class="math notranslate">\(\zeta\)</span>-reducing to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>n</sub> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> a
constant. If <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> is transparent then it replaces <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">c</span></span></code> with its
definition (say <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>) and then reduces
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>n</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span></code> according to <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span><span class="math notranslate">\(\zeta\)</span>-reduction rules.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.not-reducible">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>reducible.</span></span></code><a class="headerlink" href="#coq:exn.not-reducible" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.no-head-constant-to-reduce">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>head</span> <span>constant</span> <span>to</span> <span>reduce.</span></span></code><a class="headerlink" href="#coq:exn.no-head-constant-to-reduce" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.hnf">
<code class="descname"><span class="notation"><span>hnf</span></span></code><a class="headerlink" href="#coq:tacn.hnf" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. It replaces the current goal with its
head normal form according to the <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\delta\)</span><span class="math notranslate">\(\iota\)</span><span class="math notranslate">\(\zeta\)</span>-reduction rules, i.e. it
reduces the head of the goal until it becomes a product or an
irreducible term. All inner <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span>-redexes are also reduced.</p>
<p>Example: The term <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">n</span></span> <span class="operator"><span class="pre">:</span></span> <span class="keyword type"><span class="pre">nat</span></span> <span class="operator"><span class="pre">=&gt;</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span> <span class="operator"><span class="pre">+</span></span> <span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">n</span></span></code> is not reduced by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">hnf</span></span></span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">The <span class="math notranslate">\(\delta\)</span> rule only applies to transparent constants (see <a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>
on transparency and opacity).</p>
</div>
<dl class="tacn">
<dt id="coq:tacn.cbn">
<code class="descname"><span class="notation"><span>cbn</span></span></code><a class="headerlink" href="#coq:tacn.cbn" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.simpl">
<code class="descname"><span class="notation"><span>simpl</span></span></code><a class="headerlink" href="#coq:tacn.simpl" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>These tactics apply to any goal. They try to reduce a term to
something still readable instead of fully normalizing it. They perform
a sort of strong normalization with two key differences:</p>
<ul class="simple">
<li>They unfold a constant if and only if it leads to a <span class="math notranslate">\(\iota\)</span>-reduction,
i.e. reducing a match or unfolding a fixpoint.</li>
<li>While reducing a constant unfolding to (co)fixpoints, the tactics
use the name of the constant the (co)fixpoint comes from instead of
the (co)fixpoint definition in recursive calls.</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">cbn</span></code> tactic is claimed to be a more principled, faster and more
predictable replacement for <code class="docutils literal notranslate"><span class="pre">simpl</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">cbn</span></code> tactic accepts the same flags as <code class="docutils literal notranslate"><span class="pre">cbv</span></code> and <code class="docutils literal notranslate"><span class="pre">lazy</span></code>. The
behavior of both <code class="docutils literal notranslate"><span class="pre">simpl</span></code> and <code class="docutils literal notranslate"><span class="pre">cbn</span></code> can be tuned using the
Arguments vernacular command as follows:</p>
<ul>
<li><p class="first">A constant can be marked to be never unfolded by <code class="docutils literal notranslate"><span class="pre">cbn</span></code> or <code class="docutils literal notranslate"><span class="pre">simpl</span></code>:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">minus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-tactic">simpl</span><span> </span><span class="coqdoc-var">never</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<p>After that command an expression like <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code> is left
untouched by the tactics <code class="docutils literal notranslate"><span class="pre">cbn</span></code> and <code class="docutils literal notranslate"><span class="pre">simpl</span></code>.</p>
</li>
<li><p class="first">A constant can be marked to be unfolded only if applied to enough
arguments. The number of arguments required can be specified using the
<code class="docutils literal notranslate"><span class="pre">/</span></code> symbol in the argument list of the <a class="reference internal" href="../language/gallina-extensions.html#coq:cmd.arguments" title="Arguments"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Arguments</span></code></a> vernacular command.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">fcomp</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">g</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">C</span><span> := </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">x</span><span>).</span></dt>
<dd><span class="first last">fcomp is defined</span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">fcomp</span><span> {</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span> </span><span class="coqdoc-var">C</span><span>} </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">x</span><span> /.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;f \o g&quot; := (</span><span class="coqdoc-var">fcomp</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">g</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 50).</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<p>After that command the expression <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">f</span></span> <span class="error"><span class="pre">\</span></span><span class="name"><span class="pre">o</span></span> <span class="name"><span class="pre">g</span></span><span class="operator"><span class="pre">)</span></span></code> is left untouched by
<code class="docutils literal notranslate"><span class="pre">simpl</span></code> while <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">((</span></span><span class="name"><span class="pre">f</span></span> <span class="error"><span class="pre">\</span></span><span class="name"><span class="pre">o</span></span> <span class="name"><span class="pre">g</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> is reduced to <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">f</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">g</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">))</span></span></code>.
The same mechanism can be used to make a constant volatile, i.e.
always unfolded.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">volatile</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> =&gt; </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first last">volatile is defined</span></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">volatile</span><span> / </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
</li>
<li><p class="first">A constant can be marked to be unfolded only if an entire set of
arguments evaluates to a constructor. The <code class="docutils literal notranslate"><span class="pre">!</span></code> symbol can be used to mark
such arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">minus</span><span> !</span><span class="coqdoc-var">n</span><span> !</span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<p>After that command, the expression <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code> is left untouched
by <code class="docutils literal notranslate"><span class="pre">simpl</span></code>, while <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">))</span></span></code> is reduced to <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>.</p>
</li>
<li><p class="first">A special heuristic to determine if a constant has to be unfolded
can be activated with the following command:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">minus</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-tactic">simpl</span><span> </span><span class="coqdoc-var">nomatch</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<p>The heuristic avoids to perform a simplification step that would expose a
match construct in head position. For example the expression
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">))</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">))</span></span></code> is simplified to <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">minus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">)</span></span></code>
even if an extra simplification is possible.</p>
</li>
</ul>
<p>In detail, the tactic <code class="docutils literal notranslate"><span class="pre">simpl</span></code> first applies <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span>-reduction. Then, it
expands transparent constants and tries to reduce further using <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span>-
reduction. But, when no <span class="math notranslate">\(\iota\)</span> rule is applied after unfolding then
<span class="math notranslate">\(\delta\)</span>-reductions are not applied. For instance trying to use <code class="docutils literal notranslate"><span class="pre">simpl</span></code> on
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">plus</span></span> <span class="name"><span class="pre">n</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">n</span></span></code> changes nothing.</p>
<p>Notice that only transparent constants whose name can be reused in the
recursive calls are possibly unfolded by <code class="docutils literal notranslate"><span class="pre">simpl</span></code>. For instance a
constant defined by <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">plus'</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="name"><span class="pre">plus</span></span></code> is possibly unfolded and reused in
the recursive calls, but a constant such as <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">succ</span></span> <span class="operator"><span class="pre">:=</span></span> <span class="name"><span class="pre">plus</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">O</span></span><span class="operator"><span class="pre">)</span></span></code> is
never unfolded. This is the main difference between <code class="docutils literal notranslate"><span class="pre">simpl</span></code> and <code class="docutils literal notranslate"><span class="pre">cbn</span></code>.
The tactic <code class="docutils literal notranslate"><span class="pre">cbn</span></code> reduces whenever it will be able to reuse it or not:
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">succ</span></span> <span class="name"><span class="pre">t</span></span></code> is reduced to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">S</span></span> <span class="name"><span class="pre">t</span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cbn</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>cbn</span> <span>-</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>These are respectively synonyms of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbn</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code>
and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">cbn</span></span> <span><span class="pre">beta</span></span> <span><span class="pre">delta</span></span> <span><span class="pre">-</span></span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">iota</span></span> <span><span class="pre">zeta</span></span></span></code> (see <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a></span></code></dt>
<dd><p>This applies <code class="docutils literal notranslate"><span class="pre">simpl</span></code> only to the subterms matching <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span></code> in the
current goal.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This applies <code class="docutils literal notranslate"><span class="pre">simpl</span></code> only to the <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> occurrences of the subterms
matching <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span></code> in the current goal.</p>
<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Too</span> <span>few</span> <span>occurrences.</span></span></code></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd><p>This applies <code class="docutils literal notranslate"><span class="pre">simpl</span></code> only to the applicative subterms whose head occurrence
is the unfoldable constant <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> (the constant can be referred to by
its notation using <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> if such a notation exists).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simpl</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This applies <code class="docutils literal notranslate"><span class="pre">simpl</span></code> only to the <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> applicative subterms whose
head occurrence is <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> (or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code>).</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.debug-rakam">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Debug</span> <span>RAKAM</span></span></code><a class="headerlink" href="#coq:flag.debug-rakam" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option makes <a class="reference internal" href="#coq:tacn.cbn" title="cbn"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">cbn</span></code></a> print various debugging information.
<code class="docutils literal notranslate"><span class="pre">RAKAM</span></code> is the Refolding Algebraic Krivine Abstract Machine.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.unfold">
<code class="descname"><span class="notation"><span>unfold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:tacn.unfold" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The argument qualid must denote a
defined transparent constant or local definition (see
<a class="reference internal" href="../language/gallina-specification-language.html#gallina-definitions"><span class="std std-ref">Definitions</span></a> and <a class="reference internal" href="vernacular-commands.html#vernac-controlling-the-reduction-strategies"><span class="std std-ref">Controlling the reduction strategies and the conversion algorithm</span></a>). The tactic
<code class="docutils literal notranslate"><span class="pre">unfold</span></code> applies the <span class="math notranslate">\(\delta\)</span> rule to each occurrence of the constant to which
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> refers in the current goal and then replaces it with its
<span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span>-normal form.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.qualid-does-not-denote-an-evaluable-constant">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>does</span> <span>not</span> <span>denote</span> <span>an</span> <span>evaluable</span> <span>constant.</span></span></code><a class="headerlink" href="#coq:exn.qualid-does-not-denote-an-evaluable-constant" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>unfold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>Replaces <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> in hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> with its definition
and replaces the hypothesis with its <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span> normal form.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>unfold</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Replaces <em>simultaneously</em> <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code> with their definitions and
replaces the current goal with its <span class="math notranslate">\(\beta\)</span><span class="math notranslate">\(\iota\)</span> normal form.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>unfold</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>The lists <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span><span class="notation-sub"><span class="pre">,</span></span></span></span></code> specify the occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> to be
unfolded. Occurrences are located from left to right.</p>
<dl class="exn">
<dt id="coq:exn.bad-occurrence-number-of-qualid">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Bad</span> <span>occurrence</span> <span>number</span> <span>of</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.bad-occurrence-number-of-qualid" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.qualid-does-not-occur">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>does</span> <span>not</span> <span>occur.</span></span></code><a class="headerlink" href="#coq:exn.qualid-does-not-occur" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>unfold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a></span></code></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> denotes the discriminating symbol of a notation (e.g. &quot;+&quot;) or
an expression defining a notation (e.g. <cite>&quot;_ + _&quot;</cite>), and this notation refers to an unfoldable constant, then the
tactic unfolds it.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>unfold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a><span>%key</span></span></code></dt>
<dd><p>This is variant of <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">unfold</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> gets its
interpretation from the scope bound to the delimiting key <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">key</span></span></span></code>
instead of its default interpretation (see <a class="reference internal" href="../user-extensions/syntax-extensions.html#localinterpretationrulesfornotations"><span class="std std-ref">Local interpretation rules for notations</span></a>).</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>unfold</span> <span class="repeat-wrapper"><span class="repeat"><span>qualid</span><span>_</span><span>or</span><span>_</span><span>string</span> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is the most general form, where <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">qualid</span></span><span><span class="pre">_</span></span><span><span class="pre">or</span></span><span><span class="pre">_</span></span><span><span class="pre">string</span></span></span></code> is either a
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> or a <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole"><span class="pre">string</span></span></a></span></code> referring to a notation.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.fold">
<code class="descname"><span class="notation"><span>fold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.fold" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. The term <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is reduced using the
<code class="docutils literal notranslate"><span class="pre">red</span></code> tactic. Every occurrence of the resulting <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> in the goal is
then replaced by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>fold</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Equivalent to <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">fold</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">;</span></span> <span><span class="pre">...</span></span> <span><span class="pre">;</span></span> <span><span class="pre">fold</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.pattern">
<code class="descname"><span class="notation"><span>pattern</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.pattern" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command applies to any goal. The argument <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> must be a free
subterm of the current goal. The command pattern performs <span class="math notranslate">\(\beta\)</span>-expansion
(the inverse of <span class="math notranslate">\(\beta\)</span>-reduction) of the current goal (say <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code>) by</p>
<ul class="simple">
<li>replacing all occurrences of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> in <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> with a fresh variable</li>
<li>abstracting this variable</li>
<li>applying the abstracted goal to <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code></li>
</ul>
<p>For instance, if the current goal <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">T</span></span></code> is expressible as
<span class="math notranslate">\(\varphi\)</span><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code> where the notation captures all the instances of <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code>
in <span class="math notranslate">\(\varphi\)</span><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pattern</span></span> <span><span class="pre">t</span></span></span></code> transforms it into
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">fun</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">=&gt;</span></span></code> <span class="math notranslate">\(\varphi\)</span><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">))</span></span> <span class="name"><span class="pre">t</span></span></code>. This tactic can be used, for
instance, when the tactic <code class="docutils literal notranslate"><span class="pre">apply</span></code> fails on matching.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pattern</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Only the occurrences <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> are considered for
<span class="math notranslate">\(\beta\)</span>-expansion. Occurrences are located from left to right.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pattern</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>at</span> <span>-</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>All occurrences except the occurrences of indexes <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>
of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> are considered for <span class="math notranslate">\(\beta\)</span>-expansion. Occurrences are located from
left to right.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pattern</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Starting from a goal <span class="math notranslate">\(\varphi\)</span><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>m</sub><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span></code>,
the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">pattern</span></span> <span><span class="pre">t</span></span></span></code><sub>1</sub><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">,</span></span> <span><span class="pre">...,</span></span> <span><span class="pre">t</span></span></span></code><sub>m</sub> generates the
equivalent goal
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">fun</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span></code><sub>1</sub><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span></code><sub>1</sub><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">...</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span></code><sub>m</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span></code><sub>m</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">=&gt;</span></span></code><span class="math notranslate">\(\varphi\)</span><code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">x</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">x</span></span></code><sub>m</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">))</span></span> <span class="name"><span class="pre">t</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">t</span></span></code><sub>m</sub>.
If <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span></code><sub>i</sub> occurs in one of the generated types <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">A</span></span></code><sub>j</sub> these
occurrences will also be considered and possibly abstracted.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pattern</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>at</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This behaves as above but processing only the occurrences <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> starting from <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pattern</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>at</span> <span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span><span class="notation-sup">?</span></span></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>This is the most general syntax that combines the different variants.</p>
</dd></dl>

<div class="section" id="conversion-tactics-applied-to-hypotheses">
<h3>Conversion tactics applied to hypotheses<a class="headerlink" href="#conversion-tactics-applied-to-hypotheses" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>conv</span><span>_</span><span>tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span><span class="notation-sub">,</span></span></span></code></dt>
<dd><p>Applies the conversion tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">conv</span></span><span><span class="pre">_</span></span><span><span class="pre">tactic</span></span></span></code> to the hypotheses
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>. The tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">conv</span></span><span><span class="pre">_</span></span><span><span class="pre">tactic</span></span></span></code> is any of the conversion tactics
listed in this section.</p>
<p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is a local definition, then <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> can be replaced by
(type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>) to address not the body but the type of the local
definition.</p>
<p>Example: <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">unfold</span></span> <span><span class="pre">not</span></span> <span><span class="pre">in</span></span> <span><span class="pre">(type</span></span> <span><span class="pre">of</span></span> <span><span class="pre">H1)</span></span> <span><span class="pre">(type</span></span> <span><span class="pre">of</span></span> <span><span class="pre">H3)</span></span></span></code>.</p>
</dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>such</span> <span>hypothesis:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code></dt>
<dd></dd></dl>

</div>
</div>
<div class="section" id="automation">
<span id="id10"></span><h2>Automation<a class="headerlink" href="#automation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.auto">
<code class="descname"><span class="notation"><span>auto</span></span></code><a class="headerlink" href="#coq:tacn.auto" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic implements a Prolog-like resolution procedure to solve the
current goal. It first tries to solve the goal using the assumption
tactic, then it reduces the goal to an atomic one using intros and
introduces the newly generated hypotheses as hints. Then it looks at
the list of tactics associated to the head symbol of the goal and
tries to apply one of them (starting from the tactics with lower
cost). This process is recursively applied to the generated subgoals.</p>
<p>By default, auto only uses the hypotheses of the current goal and the
hints of the database named core.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>auto</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>Forces the search depth to be <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>. The maximal search depth
is <cite>5</cite> by default.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>auto</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Uses the hint databases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> in addition to the database core. See
<a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The Hints Databases for auto and eauto</span></a> for the list of
pre-defined databases and the way to create or extend a database.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>auto</span> <span>with</span> <span>*</span></span></code></dt>
<dd><p>Uses all existing hint databases. See
<a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The Hints Databases for auto and eauto</span></a></p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>auto</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../addendum/generalized-rewriting.html#grammar-token-lemma"><span class="hole">lemma</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Uses <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../addendum/generalized-rewriting.html#grammar-token-lemma"><span class="hole"><span class="pre">lemma</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> in addition to hints (can be combined with the with
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> option).  If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../addendum/generalized-rewriting.html#grammar-token-lemma"><span class="hole"><span class="pre">lemma</span></span></a></span></code> is an inductive type, it is the
collection of its constructors which is added as hints.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>info</span><span>_</span><span>auto</span></span></code></dt>
<dd><p>Behaves like auto but shows the tactics it uses to solve the goal. This
variant is very useful for getting a better understanding of automation, or
to know what lemmas/assumptions were used.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.debug-auto">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>debug</span> <span>auto</span></span></code><a class="headerlink" href="#coq:tacv.debug-auto" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Behaves like <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> but shows the tactics it tries to solve the goal,
including failing paths.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>info</span><span>_</span></span><span class="notation-sup">?</span></span><span>auto</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../addendum/generalized-rewriting.html#grammar-token-lemma"><span class="hole">lemma</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>This is the most general form, combining the various options.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.trivial">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>trivial</span></span></code><a class="headerlink" href="#coq:tacv.trivial" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic is a restriction of auto that is not recursive
and tries only hints that cost <cite>0</cite>. Typically it solves trivial
equalities like <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">X</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">X</span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>trivial</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>trivial</span> <span>with</span> <span>*</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>trivial</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../addendum/generalized-rewriting.html#grammar-token-lemma"><span class="hole">lemma</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.debug-trivial">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>debug</span> <span>trivial</span></span></code><a class="headerlink" href="#coq:tacv.debug-trivial" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.info-trivial">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>info</span><span>_</span><span>trivial</span></span></code><a class="headerlink" href="#coq:tacv.info-trivial" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>info</span><span>_</span></span><span class="notation-sup">?</span></span><span>trivial</span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../addendum/generalized-rewriting.html#grammar-token-lemma"><span class="hole">lemma</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last"><a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> either solves completely the goal or else leaves it
intact. <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> and <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a> never fail.</p>
</div>
<p>The following options enable printing of informative or debug information for
the <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> and <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a> tactics:</p>
<dl class="flag">
<dt id="coq:flag.info-auto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Info</span> <span>Auto</span></span></code><a class="headerlink" href="#coq:flag.info-auto" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:flag.debug-auto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Debug</span> <span>Auto</span></span></code><a class="headerlink" href="#coq:flag.debug-auto" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:flag.info-trivial">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Info</span> <span>Trivial</span></span></code><a class="headerlink" href="#coq:flag.info-trivial" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:flag.debug-trivial">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Debug</span> <span>Trivial</span></span></code><a class="headerlink" href="#coq:flag.debug-trivial" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The Hints Databases for auto and eauto</span></a></p>
</div>
<dl class="tacn">
<dt id="coq:tacn.eauto">
<code class="descname"><span class="notation"><span>eauto</span></span></code><a class="headerlink" href="#coq:tacn.eauto" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic generalizes <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>. While <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> does not try
resolution hints which would leave existential variables in the goal,
<a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> does try them (informally speaking, it usessimple <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a>
where <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> uses simple <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>). As a consequence, <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a>
can solve such a goal:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Hint Resolve</span><span> </span><span class="coqdoc-var">ex_intro</span><span>.</span></dt>
<dd><span class="first">The hint </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ex_intro</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> will only be used by eauto, because applying </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ex_intro</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> would
leave variable x as unresolved existential variable.</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>, </span><span class="coqdoc-var">P</span><span> 0 -&gt; </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exists</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">eauto</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">ex_intro</span></code> should be declared as a hint.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>info</span><span>_</span></span><span class="notation-sup">?</span></span><span>eauto</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../addendum/generalized-rewriting.html#grammar-token-lemma"><span class="hole">lemma</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd><p>The various options for eauto are the same as for auto.</p>
</dd></dl>

<p><a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> also obeys the following options:</p>
<dl class="flag">
<dt id="coq:flag.info-eauto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Info</span> <span>Eauto</span></span></code><a class="headerlink" href="#coq:flag.info-eauto" title="この定義へのパーマリンク">¶</a></dt>
<dt id="coq:flag.debug-eauto">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Debug</span> <span>Eauto</span></span></code><a class="headerlink" href="#coq:flag.debug-eauto" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The Hints Databases for auto and eauto</span></a></p>
</div>
<dl class="tacn">
<dt id="coq:tacn.autounfold">
<code class="descname"><span class="notation"><span>autounfold</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.autounfold" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic unfolds constants that were declared through a <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Unfold</span></code>
in the given databases.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>autounfold</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>in</span> <span>clause</span></span></code></dt>
<dd><p>Performs the unfolding in the given clause.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>autounfold</span> <span>with</span> <span>*</span></span></code></dt>
<dd><p>Uses the unfold hints declared in all the hint databases.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.autorewrite">
<code class="descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.autorewrite" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic <a class="footnote-reference" href="#id19" id="id11">[4]</a> carries out rewritings according to the rewriting rule
bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
<p>Each rewriting rule from the base <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is applied to the main subgoal until
it fails. Once all the rules have been processed, if the main subgoal has
progressed (e.g., if it is distinct from the initial main goal) then the rules
of this base are processed again. If the main subgoal has not progressed then
the next base is processed. For the bases, the behavior is exactly similar to
the processing of the rewriting rules.</p>
<p>The rewriting rule bases are built with the <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Rewrite</span> <span class="pre">vernacular</span></code>
command.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">This tactic may loop if you build non terminating rewriting systems.</p>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>using</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Performs, in the same way, all the rewritings of the bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>
applying tactic to the main subgoal after each rewriting step.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code></dt>
<dd><p>Performs all the rewritings in hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span>using</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Performs all the rewritings in hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> applying <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code>
to the main subgoal after each rewriting step.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>autorewrite</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>in</span> <span class="hole">clause</span></span></code></dt>
<dd><p>Performs all the rewriting in the clause <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">clause</span></span></span></code>. The clause argument
must not contain any <code class="docutils literal notranslate"><span class="pre">type</span> <span class="pre">of</span></code> nor <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">of</span></code>.</p>
</dd></dl>

<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#hintrewrite"><span class="std std-ref">Hint-Rewrite</span></a> for feeding the database of lemmas used by
<a class="reference internal" href="#coq:tacn.autorewrite" title="autorewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">autorewrite</span></code></a> and <a class="reference internal" href="#coq:tacn.autorewrite" title="autorewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">autorewrite</span></code></a> for examples showing the use of this tactic.</p>
</div>
<dl class="tacn">
<dt id="coq:tacn.easy">
<code class="descname"><span class="notation"><span>easy</span></span></code><a class="headerlink" href="#coq:tacn.easy" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic tries to solve the current goal by a number of standard closing steps.
In particular, it tries to close the current goal using the closing tactics
<a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a>, <a class="reference internal" href="#coq:tacn.reflexivity" title="reflexivity"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">reflexivity</span></code></a>, <a class="reference internal" href="#coq:tacn.symmetry" title="symmetry"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">symmetry</span></code></a>, <a class="reference internal" href="#coq:tacn.contradiction" title="contradiction"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">contradiction</span></code></a>
and <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> of hypothesis.
If this fails, it tries introducing variables and splitting and-hypotheses,
using the closing tactics afterwards, and splitting the goal using
<a class="reference internal" href="#coq:tacv.split" title="split"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">split</span></code></a> and recursing.</p>
<p>This tactic solves goals that belong to many common classes; in particular, many cases of
unsatisfiable hypotheses, and simple equality goals are usually solved by this tactic.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.now">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>now</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacv.now" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Run <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> followed by <a class="reference internal" href="#coq:tacn.easy" title="easy"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">easy</span></code></a>. This is a notation for <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span><span><span class="pre">;</span></span> <span><span class="pre">easy</span></span></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="controlling-automation">
<h2>Controlling automation<a class="headerlink" href="#controlling-automation" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="the-hints-databases-for-auto-and-eauto">
<span id="thehintsdatabasesforautoandeauto"></span><h3>The hints databases for auto and eauto<a class="headerlink" href="#the-hints-databases-for-auto-and-eauto" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The hints for <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> and <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> are stored in databases. Each database
maps head symbols to a list of hints.</p>
<dl class="cmd">
<dt id="coq:cmd.print-hint">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Hint</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.print-hint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Use this command
to display the hints associated to the head symbol <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>
(see <a class="reference internal" href="#printhint"><span class="std std-ref">Print Hint</span></a>). Each hint has a cost that is a nonnegative
integer, and an optional pattern. The hints with lower cost are tried first. A
hint is tried by <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> when the conclusion of the current goal matches its
pattern or when it has no pattern.</p>
</dd></dl>

<div class="section" id="creating-hint-databases">
<h4>Creating Hint databases<a class="headerlink" href="#creating-hint-databases" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>One can optionally declare a hint database using the command
<a class="reference internal" href="#coq:cmd.create-hintdb" title="Create HintDb"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Create</span> <span class="pre">HintDb</span></code></a>. If a hint is added to an unknown database, it will be
automatically created.</p>
<dl class="cmd">
<dt id="coq:cmd.create-hintdb">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Create</span> <span>HintDb</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>discriminated</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.create-hintdb" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command creates a new database named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>. The database is
implemented by a Discrimination Tree (DT) that serves as an index of
all the lemmas. The DT can use transparency information to decide if a
constant should be indexed or not
(c.f. <a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">The hints databases for auto and eauto</span></a>),
making the retrieval more efficient. The legacy implementation (the default one
for new databases) uses the DT only on goals without existentials (i.e., <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a>
goals), for non-Immediate hints and does not make use of transparency
hints, putting more work on the unification that is run after
retrieval (it keeps a list of the lemmas in case the DT is not used).
The new implementation enabled by the discriminated option makes use
of DTs in all cases and takes transparency information into account.
However, the order in which hints are retrieved from the DT may differ
from the order in which they were inserted, making this implementation
observationally different from the legacy one.</p>
</dd></dl>

<p>The general command to add a hint to some databases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> is</p>
<dl class="cmd">
<dt id="coq:cmd.hint">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span class="hole">hint_definition</span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.hint" title="この定義へのパーマリンク">¶</a></dt>
<dd><dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span class="hole">hint_definition</span></span></code></dt>
<dd><p>No database name is given: the hint is registered in the core database.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Local</span> <span>Hint</span> <span class="hole">hint_definition</span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is used to declare hints that must not be exported to the other modules
that require and import the current module. Inside a section, the option
Local is useless since hints do not survive anyway to the closure of
sections.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Local</span> <span>Hint</span> <span class="hole">hint_definition</span></span></code></dt>
<dd><p>Idem for the core database.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.hint-resolve">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Resolve</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmdv.hint-resolve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command adds <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> to the hint list with the head
symbol of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. The cost of that hint is the number of
subgoals generated by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> if specified. The
associated <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span></code> is inferred from the conclusion of the type of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> or the given <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span></code> if specified. In case the inferred type
of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> does not start with a product the tactic added in the hint list
is <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">exact</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>. In case this type can however be reduced to a type
starting with a product, the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is also stored in
the hints list. If the inferred type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> contains a dependent
quantification on a variable which occurs only in the premisses of the type
and not in its conclusion, no instance could be inferred for the variable by
unification with the goal. In this case, the hint is added to the hint list
of <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> instead of the hint list of auto and a warning is printed. A
typical example of a hint that is used only by <a class="reference internal" href="#coq:tacn.eauto" title="eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eauto</span></code></a> is a transitivity
lemma.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.term-cannot-be-used-as-a-hint">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>cannot</span> <span>be</span> <span>used</span> <span>as</span> <span>a</span> <span>hint</span></span></code><a class="headerlink" href="#coq:exn.term-cannot-be-used-as-a-hint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The head symbol of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> is a bound variable such that
this tactic cannot be associated to a constant.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Resolve</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Hint</span></span> <span><span class="pre">Resolve</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Resolve</span> <span>-&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Adds the left-to-right implication of an equivalence as a hint (informally
the hint will be used as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">apply</span></span> <span><span class="pre">&lt;-</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, although as mentionned
before, the tactic actually used is a restricted version of
<a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a>).</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Resolve</span> <span>&lt;-</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd><p>Adds the right-to-left implication of an equivalence  as a hint.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.hint-immediate">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Immediate</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:cmdv.hint-immediate" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command adds <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">trivial</span></span></span></code> to the hint list associated
with the head symbol of the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the given database. This
tactic will fail if all the subgoals generated by <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simple</span></span> <span><span class="pre">apply</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> are
not solved immediately by the <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a> tactic (which only tries tactics
with cost 0).This command is useful for theorems such as the symmetry of
equality or <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">+</span></span><span class="literal number integer"><span class="pre">1</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">m</span></span><span class="operator"><span class="pre">+</span></span><span class="literal number integer"><span class="pre">1</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">n</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">m</span></span></code> that we may like to introduce with a limited
use in order to avoid useless proof-search. The cost of this tactic (which
never generates subgoals) is always 1, so that it is not used by <a class="reference internal" href="#coq:tacv.trivial" title="trivial"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">trivial</span></code></a>
itself.</p>
</dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>cannot</span> <span>be</span> <span>used</span> <span>as</span> <span>a</span> <span>hint</span></span></code></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Immediate</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Hint</span></span> <span><span class="pre">Immediate</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.hint-constructors">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Constructors</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmdv.hint-constructors" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is an inductive type, this command adds all its constructors as
hints of type <code class="docutils literal notranslate"><span class="pre">Resolve</span></code>. Then, when the conclusion of current goal has the form
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">(</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">...)</span></span></span></code>, <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> will try to apply each constructor.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.ident-is-not-an-inductive-type">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>is</span> <span>not</span> <span>an</span> <span>inductive</span> <span>type</span></span></code><a class="headerlink" href="#coq:exn.ident-is-not-an-inductive-type" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Constructors</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Hint</span></span> <span><span class="pre">Constructors</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.hint-unfold">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Unfold</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmdv.hint-unfold" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This adds the tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">unfold</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> to the hint list that will only be
used when the head constant of the goal is <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.
Its cost is 4.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Unfold</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds each <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">Hint</span></span> <span><span class="pre">Unfold</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.hint-transparent-opaque">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span class="meta">(</span> <span>Transparent</span> <span class="meta">|</span> <span>Opaque</span> <span class="meta">)</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#coq:cmdv.hint-transparent-opaque" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This adds a transparency hint to the database, making <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> a
transparent or opaque constant during resolution. This information is used
during unification of the goal with any lemma in the database and inside the
discrimination network to relax or constrain it in the case of discriminated
databases.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span class="meta">(</span> <span>Transparent</span> <span class="meta">|</span> <span>Opaque</span> <span class="meta">)</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Declares each <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> as a transparent or opaque constant.</p>
</dd></dl>

<dl class="cmdv">
<dt id="coq:cmdv.hint-extern">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Extern</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">?</span></span> <span>=&gt;</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:cmdv.hint-extern" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This hint type is to extend <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> with tactics other than <a class="reference internal" href="#coq:tacn.apply" title="apply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">apply</span></code></a> and
<a class="reference internal" href="#coq:tacn.unfold" title="unfold"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unfold</span></code></a>. For that, we must specify a cost, an optional <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a></span></code> and a
<code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> to execute.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Hint Extern</span><span> 4 (~(</span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">_</span><span>)) =&gt; </span><span class="coqdoc-tactic">discriminate</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p class="last">Now, when the head of the goal is a disequality, <code class="docutils literal notranslate"><span class="pre">auto</span></code> will try
discriminate if it does not manage to solve the goal with hints with a
cost less than 4.</p>
</div>
<p>One can even use some sub-patterns of the pattern in
the tactic script. A sub-pattern is a question mark followed by an
identifier, like <code class="docutils literal notranslate"><span class="pre">?X1</span></code> or <code class="docutils literal notranslate"><span class="pre">?X2</span></code>. Here is an example:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">List</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Hint Extern</span><span> 5 ({?</span><span class="coqdoc-var">X1</span><span> = ?</span><span class="coqdoc-var">X2</span><span>} + {?</span><span class="coqdoc-var">X1</span><span> &lt;&gt; ?</span><span class="coqdoc-var">X2</span><span>}) =&gt; </span><span class="coqdoc-tactic">generalize</span><span> </span><span class="coqdoc-var">X1</span><span>, </span><span class="coqdoc-var">X2</span><span>; </span><span class="coqdoc-var">decide</span><span> </span><span class="coqdoc-var">equality</span><span> : </span><span class="coqdoc-var">eqdec</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>:</span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>), {</span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">b</span><span>} + {</span><span class="coqdoc-var">a</span><span> &lt;&gt; </span><span class="coqdoc-var">b</span><span>}.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">+</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">Info</span><span> 1 </span><span class="coqdoc-tactic">auto</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">eqdec</span><span>.</span></dt>
<dd><span class="first last">&lt;ltac_plugin::auto&#64;0&gt; eqdec
No more subgoals.</span></dd>
</dl>
</div>
</div>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Cut</span> <span class="hole">regexp</span></span></code></dt>
<dd><div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">These hints currently only apply to typeclass proof search and the
<a class="reference internal" href="../addendum/type-classes.html#coq:tacn.typeclasses-eauto" title="typeclasses eauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">typeclasses</span> <span class="pre">eauto</span></code></a> tactic.</p>
</div>
<p>This command can be used to cut the proof-search tree according to a regular
expression matching paths to be cut. The grammar for regular expressions is
the following. Beware, there is no operator precedence during parsing, one can
check with <a class="reference internal" href="#coq:cmd.print-hintdb" title="Print HintDb"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Print</span> <span class="pre">HintDb</span></code></a> to verify the current cut expression:</p>
<pre>
<strong id="grammar-token-e">e</strong> ::=  ident      hint or instance identifier
      | _         any hint
      | e\|e′     disjunction
      | e e′      sequence
      | e *       Kleene star
      | emp       empty
      | eps       epsilon
      | ( e  )
</pre>
<p>The <cite>emp</cite> regexp does not match any search path while <cite>eps</cite>
matches the empty path. During proof search, the path of
successive successful hints on a search branch is recorded, as a
list of identifiers for the hints (note that Hint Extern’s do not have
an associated identifier).
Before applying any hint <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> the current path <cite>p</cite> extended with
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is matched against the current cut expression <cite>c</cite> associated to
the hint database. If matching succeeds, the hint is <em>not</em> applied. The
semantics of <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Cut</span> <span class="pre">e</span></code> is to set the cut expression to <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">|</span> <span class="pre">e</span></code>, the
initial cut expression being <cite>emp</cite>.</p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Mode</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a> <span class="repeat-wrapper"><span class="repeat"><span>(+</span> <span>|</span> <span>!</span> <span>|</span> <span>-)</span></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>This sets an optional mode of use of the identifier <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code>. When
proof-search faces a goal that ends in an application of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> to
arguments <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">...</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, the mode tells if the hints associated to
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> can be applied or not. A mode specification is a list of n <code class="docutils literal notranslate"><span class="pre">+</span></code>,
<code class="docutils literal notranslate"><span class="pre">!</span></code> or <code class="docutils literal notranslate"><span class="pre">-</span></code> items that specify if an argument of the identifier is to be
treated as an input (<code class="docutils literal notranslate"><span class="pre">+</span></code>), if its head only is an input (<code class="docutils literal notranslate"><span class="pre">!</span></code>) or an output
(<code class="docutils literal notranslate"><span class="pre">-</span></code>) of the identifier. For a mode to match a list of arguments, input
terms and input heads <em>must not</em> contain existential variables or be
existential variables respectively, while outputs can be any term. Multiple
modes can be declared for a single identifier, in that case only one mode
needs to match the arguments for the hints to be applied.The head of a term
is understood here as the applicative head, or the match or projection
scrutinee’s head, recursively, casts being ignored. <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Mode</span></code> is
especially useful for typeclasses, when one does not want to support default
instances and avoid ambiguity in general. Setting a parameter of a class as an
input forces proof-search to be driven by that index of the class, with <code class="docutils literal notranslate"><span class="pre">!</span></code>
giving more flexibility by allowing existentials to still appear deeper in the
index but not at its head.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">One can use an <code class="docutils literal notranslate"><span class="pre">Extern</span></code> hint with no pattern to do pattern matching on
hypotheses using <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">goal</span></code> with inside the tactic.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="hint-databases-defined-in-the-coq-standard-library">
<h3>Hint databases defined in the Coq standard library<a class="headerlink" href="#hint-databases-defined-in-the-coq-standard-library" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Several hint databases are defined in the Coq standard library. The
actual content of a database is the collection of hints declared
to belong to this database in each of the various modules currently
loaded. Especially, requiring new modules may extend the database.
At Coq startup, only the core database is nonempty and can be used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">core:</th><td class="field-body">This special database is automatically used by <code class="docutils literal notranslate"><span class="pre">auto</span></code>, except when
pseudo-database <code class="docutils literal notranslate"><span class="pre">nocore</span></code> is given to <code class="docutils literal notranslate"><span class="pre">auto</span></code>. The core database
contains only basic lemmas about negation, conjunction, and so on.
Most of the hints in this database come from the Init and Logic directories.</td>
</tr>
<tr class="field-even field"><th class="field-name">arith:</th><td class="field-body">This database contains all lemmas about Peano’s arithmetic proved in the
directories Init and Arith.</td>
</tr>
<tr class="field-odd field"><th class="field-name">zarith:</th><td class="field-body">contains lemmas about binary signed integers from the directories
theories/ZArith. When required, the module Omega also extends the
database zarith with a high-cost hint that calls <code class="docutils literal notranslate"><span class="pre">omega</span></code> on equations
and inequalities in <code class="docutils literal notranslate"><span class="pre">nat</span></code> or <code class="docutils literal notranslate"><span class="pre">Z</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">bool:</th><td class="field-body">contains lemmas about booleans, mostly from directory theories/Bool.</td>
</tr>
<tr class="field-odd field"><th class="field-name">datatypes:</th><td class="field-body">is for lemmas about lists, streams and so on that are mainly proved
in the Lists subdirectory.</td>
</tr>
<tr class="field-even field"><th class="field-name">sets:</th><td class="field-body">contains lemmas about sets and relations from the directories Sets and
Relations.</td>
</tr>
<tr class="field-odd field"><th class="field-name" colspan="2">typeclass_instances:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">contains all the typeclass instances declared in the
environment, including those used for <code class="docutils literal notranslate"><span class="pre">setoid_rewrite</span></code>,
from the Classes directory.</td>
</tr>
</tbody>
</table>
<p>You are advised not to put your own hints in the core database, but
use one or several databases specific to your development.</p>
<span class="target" id="removehints"></span><dl class="cmd">
<dt id="coq:cmd.remove-hints">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Remove</span> <span>Hints</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.remove-hints" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This command removes the hints associated to terms <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> in databases
<code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
<span class="target" id="printhint"></span><dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Hint</span></span></code></dt>
<dd></dd></dl>

<p>This command displays all hints that apply to the current goal. It
fails if no proof is being edited, while the two variants can be used
at every moment.</p>
<p><strong>Variants:</strong></p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Hint</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>This command displays only tactics associated with <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> in the hints
list. This is independent of the goal being edited, so this command will not
fail if no goal is being edited.</p>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Hint</span> <span>*</span></span></code></dt>
<dd><p>This command displays all declared hints.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.print-hintdb">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>HintDb</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.print-hintdb" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command displays all hints from database <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<span class="target" id="hintrewrite"></span><dl class="cmd">
<dt id="coq:cmd.hint-rewrite">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-rewrite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This vernacular command adds the terms <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> (their types must be
equalities) in the rewriting bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> with the default orientation
(left to right). Notice that the rewriting bases are distinct from the <code class="docutils literal notranslate"><span class="pre">auto</span></code>
hint bases and thatauto does not take them into account.</p>
<p>This command is synchronous with the section mechanism (see <a class="reference internal" href="../language/gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>):
when closing a section, all aliases created by <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Rewrite</span></code> in that
section are lost. Conversely, when loading a module, all <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Rewrite</span></code>
declarations at the global level of that module are loaded.</p>
</dd></dl>

<p><strong>Variants:</strong></p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span>-&gt;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This is strictly equivalent to the command above (we only make explicit the
orientation which otherwise defaults to -&gt;).</p>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span>&lt;-</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds the rewriting rules <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> with a right-to-left orientation in
the bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>.</p>
</dd></dl>

<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>Rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span> <span>using</span> <span>tactic</span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>When the rewriting rules <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> in <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> will be used, the
tactic <code class="docutils literal notranslate"><span class="pre">tactic</span></code> will be applied to the generated subgoals, the main subgoal
excluded.</p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.print-rewrite-hintdb">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Rewrite</span> <span>HintDb</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:cmd.print-rewrite-hintdb" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command displays all rewrite hints contained in <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

</div>
<div class="section" id="hint-locality">
<h3>Hint locality<a class="headerlink" href="#hint-locality" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Hints provided by the <code class="docutils literal notranslate"><span class="pre">Hint</span></code> commands are erased when closing a section.
Conversely, all hints of a module <code class="docutils literal notranslate"><span class="pre">A</span></code> that are not defined inside a
section (and not defined with option <code class="docutils literal notranslate"><span class="pre">Local</span></code>) become available when the
module <code class="docutils literal notranslate"><span class="pre">A</span></code> is imported (using e.g. <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">A.</span></code>).</p>
<p>As of today, hints only have a binary behavior regarding locality, as
described above: either they disappear at the end of a section scope,
or they remain global forever. This causes a scalability issue,
because hints coming from an unrelated part of the code may badly
influence another development. It can be mitigated to some extent
thanks to the <a class="reference internal" href="#coq:cmd.remove-hints" title="Remove Hints"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Remove</span> <span class="pre">Hints</span></code></a> command,
but this is a mere workaround and has some limitations (for instance, external
hints cannot be removed).</p>
<p>A proper way to fix this issue is to bind the hints to their module scope, as
for most of the other objects Coq uses. Hints should only be made available when
the module they are defined in is imported, not just required. It is very
difficult to change the historical behavior, as it would break a lot of scripts.
We propose a smooth transitional path by providing the <a class="reference internal" href="#coq:opt.loose-hint-behavior" title="Loose Hint Behavior"><code class="xref coq coq-opt docutils literal notranslate"><span class="pre">Loose</span> <span class="pre">Hint</span> <span class="pre">Behavior</span></code></a>
option which accepts three flags allowing for a fine-grained handling of
non-imported hints.</p>
<dl class="opt">
<dt id="coq:opt.loose-hint-behavior">
<em class="property"><span class="sigannot">Option</span></em> <code class="descname"><span class="notation"><span>Loose</span> <span>Hint</span> <span>Behavior</span> <span class="meta">(</span> <span>&quot;Lax&quot;</span> <span class="meta">|</span> <span>&quot;Warn&quot;</span> <span class="meta">|</span> <span>&quot;Strict&quot;</span> <span class="meta">)</span></span></code><a class="headerlink" href="#coq:opt.loose-hint-behavior" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option accepts three values, which control the behavior of hints w.r.t.
<a class="reference internal" href="../language/gallina-extensions.html#coq:cmd.import" title="Import"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Import</span></code></a>:</p>
<ul class="simple">
<li>&quot;Lax&quot;: this is the default, and corresponds to the historical behavior,
that is, hints defined outside of a section have a global scope.</li>
<li>&quot;Warn&quot;: outputs a warning when a non-imported hint is used. Note that this
is an over-approximation, because a hint may be triggered by a run that
will eventually fail and backtrack, resulting in the hint not being
actually useful for the proof.</li>
<li>&quot;Strict&quot;: changes the behavior of an unloaded hint to a immediate fail
tactic, allowing to emulate an import-scoped hint mechanism.</li>
</ul>
</dd></dl>

</div>
<div class="section" id="setting-implicit-automation-tactics">
<span id="tactics-implicit-automation"></span><h3>Setting implicit automation tactics<a class="headerlink" href="#setting-implicit-automation-tactics" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="cmd">
<dt id="coq:cmd.proof-with">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Proof</span> <span>with</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:cmd.proof-with" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command may be used to start a proof. It defines a default tactic
to be used each time a tactic command <code class="docutils literal notranslate"><span class="pre">tactic</span></code><sub>1</sub> is ended by <code class="docutils literal notranslate"><span class="pre">...</span></code>.
In this case the tactic command typed by the user is equivalent to
<code class="docutils literal notranslate"><span class="pre">tactic</span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="pre">;tactic</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="proof-handling.html#coq:cmd.proof" title="Proof"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Proof</span></code></a> in <a class="reference internal" href="proof-handling.html#proof-editing-mode"><span class="std std-ref">Switching on/off the proof editing mode</span></a>.</p>
</div>
<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Proof</span> <span>with</span> <span>tactic</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Combines in a single line <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">with</span></code> and <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code>, see <a class="reference internal" href="proof-handling.html#proof-editing-mode"><span class="std std-ref">Switching on/off the proof editing mode</span></a></p>
</dd></dl>

<dl class="cmdv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>Proof</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>with</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Combines in a single line <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">with</span></code> and <code class="docutils literal notranslate"><span class="pre">Proof</span> <span class="pre">using</span></code>, see <a class="reference internal" href="proof-handling.html#proof-editing-mode"><span class="std std-ref">Switching on/off the proof editing mode</span></a></p>
</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.declare-implicit-tactic">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Declare</span> <span>Implicit</span> <span>Tactic</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:cmd.declare-implicit-tactic" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command declares a tactic to be used to solve implicit arguments
that Coq does not know how to solve by unification. It is used every
time the term argument of a tactic has one of its holes not fully
resolved.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">quo</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span>:</span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span>&lt;&gt;0 -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd><span class="first last">quo is declared</span></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;x // y&quot; := (</span><span class="coqdoc-var">quo</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">_</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 40).</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Declare</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-keyword">Tactic</span><span> </span><span class="coqdoc-tactic">assumption</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">m</span><span>&lt;&gt;0 -&gt; { </span><span class="coqdoc-var">q</span><span>:</span><span class="coqdoc-var">nat</span><span> &amp; { </span><span class="coqdoc-var">r</span><span> | </span><span class="coqdoc-var">q</span><span> * </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">r</span><span> = </span><span class="coqdoc-var">n</span><span> } }.</span></dt>
<dd><span class="first">quo is declared
1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">exists</span><span> (</span><span class="coqdoc-var">n</span><span> // </span><span class="coqdoc-var">m</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> //</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">The tactic <code class="docutils literal notranslate"><span class="pre">exists</span> <span class="pre">(n</span> <span class="pre">//</span> <span class="pre">m)</span></code> did not fail. The hole was solved
by <code class="docutils literal notranslate"><span class="pre">assumption</span></code> so that it behaved as <code class="docutils literal notranslate"><span class="pre">exists</span> <span class="pre">(quo</span> <span class="pre">n</span> <span class="pre">m</span> <span class="pre">H)</span></code>.</p>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="decision-procedures">
<span id="decisionprocedures"></span><h2>Decision procedures<a class="headerlink" href="#decision-procedures" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.tauto">
<code class="descname"><span class="notation"><span>tauto</span></span></code><a class="headerlink" href="#coq:tacn.tauto" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic implements a decision procedure for intuitionistic propositional
calculus based on the contraction-free sequent calculi LJT* of Roy Dyckhoff
<a class="reference internal" href="../zebibliography.html#dyc92" id="id12">[Dyc92]</a>. Note that <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> succeeds on any instance of an
intuitionistic tautological proposition. <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> unfolds negations and
logical equivalence but does not unfold any other definition.</p>
<p>The following goal can be proved by <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> whereas <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> would
fail:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>), </span><span class="coqdoc-var">x</span><span> = 0 \/ </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">x</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> &lt;&gt; 0 -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">tauto</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
</div>
<p>Moreover, if it has nothing else to do, <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> performs introductions.
Therefore, the use of <a class="reference internal" href="#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a> in the previous proof is unnecessary.
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> can for instance for:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">P</span><span>:</span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>), </span><span class="coqdoc-var">A</span><span> \/ (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">nat</span><span>, ~ </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">x</span><span>) -&gt; </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>:</span><span class="coqdoc-var">nat</span><span>, ~ </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">tauto</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
</div>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">In contrast, <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> cannot solve the following goal
<code class="code Coq docutils literal notranslate"><span class="keyword namespace"><span class="pre">Goal</span></span> <span class="keyword"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Prop</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">P</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="keyword type"><span class="pre">Prop</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">~</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span> <span class="operator"><span class="pre">-&gt;</span></span></code>
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">~</span></span> <span class="operator"><span class="pre">~</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">\/</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">).</span></span></code>
because <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">nat</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">~</span></span> <span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">-&gt;</span></span> <span class="name"><span class="pre">P</span></span> <span class="name"><span class="pre">x</span></span><span class="operator"><span class="pre">)</span></span></code> cannot be treated as atomic and
an instantiation of <cite>x</cite> is necessary.</p>
</div>
<dl class="tacv">
<dt id="coq:tacv.dtauto">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dtauto</span></span></code><a class="headerlink" href="#coq:tacv.dtauto" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>While <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> recognizes inductively defined connectives isomorphic to
the standard connectives <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">prod</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>,
<code class="docutils literal notranslate"><span class="pre">Empty_set</span></code>, <code class="docutils literal notranslate"><span class="pre">unit</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#coq:tacv.dtauto" title="dtauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dtauto</span></code></a> also recognizes all inductive
types with one constructor and no indices, i.e. record-style connectives.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.intuition">
<code class="descname"><span class="notation"><span>intuition</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacn.intuition" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The tactic <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> takes advantage of the search-tree built by the
decision procedure involved in the tactic <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a>. It uses this
information to generate a set of subgoals equivalent to the original one (but
simpler than it) and applies the tactic <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> to them <a class="reference internal" href="../zebibliography.html#mun94" id="id13">[Mun94]</a>. If
this tactic fails on some goals then <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> fails. In fact,
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> is simply <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">intuition</span></span> <span class="name"><span class="pre">fail</span></span></code>.</p>
<p>For instance, the tactic <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">intuition</span></span> <span class="keyword"><span class="pre">auto</span></span></code> applied to the goal</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(forall (x:nat), P x) /\ B -&gt; (forall (y:nat), P y) /\ P O \/ B /\ P O
</pre></div>
</div>
<p>internally replaces it by the equivalent one:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(forall (x:nat), P x), B |- P O
</pre></div>
</div>
<p>and then uses <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> which completes the proof.</p>
<p>Originally due to César Muñoz, these tactics (<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> and
<a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a>) have been completely re-engineered by David Delahaye using
mainly the tactic language (see <a class="reference internal" href="ltac.html#ltac"><span class="std std-ref">The tactic language</span></a>). The code is
now much shorter and a significant increase in performance has been noticed.
The general behavior with respect to dependent types, unfolding and
introductions has slightly changed to get clearer semantics. This may lead to
some incompatibilities.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>intuition</span></span></code></dt>
<dd><p>Is equivalent to <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">intuition</span></span> <span class="keyword"><span class="pre">auto</span></span> <span class="keyword"><span class="pre">with</span></span> <span class="operator"><span class="pre">*</span></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.dintuition">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dintuition</span></span></code><a class="headerlink" href="#coq:tacv.dintuition" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>While <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> recognizes inductively defined connectives
isomorphic to the standard connectives <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">prod</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">sum</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>,
<code class="docutils literal notranslate"><span class="pre">Empty_set</span></code>, <code class="docutils literal notranslate"><span class="pre">unit</span></code>, <code class="docutils literal notranslate"><span class="pre">True</span></code>, <a class="reference internal" href="#coq:tacv.dintuition" title="dintuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dintuition</span></code></a> also recognizes all inductive
types with one constructor and no indices, i.e. record-style connectives.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.intuition-negation-unfolding">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Intuition</span> <span>Negation</span> <span>Unfolding</span></span></code><a class="headerlink" href="#coq:flag.intuition-negation-unfolding" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Controls whether <a class="reference internal" href="#coq:tacn.intuition" title="intuition"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intuition</span></code></a> unfolds inner negations which do not need
to be unfolded. This option is on by default.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.rtauto">
<code class="descname"><span class="notation"><span>rtauto</span></span></code><a class="headerlink" href="#coq:tacn.rtauto" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The <a class="reference internal" href="#coq:tacn.rtauto" title="rtauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rtauto</span></code></a> tactic solves propositional tautologies similarly to what
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> does. The main difference is that the proof term is built using a
reflection scheme applied to a sequent calculus proof of the goal.  The search
procedure is also implemented using a different technique.</p>
<p>Users should be aware that this difference may result in faster proof-search
but slower proof-checking, and <a class="reference internal" href="#coq:tacn.rtauto" title="rtauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rtauto</span></code></a> might not solve goals that
<a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> would be able to solve (e.g. goals involving universal
quantifiers).</p>
<p>Note that this tactic is only available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Rtauto</span></code>.</p>
<dl class="tacn">
<dt id="coq:tacn.firstorder">
<code class="descname"><span class="notation"><span>firstorder</span></span></code><a class="headerlink" href="#coq:tacn.firstorder" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The tactic <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a> is an experimental extension of <a class="reference internal" href="#coq:tacn.tauto" title="tauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">tauto</span></code></a> to
first- order reasoning, written by Pierre Corbineau. It is not restricted to
usual logical connectives but instead may reason about any first-order class
inductive definition.</p>
<dl class="opt">
<dt id="coq:opt.firstorder-solver">
<em class="property"><span class="sigannot">Option</span></em> <code class="descname"><span class="notation"><span>Firstorder</span> <span>Solver</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:opt.firstorder-solver" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The default tactic used by <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a> when no rule applies is
<code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">auto</span></span> <span class="keyword"><span class="pre">with</span></span> <span class="operator"><span class="pre">*</span></span></code>, it can be reset locally or globally using this option.</p>
<dl class="cmd">
<dt id="coq:cmd.print-firstorder-solver">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Print</span> <span>Firstorder</span> <span>Solver</span></span></code><a class="headerlink" href="#coq:cmd.print-firstorder-solver" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Prints the default tactic used by <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a> when no rule applies.</p>
</dd></dl>

</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>firstorder</span> <span class="hole">tactic</span></span></code></dt>
<dd><p>Tries to solve the goal with <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span></span></code> when no logical rule may apply.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>firstorder</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds lemmas <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to the proof-search environment. If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code>
refers to an inductive type, it is the collection of its constructors which are
added to the proof-search environment.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>firstorder</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>Adds lemmas from <a class="reference internal" href="#coq:tacn.auto" title="auto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">auto</span></code></a> hint bases <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to the proof-search
environment.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>firstorder</span> <span>tactic</span> <span>using</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd><p>This combines the effects of the different variants of <a class="reference internal" href="#coq:tacn.firstorder" title="firstorder"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">firstorder</span></code></a>.</p>
</dd></dl>

<dl class="opt">
<dt id="coq:opt.firstorder-depth">
<em class="property"><span class="sigannot">Option</span></em> <code class="descname"><span class="notation"><span>Firstorder</span> <span>Depth</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code><a class="headerlink" href="#coq:opt.firstorder-depth" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option controls the proof-search depth bound.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.congruence">
<code class="descname"><span class="notation"><span>congruence</span></span></code><a class="headerlink" href="#coq:tacn.congruence" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The tactic <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a>, by Pierre Corbineau, implements the standard
Nelson and Oppen congruence closure algorithm, which is a decision procedure
for ground equalities with uninterpreted symbols. It also includes
constructor theory (see <a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> and <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>). If the goal
is a non-quantified equality, congruence tries to prove it with non-quantified
equalities in the context. Otherwise it tries to infer a discriminable equality
from those in the context. Alternatively, congruence tries to prove that a
hypothesis is equal to the goal or to the negation of another hypothesis.</p>
<p><a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> is also able to take advantage of hypotheses stating
quantified equalities, but you have to provide a bound for the number of extra
equalities generated that way. Please note that one of the sides of the
equality must contain all the quantified variables in order for congruence to
match against it.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Theorem</span><span> </span><span class="coqdoc-var">T</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">g</span><span>: </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">A</span><span>) </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>: </span><span class="coqdoc-var">a</span><span>=(</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">a</span><span>) -&gt; (</span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">b</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">a</span><span>))=(</span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">a</span><span>)) -&gt; (</span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>)=(</span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">a</span><span>)) -&gt; (</span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>)=</span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  g : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  g : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">congruence</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd><span class="first last">T is defined</span></dd>
<dt><span class="coqdoc-keyword">Theorem</span><span> </span><span class="coqdoc-var">inj</span><span> (</span><span class="coqdoc-var">A</span><span>:</span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">f</span><span>:</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">A</span><span> * </span><span class="coqdoc-var">A</span><span>) (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">c</span><span> </span><span class="coqdoc-var">d</span><span>: </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">f</span><span> = </span><span class="coqdoc-var">pair</span><span> </span><span class="coqdoc-var">a</span><span> -&gt; </span><span class="coqdoc-var">Some</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">c</span><span>) = </span><span class="coqdoc-var">Some</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">d</span><span>) -&gt; </span><span class="coqdoc-var">c</span><span>=</span><span class="coqdoc-var">d</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, c, d : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pair</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, c, d : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pair</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">congruence</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd><span class="first last">inj is defined</span></dd>
</dl>
</div>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>congruence</span> <span>n</span></span></code></dt>
<dd><p>Tries to add at most <cite>n</cite> instances of hypotheses stating quantified equalities
to the problem in order to solve it. A bigger value of <cite>n</cite> does not make
success slower, only failure. You might consider adding some lemmas as
hypotheses using assert in order for <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> to use them.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.congruence-with">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>congruence</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacv.congruence-with" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> to the pool of terms used by <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a>. This helps
in case you have partially applied constructors in your goal.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.i-dont-know-how-to-handle-dependent-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>I</span> <span>don’t</span> <span>know</span> <span>how</span> <span>to</span> <span>handle</span> <span>dependent</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.i-dont-know-how-to-handle-dependent-equality" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The decision procedure managed to find a proof of the goal or of a
discriminable equality but this proof could not be built in Coq because of
dependently-typed functions.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.goal-is-solvable-by-congruence-but-some-arguments-are-missing-try-congruence-with-term-term-replacing-metavariables-by-arbitrary-terms">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Goal</span> <span>is</span> <span>solvable</span> <span>by</span> <span>congruence</span> <span>but</span> <span>some</span> <span>arguments</span> <span>are</span> <span>missing.</span> <span>Try</span> <span>congruence</span> <span>with</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span><span>,</span> <span>replacing</span> <span>metavariables</span> <span>by</span> <span>arbitrary</span> <span>terms.</span></span></code><a class="headerlink" href="#coq:exn.goal-is-solvable-by-congruence-but-some-arguments-are-missing-try-congruence-with-term-term-replacing-metavariables-by-arbitrary-terms" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The decision procedure could solve the goal with the provision that additional
arguments are supplied for some partially applied constructors. Any term of an
appropriate type will allow the tactic to successfully solve the goal. Those
additional arguments can be given to congruence by filling in the holes in the
terms given in the error message, using the <a class="reference internal" href="#coq:tacv.congruence-with" title="congruence with"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span> <span class="pre">with</span></code></a> variant described above.</p>
</dd></dl>

<dl class="flag">
<dt id="coq:flag.congruence-verbose">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>Congruence</span> <span>Verbose</span></span></code><a class="headerlink" href="#coq:flag.congruence-verbose" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option makes <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a> print debug information.</p>
</dd></dl>

</div>
<div class="section" id="checking-properties-of-terms">
<h2>Checking properties of terms<a class="headerlink" href="#checking-properties-of-terms" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Each of the following tactics acts as the identity if the check
succeeds, and results in an error otherwise.</p>
<dl class="tacn">
<dt id="coq:tacn.constr-eq">
<code class="descname"><span class="notation"><span>constr</span><span>_</span><span>eq</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.constr-eq" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic checks whether its arguments are equal modulo alpha
conversion and casts.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.not-equal">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>equal.</span></span></code><a class="headerlink" href="#coq:exn.not-equal" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.unify">
<code class="descname"><span class="notation"><span>unify</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.unify" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic checks whether its arguments are unifiable, potentially
instantiating existential variables.</p>
</dd></dl>

<dl class="exn">
<dt>
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Unable</span> <span>to</span> <span>unify</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>.</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>unify</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>Unification takes the transparency information defined in the hint database
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> into account (see <a class="reference internal" href="#thehintsdatabasesforautoandeauto"><span class="std std-ref">the hints databases for auto and eauto</span></a>).</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.is-evar">
<code class="descname"><span class="notation"><span>is</span><span>_</span><span>evar</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.is-evar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic checks whether its argument is a current existential
variable. Existential variables are uninstantiated variables generated
by <a class="reference internal" href="#coq:tacv.eapply" title="eapply"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">eapply</span></code></a> and some other tactics.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.not-an-evar">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>an</span> <span>evar.</span></span></code><a class="headerlink" href="#coq:exn.not-an-evar" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.has-evar">
<code class="descname"><span class="notation"><span>has</span><span>_</span><span>evar</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.has-evar" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic checks whether its argument has an existential variable as
a subterm. Unlike context patterns combined with <code class="docutils literal notranslate"><span class="pre">is_evar</span></code>, this tactic
scans all subterms, including those under binders.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.no-evars">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>No</span> <span>evars.</span></span></code><a class="headerlink" href="#coq:exn.no-evars" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.is-var">
<code class="descname"><span class="notation"><span>is</span><span>_</span><span>var</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.is-var" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic checks whether its argument is a variable or hypothesis in
the current goal context or in the opened sections.</p>
</dd></dl>

<dl class="exn">
<dt id="coq:exn.not-a-variable-or-hypothesis">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Not</span> <span>a</span> <span>variable</span> <span>or</span> <span>hypothesis.</span></span></code><a class="headerlink" href="#coq:exn.not-a-variable-or-hypothesis" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="equality">
<span id="id14"></span><h2>Equality<a class="headerlink" href="#equality" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.f-equal">
<code class="descname"><span class="notation"><span>f</span><span>_</span><span>equal</span></span></code><a class="headerlink" href="#coq:tacn.f-equal" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic applies to a goal of the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span> <span class="name"><span class="pre">a</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">a</span></span></code><sub>n</sub>
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">f</span></span><span class="error"><span class="pre">′</span></span><span class="name"><span class="pre">a</span></span><span class="error"><span class="pre">′</span></span></code><sub>1</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">...</span></span> <span class="name"><span class="pre">a</span></span><span class="error"><span class="pre">′</span></span></code><sub>n</sub>.  Using <a class="reference internal" href="#coq:tacn.f-equal" title="f_equal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">f_equal</span></code></a> on such a goal
leads to subgoals <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">f</span></span><span class="error"><span class="pre">′</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code><sub>1</sub> = <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span><span class="error"><span class="pre">′</span></span></code><sub>1</sub> and so on up
to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code><sub>n</sub> <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">a</span></span><span class="error"><span class="pre">′</span></span></code><sub>n</sub>. Amongst these subgoals, the simple ones
(e.g. provable by <a class="reference internal" href="#coq:tacn.reflexivity" title="reflexivity"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">reflexivity</span></code></a> or <a class="reference internal" href="#coq:tacn.congruence" title="congruence"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congruence</span></code></a>) are automatically
solved by <a class="reference internal" href="#coq:tacn.f-equal" title="f_equal"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">f_equal</span></code></a>.</p>
<dl class="tacn">
<dt id="coq:tacn.reflexivity">
<code class="descname"><span class="notation"><span>reflexivity</span></span></code><a class="headerlink" href="#coq:tacn.reflexivity" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic applies to a goal that has the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code>. It checks that <cite>t</cite>
and <cite>u</cite> are convertible and then solves the goal. It is equivalent to
<code class="docutils literal notranslate"><span class="pre">apply</span> <span class="pre">refl_equal</span></code>.</p>
<dl class="exn">
<dt id="coq:exn.the-conclusion-is-not-a-substitutive-equation">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>The</span> <span>conclusion</span> <span>is</span> <span>not</span> <span>a</span> <span>substitutive</span> <span>equation.</span></span></code><a class="headerlink" href="#coq:exn.the-conclusion-is-not-a-substitutive-equation" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.unable-to-unify-with">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Unable</span> <span>to</span> <span>unify</span> <span>...</span> <span>with</span> <span>...</span></span></code><a class="headerlink" href="#coq:exn.unable-to-unify-with" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.symmetry">
<code class="descname"><span class="notation"><span>symmetry</span></span></code><a class="headerlink" href="#coq:tacn.symmetry" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic applies to a goal that has the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code> and changes it into
<code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">t</span></span></code>.</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>symmetry</span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code></dt>
<dd><p>If the statement of the hypothesis ident has the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code>, the tactic
changes it to <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">u</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">t</span></span></code>.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.transitivity">
<code class="descname"><span class="notation"><span>transitivity</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.transitivity" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic applies to a goal that has the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">=</span></span><span class="name"><span class="pre">u</span></span></code> and transforms it
into the two subgoals <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">t=</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a><span><span class="pre">=u</span></span></span></code>.</p>
</div>
<div class="section" id="equality-and-inductive-sets">
<h2>Equality and inductive sets<a class="headerlink" href="#equality-and-inductive-sets" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>We describe in this section some special purpose tactics dealing with
equality and inductive sets or types. These tactics use the
equality <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">eq</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword"><span class="pre">forall</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">:</span></span><span class="keyword type"><span class="pre">Type</span></span><span class="operator"><span class="pre">),</span></span> <span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="name"><span class="pre">A</span></span><span class="operator"><span class="pre">-&gt;</span></span><span class="keyword type"><span class="pre">Prop</span></span></code>, simply written with the infix
symbol <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">=</span></span></code>.</p>
<dl class="tacn">
<dt id="coq:tacn.decide-equality">
<code class="descname"><span class="notation"><span>decide</span> <span>equality</span></span></code><a class="headerlink" href="#coq:tacn.decide-equality" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic solves a goal of the form <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">forall</span></span> <span class="name"><span class="pre">x</span></span> <span class="name"><span class="pre">y</span></span> <span class="operator"><span class="pre">:</span></span> <span class="name"><span class="pre">R</span></span><span class="operator"><span class="pre">,</span></span> <span class="operator"><span class="pre">{</span></span><span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span> <span class="operator"><span class="pre">+</span></span> <span class="operator"><span class="pre">{~</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span></code>,
where <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">R</span></span></code> is an inductive type such that its constructors do not take
proofs or functions as arguments, nor objects in dependent types. It
solves goals of the form <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">{</span></span><span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span> <span class="operator"><span class="pre">+</span></span> <span class="operator"><span class="pre">{~</span></span> <span class="name"><span class="pre">x</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">y</span></span><span class="operator"><span class="pre">}</span></span></code> as well.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.compare">
<code class="descname"><span class="notation"><span>compare</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.compare" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic compares two given objects <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> of an
inductive datatype. If <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">G</span></span></code> is the current goal, it leaves the sub-
goals <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">-&gt;</span></span> <span><span class="pre">G</span></span></span></code> and <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">~</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">-&gt;</span></span> <span><span class="pre">G</span></span></span></code>. The type of
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> must satisfy the same restrictions as in the
tactic <code class="docutils literal notranslate"><span class="pre">decide</span> <span class="pre">equality</span></code>.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.simplify-eq">
<code class="descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.simplify-eq" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Let <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> be the proof of a statement of conclusion <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> are structurally different (in the sense
described for the tactic <a class="reference internal" href="#coq:tacn.discriminate" title="discriminate"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">discriminate</span></code></a>), then the tactic
<code class="docutils literal notranslate"><span class="pre">simplify_eq</span></code> behaves as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">discriminate</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, otherwise it behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">injection</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">If some quantified hypothesis of the goal is named <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>,
then <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> first introduces the hypothesis in the local
context using <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</div>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> then
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> is the identifier for the last
introduced hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span></code></dt>
<dd><p>This does the same as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> but using the given bindings to
instantiate parameters or hypotheses of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>esimplify</span><span>_</span><span>eq</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.esimplify-eq">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>esimplify</span><span>_</span><span>eq</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>with</span> <a class="reference internal" href="#grammar-token-bindings_list"><span class="hole">bindings_list</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.esimplify-eq" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This works the same as <code class="docutils literal notranslate"><span class="pre">simplify_eq</span></code> but if the type of <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>, or the
type of the hypothesis referred to by <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>, has uninstantiated
parameters, these parameters are left as existential variables.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>simplify</span><span>_</span><span>eq</span></span></code></dt>
<dd><p>If the current goal has form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t1</span></span> <span class="operator"><span class="pre">&lt;&gt;</span></span> <span class="name"><span class="pre">t2</span></span></code>, it behaves as
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intro</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a><span><span class="pre">;</span></span> <span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.dependent-rewrite">
<code class="descname"><span class="notation"><span>dependent</span> <span>rewrite</span> <span>-&gt;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.dependent-rewrite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic applies to any goal. If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> has type
<code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a</span></span> <span class="name"><span class="pre">b</span></span><span class="operator"><span class="pre">)=(</span></span><span class="name"><span class="pre">existT</span></span> <span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a'</span></span> <span class="name"><span class="pre">b'</span></span><span class="operator"><span class="pre">)</span></span></code> in the local context (i.e. each
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> of the equality has a sigma type <code class="code Coq docutils literal notranslate"><span class="operator"><span class="pre">{</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">:</span></span><span class="name"><span class="pre">A</span></span> <span class="operator"><span class="pre">&amp;</span></span> <span class="operator"><span class="pre">(</span></span><span class="name"><span class="pre">B</span></span> <span class="name"><span class="pre">a</span></span><span class="operator"><span class="pre">)}</span></span></code>) this tactic
rewrites <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a</span></span></code> into <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">a'</span></span></code> and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b</span></span></code> into <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">b'</span></span></code> in the current goal.
This tactic works even if <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">B</span></span></code> is also a sigma type. This kind of
equalities between dependent pairs may be derived by the
<a class="reference internal" href="#coq:tacn.injection" title="injection"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">injection</span></code></a> and <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a> tactics.</p>
</dd></dl>

<dl class="tacv">
<dt id="coq:tacv.dependent-rewrite">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>dependent</span> <span>rewrite</span> <span>&lt;-</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacv.dependent-rewrite" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Analogous to <a class="reference internal" href="#coq:tacn.dependent-rewrite" title="dependent rewrite -&gt;"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">dependent</span> <span class="pre">rewrite</span> <span class="pre">-&gt;</span></code></a> but uses the equality from right to
left.</p>
</dd></dl>

</div>
<div class="section" id="inversion">
<h2>Inversion<a class="headerlink" href="#inversion" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.functional-inversion">
<code class="descname"><span class="notation"><span>functional</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.functional-inversion" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p><a class="reference internal" href="#coq:tacn.functional-inversion" title="functional inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">functional</span> <span class="pre">inversion</span></code></a> is a tactic that performs inversion on hypothesis
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> of the form <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a><span>
</span><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code> where <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> must have been defined using Function (see
<a class="reference internal" href="../language/gallina-extensions.html#advanced-recursive-functions"><span class="std std-ref">Advanced recursive functions</span></a>). Note that this tactic is only
available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">FunInd</span></code>.</p>
<dl class="exn">
<dt id="coq:exn.hypothesis-ident-must-contain-at-least-one-function">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Hypothesis</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>must</span> <span>contain</span> <span>at</span> <span>least</span> <span>one</span> <span>Function.</span></span></code><a class="headerlink" href="#coq:exn.hypothesis-ident-must-contain-at-least-one-function" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="exn">
<dt id="coq:exn.cannot-find-inversion-information-for-hypothesis-ident">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>find</span> <span>inversion</span> <span>information</span> <span>for</span> <span>hypothesis</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a><span>.</span></span></code><a class="headerlink" href="#coq:exn.cannot-find-inversion-information-for-hypothesis-ident" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This error may be raised when some inversion lemma failed to be generated by
Function.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>functional</span> <span>inversion</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code></dt>
<dd><p>This does the same thing as <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">intros</span></span> <span><span class="pre">until</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> folowed by
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">functional</span></span> <span><span class="pre">inversion</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> where <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the
identifier for the last introduced hypothesis.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>functional</span> <span>inversion</span> <span>ident</span> <span>qualid</span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>functional</span> <span>inversion</span> <span>num</span> <span>qualid</span></span></code></dt>
<dd><p>If the hypothesis <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code> (or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>) has a type of the form
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code><sub>1</sub> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code><sub>1</sub> ... <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code><sub>n</sub> <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">=</span>
</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code><sub>2</sub> <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code><sub>n+1</sub> ... <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code><sub>n+m</sub> where
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code><sub>1</sub> and <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code><sub>2</sub> are valid candidates to
functional inversion, this variant allows choosing which <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole"><span class="pre">qualid</span></span></a></span></code> is
inverted.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.quote">
<code class="descname"><span class="notation"><span>quote</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.quote" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This kind of inversion has nothing to do with the tactic <a class="reference internal" href="#coq:tacn.inversion" title="inversion"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">inversion</span></code></a>
above. This tactic does <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">change</span></span> <span class="operator"><span class="pre">(&#64;</span></span><span class="name"><span class="pre">ident</span></span> <span class="name"><span class="pre">t</span></span><span class="operator"><span class="pre">)</span></span></code>, where <cite>t</cite> is a term built in
order to ensure the convertibility. In other words, it does inversion of the
function <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span></code>. This function must be a fixpoint on a simple recursive
datatype: see <a class="reference internal" href="detailed-tactic-examples.html#quote"><span class="std std-ref">quote</span></a> for the full details.</p>
<dl class="exn">
<dt id="coq:exn.quote-not-a-simple-fixpoint">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>quote:</span> <span>not</span> <span>a</span> <span>simple</span> <span>fixpoint.</span></span></code><a class="headerlink" href="#coq:exn.quote-not-a-simple-fixpoint" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Happens when quote is not able to perform inversion properly.</p>
</dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>quote</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd><p>All terms that are built only with <code class="docutils literal notranslate"><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a></span><span class="notation-sup"><span class="pre">*</span></span></span></span></code> will be considered by quote
as constants rather than variables.</p>
</dd></dl>

</div>
<div class="section" id="classical-tactics">
<h2>Classical tactics<a class="headerlink" href="#classical-tactics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>In order to ease the proving process, when the Classical module is
loaded. A few more tactics are available. Make sure to load the module
using the <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span></code> command.</p>
<dl class="tacn">
<dt id="coq:tacn.classical-left">
<code class="descname"><span class="notation"><span>classical</span><span>_</span><span>left</span></span></code><a class="headerlink" href="#coq:tacn.classical-left" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.classical-right">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>classical</span><span>_</span><span>right</span></span></code><a class="headerlink" href="#coq:tacv.classical-right" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The tactics <code class="docutils literal notranslate"><span class="pre">classical_left</span></code> and <code class="docutils literal notranslate"><span class="pre">classical_right</span></code> are the analog of the
left and right but using classical logic. They can only be used for
disjunctions. Use <code class="docutils literal notranslate"><span class="pre">classical_left</span></code> to prove the left part of the
disjunction with the assumption that the negation of right part holds.
Use <code class="docutils literal notranslate"><span class="pre">classical_right</span></code> to prove the right part of the disjunction with
the assumption that the negation of left part holds.</p>
</dd></dl>

</div>
<div class="section" id="automating">
<span id="tactics-automating"></span><h2>Automating<a class="headerlink" href="#automating" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.btauto">
<code class="descname"><span class="notation"><span>btauto</span></span></code><a class="headerlink" href="#coq:tacn.btauto" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The tactic <a class="reference internal" href="#coq:tacn.btauto" title="btauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">btauto</span></code></a> implements a reflexive solver for boolean
tautologies. It solves goals of the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">u</span></span></code> where <cite>t</cite> and <cite>u</cite> are
constructed over the following grammar:</p>
<blockquote id="btauto-grammar">
<div><pre>
<strong id="grammar-token-t">t</strong> ::=  x
      ∣ true
      ∣ false
      ∣ orb t1 t2
      ∣ andb t1 t2
      ∣ xorb t1 t2
      ∣ negb t
      ∣ if t1 then t2 else t3
</pre>
<p>Whenever the formula supplied is not a tautology, it also provides a
counter-example.</p>
<p>Internally, it uses a system very similar to the one of the ring
tactic.</p>
<p>Note that this tactic is only available after a <code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Btauto</span></code>.</p>
</div></blockquote>
<dl class="exn">
<dt id="coq:exn.cannot-recognize-a-boolean-equality">
<em class="property"><span class="sigannot">Error</span></em> <code class="descname"><span class="notation"><span>Cannot</span> <span>recognize</span> <span>a</span> <span>boolean</span> <span>equality.</span></span></code><a class="headerlink" href="#coq:exn.cannot-recognize-a-boolean-equality" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>The goal is not of the form <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">t</span></span> <span class="operator"><span class="pre">=</span></span> <span class="name"><span class="pre">u</span></span></code>. Especially note that <a class="reference internal" href="#coq:tacn.btauto" title="btauto"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">btauto</span></code></a>
doesn't introduce variables into the context on its own.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.omega">
<code class="descname"><span class="notation"><span>omega</span></span></code><a class="headerlink" href="#coq:tacn.omega" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The tactic <a class="reference internal" href="#coq:tacn.omega" title="omega"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">omega</span></code></a>, due to Pierre Crégut, is an automatic decision
procedure for Presburger arithmetic. It solves quantifier-free
formulas built with <cite>~</cite>, <cite>/</cite>, <cite>/`, `-&gt;</cite> on top of equalities,
inequalities and disequalities on both the type <code class="code Coq docutils literal notranslate"><span class="keyword type"><span class="pre">nat</span></span></code> of natural numbers
and <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">Z</span></span></code> of binary integers. This tactic must be loaded by the command
<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Omega</span></code>. See the additional documentation about omega
(see Chapter <a class="reference internal" href="../addendum/omega.html#omega"><span class="std std-ref">Omega: a solver for quantifier-free problems in Presburger Arithmetic</span></a>).</p>
<dl class="tacn">
<dt id="coq:tacn.ring">
<code class="descname"><span class="notation"><span>ring</span></span></code><a class="headerlink" href="#coq:tacn.ring" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.ring-simplify">
<code class="descname"><span class="notation"><span>ring</span><span>_</span><span>simplify</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.ring-simplify" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ring</span></span></span></code> tactic solves equations upon polynomial expressions of a ring
(or semiring) structure. It proceeds by normalizing both hand sides
of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation) and comparing syntactically the
results.</p>
<p><code class="docutils literal notranslate"><span class="notation"><span><span class="pre">ring</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span></span></code> applies the normalization procedure described above to
the given terms. The tactic then replaces all occurrences of the terms
given in the conclusion of the goal by their normal forms. If no term
is given, then the conclusion should be an equation and both hand
sides are normalized.</p>
<p>See <a class="reference internal" href="../addendum/ring.html#theringandfieldtacticfamilies"><span class="std std-ref">The ring and field tactic families</span></a> for more information on
the tactic and how to declare new ring structures. All declared field structures
can be printed with the <code class="docutils literal notranslate"><span class="pre">Print</span> <span class="pre">Rings</span></code> command.</p>
<dl class="tacn">
<dt id="coq:tacn.field">
<code class="descname"><span class="notation"><span>field</span></span></code><a class="headerlink" href="#coq:tacn.field" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.field-simplify">
<code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.field-simplify" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacn">
<dt id="coq:tacn.field-simplify-eq">
<code class="descname"><span class="notation"><span>field</span><span>_</span><span>simplify</span><span>_</span><span>eq</span></span></code><a class="headerlink" href="#coq:tacn.field-simplify-eq" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The field tactic is built on the same ideas as ring: this is a
reflexive tactic that solves or simplifies equations in a field
structure. The main idea is to reduce a field expression (which is an
extension of ring expressions with the inverse and division
operations) to a fraction made of two polynomial expressions.</p>
<p>Tactic <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">field</span></span></span></code> is used to solve subgoals, whereas <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">field</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span><span class="notation-sup"><span class="pre">+</span></span></span></span></code>
replaces the provided terms by their reduced fraction.
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">field</span></span><span><span class="pre">_</span></span><span><span class="pre">simplify</span></span><span><span class="pre">_</span></span><span><span class="pre">eq</span></span></span></code> applies when the conclusion is an equation: it
simplifies both hand sides and multiplies so as to cancel
denominators. So it produces an equation without division nor inverse.</p>
<p>All of these 3 tactics may generate a subgoal in order to prove that
denominators are different from zero.</p>
<p>See <a class="reference internal" href="../addendum/ring.html#theringandfieldtacticfamilies"><span class="std std-ref">The ring and field tactic families</span></a> for more information on the tactic and how to
declare new field structures. All declared field structures can be
printed with the Print Fields command.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Reals</span><span>.</span></dt>
<dd><span class="first last">[Loading ML file z_syntax_plugin.cmxs ... done]
[Loading ML file r_syntax_plugin.cmxs ... done]
[Loading ML file quote_plugin.cmxs ... done]
[Loading ML file newring_plugin.cmxs ... done]
[Loading ML file omega_plugin.cmxs ... done]
[Loading ML file fourier_plugin.cmxs ... done]
[Loading ML file micromega_plugin.cmxs ... done]</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>:</span><span class="coqdoc-var">R</span><span>,</span><span>
(</span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">y</span><span> &gt; 0)%</span><span class="coqdoc-var">R</span><span> -&gt;</span><span>
(</span><span class="coqdoc-var">x</span><span> * (1 / </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">x</span><span> / (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>)))%</span><span class="coqdoc-var">R</span><span> =</span><span>
((- 1 / </span><span class="coqdoc-var">y</span><span>) * </span><span class="coqdoc-var">y</span><span> * (- </span><span class="coqdoc-var">x</span><span> * (</span><span class="coqdoc-var">x</span><span> / (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>)) - 1))%</span><span class="coqdoc-var">R</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)%R</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)))%R</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (-1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">-</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 1))%R</span></dd>
<dt><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">field</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)%R
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)%R</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0%R</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0%R</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0%R</span></dd>
</dl>
</div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last">File plugins/setoid_ring/RealField.v for an example of instantiation,
theory theories/Reals for many examples of use of field.</p>
</div>
<dl class="tacn">
<dt id="coq:tacn.fourier">
<code class="descname"><span class="notation"><span>fourier</span></span></code><a class="headerlink" href="#coq:tacn.fourier" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic written by Loïc Pottier solves linear inequalities on real
numbers using Fourier’s method <a class="reference internal" href="../zebibliography.html#fourier" id="id15">[Fou90]</a>. This tactic must be loaded by
<code class="docutils literal notranslate"><span class="pre">Require</span> <span class="pre">Import</span> <span class="pre">Fourier</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example: .. coqtop:: reset all</p>
<blockquote class="last">
<div>Require Import Reals.
Require Import Fourier.
Goal forall x y:R, (x &lt; y)%R -&gt; (y + 1 &gt;= x - 1)%R.
intros; fourier.</div></blockquote>
</div>
</div>
<div class="section" id="non-logical-tactics">
<h2>Non-logical tactics<a class="headerlink" href="#non-logical-tactics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<dl class="tacn">
<dt id="coq:tacn.cycle">
<code class="descname"><span class="notation"><span>cycle</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code><a class="headerlink" href="#coq:tacn.cycle" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic puts the <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> first goals at the end of the list of goals.
If <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> is negative, it will put the last <span class="math notranslate">\(|num|\)</span> goals at the
beginning of the list.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">P is declared</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">P</span><span> 1 /\ </span><span class="coqdoc-var">P</span><span> 2 /\ </span><span class="coqdoc-var">P</span><span> 3 /\ </span><span class="coqdoc-var">P</span><span> 4 /\ </span><span class="coqdoc-var">P</span><span> 5.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 5</span></dd>
<dt><span class="coqdoc-tactic">repeat</span><span> </span><span class="coqdoc-tactic">split</span><span>.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 5</span></dd>
<dt><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">cycle</span><span> 2.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 5
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 2</span></dd>
<dt><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">cycle</span><span> -3.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 5

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 4</span></dd>
</dl>
</div>
</div>
<dl class="tacn">
<dt id="coq:tacn.swap">
<code class="descname"><span class="notation"><span>swap</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span></code><a class="headerlink" href="#coq:tacn.swap" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic switches the position of the goals of indices <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> and
<code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code>. If either <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> or <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole"><span class="pre">num</span></span></a></span></code> is negative then goals are
counted from the end of the focused goal list. Goals are indexed from 1,
there is no goal with position 0.</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">P is declared</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">P</span><span> 1 /\ </span><span class="coqdoc-var">P</span><span> 2 /\ </span><span class="coqdoc-var">P</span><span> 3 /\ </span><span class="coqdoc-var">P</span><span> 4 /\ </span><span class="coqdoc-var">P</span><span> 5.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 5</span></dd>
<dt><span class="coqdoc-tactic">repeat</span><span> </span><span class="coqdoc-tactic">split</span><span>.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 5</span></dd>
<dt><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">swap</span><span> 1 3.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 5</span></dd>
<dt><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">swap</span><span> 1 -1.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 5

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 3</span></dd>
</dl>
</div>
</div>
<dl class="tacn">
<dt id="coq:tacn.revgoals">
<code class="descname"><span class="notation"><span>revgoals</span></span></code><a class="headerlink" href="#coq:tacn.revgoals" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactics reverses the list of the focused goals.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Parameter</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">P is declared</span></dd>
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">P</span><span> 1 /\ </span><span class="coqdoc-var">P</span><span> 2 /\ </span><span class="coqdoc-var">P</span><span> 3 /\ </span><span class="coqdoc-var">P</span><span> 4 /\ </span><span class="coqdoc-var">P</span><span> 5.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 5</span></dd>
<dt><span class="coqdoc-tactic">repeat</span><span> </span><span class="coqdoc-tactic">split</span><span>.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 5</span></dd>
<dt><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">revgoals</span><span>.</span></dt>
<dd><span class="first">5 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 5

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4
subgoal 3 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
subgoal 4 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
subgoal 5 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 1</span></dd>
</dl>
</div>
</div>
<dl class="tacn">
<dt id="coq:tacn.shelve">
<code class="descname"><span class="notation"><span>shelve</span></span></code><a class="headerlink" href="#coq:tacn.shelve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic moves all goals under focus to a shelf. While on the
shelf, goals will not be focused on. They can be solved by
unification, or they can be called back into focus with the command
<a class="reference internal" href="#coq:cmd.unshelve" title="Unshelve"><code class="xref coq coq-cmd docutils literal notranslate"><span class="pre">Unshelve</span></code></a>.</p>
<dl class="tacv">
<dt id="coq:tacv.shelve-unifiable">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>shelve</span><span>_</span><span>unifiable</span></span></code><a class="headerlink" href="#coq:tacv.shelve-unifiable" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>Shelves only the goals under focus that are mentioned in other goals.
Goals that appear in the type of other goals can be solved by unification.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">n</span><span>=0.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exists</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">refine</span><span> (</span><span class="coqdoc-var">ex_intro</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>).</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  ============================
  </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?Goal</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-var">all</span><span>: </span><span class="coqdoc-var">shelve_unifiable</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-tactic">reflexivity</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
</div>
</dd></dl>

</dd></dl>

<dl class="cmd">
<dt id="coq:cmd.unshelve">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Unshelve</span></span></code><a class="headerlink" href="#coq:cmd.unshelve" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This command moves all the goals on the shelf (see <a class="reference internal" href="#coq:tacn.shelve" title="shelve"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">shelve</span></code></a>)
from the shelf into focus, by appending them to the end of the current
list of focused goals.</p>
</dd></dl>

<dl class="tacn">
<dt id="coq:tacn.give-up">
<code class="descname"><span class="notation"><span>give</span><span>_</span><span>up</span></span></code><a class="headerlink" href="#coq:tacn.give-up" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic removes the focused goals from the proof. They are not
solved, and cannot be solved later in the proof. As the goals are not
solved, the proof cannot be closed.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">give_up</span></code> tactic can be used while editing a proof, to choose to
write the proof script in a non-sequential order.</p>
</dd></dl>

</div>
<div class="section" id="simple-tactic-macros">
<h2>Simple tactic macros<a class="headerlink" href="#simple-tactic-macros" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A simple example has more value than a long explanation:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-keyword">Solve</span><span> := </span><span class="coqdoc-tactic">simpl</span><span>; </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">auto</span><span>.</span></dt>
<dd><span class="first last">Solve is defined</span></dd>
<dt><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">ElimBoolRewrite</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span> :=</span><span>
</span><span class="coqdoc-tactic">elim</span><span> </span><span class="coqdoc-var">b</span><span>; [ </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H1</span><span>; </span><span class="coqdoc-tactic">eauto</span><span> | </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H2</span><span>; </span><span class="coqdoc-tactic">eauto</span><span> ].</span></dt>
<dd><span class="first last">ElimBoolRewrite is defined</span></dd>
</dl>
</div>
</div>
<p>The tactics macros are synchronous with the Coq section mechanism: a
tactic definition is deleted from the current environment when you
close the section (see also <a class="reference internal" href="../language/gallina-extensions.html#section-mechanism"><span class="std std-ref">Section mechanism</span></a>) where it was
defined. If you want that a tactic macro defined in a module is usable in the
modules that require it, you should put it outside of any section.</p>
<p><a class="reference internal" href="ltac.html#ltac"><span class="std std-ref">The tactic language</span></a> gives examples of more complex
user-defined tactics.</p>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td>Actually, only the second subgoal will be generated since the
other one can be automatically checked.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>This corresponds to the cut rule of sequent calculus.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>Reminder: opaque constants will not be expanded by δ reductions.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[4]</a></td><td>The behavior of this tactic has changed a lot compared to the
versions available in the previous distributions (V6). This may cause
significant changes in your theories to obtain the same result. As a
drawback of the re-engineering of the code, this tactic has also been
completely revised to get a very compact and readable version.</td></tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ltac.html" class="btn btn-neutral float-right" title="The tactic language" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="proof-handling.html" class="btn btn-neutral" title="Proof handling" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>