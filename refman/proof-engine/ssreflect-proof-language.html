

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="ja" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="ja" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>The SSReflect proof language &mdash; Coq 8.8.2 ドキュメント</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/fonts.css" type="text/css" />
  <link rel="stylesheet" href="../_static/ansi.css" type="text/css" />
  <link rel="stylesheet" href="../_static/coqdoc.css" type="text/css" />
  <link rel="stylesheet" href="../_static/notations.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pre-text.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="検索" href="../search.html" />
    <link rel="next" title="Syntax extensions and interpretation scopes" href="../user-extensions/syntax-extensions.html" />
    <link rel="prev" title="Detailed examples of tactics" href="detailed-tactic-examples.html" /> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Coq
          

          
          </a>

          
            
            
              <div class="version">
                8.8.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">索引</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../genindex.html">Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-cmdindex.html">Command index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-tacindex.html">Tactic index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-optindex.html">Flags, options and tables index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coq-exnindex.html">Errors and warnings index</a></li>
</ul>
<p class="caption"><span class="caption-text">はじめに</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../index.html">はじめに</a></li>
<li class="toctree-l1"><a class="reference internal" href="../credits.html">Credits</a></li>
</ul>
<p class="caption"><span class="caption-text">言語</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-specification-language.html">The Gallina specification language</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/gallina-extensions.html">Extensions of <span class="smallcaps">Gallina</span></a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/coq-library.html">The <span class="smallcaps">Coq</span> library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/cic.html">Calculus of Inductive Constructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../language/module-system.html">The Module System</a></li>
</ul>
<p class="caption"><span class="caption-text">証明エンジン</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="vernacular-commands.html">Vernacular commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="proof-handling.html">Proof handling</a></li>
<li class="toctree-l1"><a class="reference internal" href="tactics.html">Tactics</a></li>
<li class="toctree-l1"><a class="reference internal" href="ltac.html">The tactic language</a></li>
<li class="toctree-l1"><a class="reference internal" href="detailed-tactic-examples.html">Detailed examples of tactics</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">The <span class="smallcaps">SSReflect</span> proof language</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">はじめに</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#acknowledgments">Acknowledgments</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#usage">Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#getting-started">Getting started</a></li>
<li class="toctree-l3"><a class="reference internal" href="#compatibility-issues">Compatibility issues</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gallina-extensions"><span class="smallcaps">Gallina</span> extensions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pattern-assignment">Pattern assignment</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pattern-conditional">Pattern conditional</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parametric-polymorphism">Parametric polymorphism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#anonymous-arguments">Anonymous arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wildcards">Wildcards</a></li>
<li class="toctree-l3"><a class="reference internal" href="#definitions">Definitions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#abbreviations">Abbreviations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#matching">Matching</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-selection">Occurrence selection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#basic-localization">Basic localization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#basic-tactics">Basic tactics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#bookkeeping">Bookkeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-defective-tactics">The defective tactics</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-move-tactic">The move tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-case-tactic">The case tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-elim-tactic">The elim tactic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-apply-tactic">The apply tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#discharge">Discharge</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#clear-rules">Clear rules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matching-for-apply-and-exact">Matching for apply and exact</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-abstract-tactic">The abstract tactic</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#introduction-in-the-context">Introduction in the context</a></li>
<li class="toctree-l3"><a class="reference internal" href="#generation-of-equations">Generation of equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-families">Type families</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#control-flow">Control flow</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#indentation-and-bullets">Indentation and bullets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#terminators">Terminators</a></li>
<li class="toctree-l3"><a class="reference internal" href="#selectors">Selectors</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iteration">Iteration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#localization">Localization</a></li>
<li class="toctree-l3"><a class="reference internal" href="#structure">Structure</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-have-tactic">The have tactic.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#generating-let-in-context-entries-with-have">Generating let in context entries with have</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-have-tactic-and-typeclass-resolution">The have tactic and typeclass resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variants-the-suff-and-wlog-tactics">Variants: the suff and wlog tactics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rewriting">Rewriting</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#an-extended-rewrite-tactic">An extended rewrite tactic</a></li>
<li class="toctree-l3"><a class="reference internal" href="#remarks-and-examples">Remarks and examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rewrite-redex-selection">Rewrite redex selection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#chained-rewrite-steps">Chained rewrite steps</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-redex-switches-are-matched-first">Explicit redex switches are matched first</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-switches-and-redex-switches">Occurrence switches and redex switches</a></li>
<li class="toctree-l4"><a class="reference internal" href="#occurrence-selection-and-repetition">Occurrence selection and repetition</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multi-rule-rewriting">Multi-rule rewriting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#wildcards-vs-abstractions">Wildcards vs abstractions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite</a></li>
<li class="toctree-l4"><a class="reference internal" href="#existential-metavariables-and-rewriting">Existential metavariables and rewriting</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#locking-unlocking">Locking, unlocking</a></li>
<li class="toctree-l3"><a class="reference internal" href="#congruence">Congruence</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#contextual-patterns">Contextual patterns</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#syntax">Syntax</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matching-contextual-patterns">Matching contextual patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="#examples">Examples</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#contextual-pattern-in-set-and-the-tactical">Contextual pattern in set and the : tactical</a></li>
<li class="toctree-l4"><a class="reference internal" href="#contextual-patterns-in-rewrite">Contextual patterns in rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#patterns-for-recurrent-contexts">Patterns for recurrent contexts</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#views-and-reflection">Views and reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-eliminations">Interpreting eliminations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-assumptions">Interpreting assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#specializing-assumptions">Specializing assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-goals">Interpreting goals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#boolean-reflection">Boolean reflection</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-reflect-predicate">The reflect predicate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#general-mechanism-for-interpreting-goals-and-assumptions">General mechanism for interpreting goals and assumptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">Specializing assumptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">Interpreting assumptions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#interpreting-equivalences">Interpreting equivalences</a></li>
<li class="toctree-l3"><a class="reference internal" href="#declaring-new-hint-views">Declaring new Hint Views</a></li>
<li class="toctree-l3"><a class="reference internal" href="#multiple-views">Multiple views</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#ssr-searching-tool"><span class="smallcaps">SSReflect</span> searching tool</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synopsis-and-index">Synopsis and Index</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#items-and-switches">Items and switches</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tactics">Tactics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tacticals">Tacticals</a></li>
<li class="toctree-l3"><a class="reference internal" href="#commands">Commands</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">ユーザ拡張</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/syntax-extensions.html">Syntax extensions and interpretation scopes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../user-extensions/proof-schemes.html">Proof schemes</a></li>
</ul>
<p class="caption"><span class="caption-text">実用ツール</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coq-commands.html">The <span class="smallcaps">Coq</span> commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="../practical-tools/coqide.html"><span class="smallcaps">Coq</span> Integrated Development Environment</a></li>
</ul>
<p class="caption"><span class="caption-text">付録</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extended-pattern-matching.html">Extended pattern matching</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/implicit-coercions.html">Implicit Coercions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/canonical-structures.html">Canonical Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/type-classes.html">Type Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/omega.html">Omega: a solver for quantifier-free problems in Presburger Arithmetic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/micromega.html">Micromega: tactics for solving arithmetic goals over ordered rings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/extraction.html">Extraction of programs in <span class="smallcaps">OCaml</span> and Haskell</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/program.html">Program</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/ring.html">The ring and field tactic families</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/nsatz.html">Nsatz: tactics for proving equalities in integral domains</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/generalized-rewriting.html">Generalized rewriting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/parallel-proof-processing.html">Asynchronous and Parallel Proof Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/miscellaneous-extensions.html">Miscellaneous extensions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../addendum/universe-polymorphism.html">Polymorphic Universes</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../zebibliography.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Coq</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>The <span class="smallcaps">SSReflect</span> proof language</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/coq/coq/blob/master/doc/sphinx/proof-engine/ssreflect-proof-language.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="math-preamble math notranslate">
\[\begin{split}\newcommand{\alors}{\textsf{then}}
\newcommand{\alter}{\textsf{alter}}
\newcommand{\as}{\kw{as}}
\newcommand{\Assum}[3]{\kw{Assum}(#1)(#2:#3)}
\newcommand{\bool}{\textsf{bool}}
\newcommand{\case}{\kw{case}}
\newcommand{\conc}{\textsf{conc}}
\newcommand{\cons}{\textsf{cons}}
\newcommand{\consf}{\textsf{consf}}
\newcommand{\conshl}{\textsf{cons\_hl}}
\newcommand{\Def}[4]{\kw{Def}(#1)(#2:=#3:#4)}
\newcommand{\emptyf}{\textsf{emptyf}}
\newcommand{\End}{\kw{End}}
\newcommand{\kwend}{\kw{end}}
\newcommand{\EqSt}{\textsf{EqSt}}
\newcommand{\even}{\textsf{even}}
\newcommand{\evenO}{\textsf{even}_\textsf{O}}
\newcommand{\evenS}{\textsf{even}_\textsf{S}}
\newcommand{\false}{\textsf{false}}
\newcommand{\filter}{\textsf{filter}}
\newcommand{\Fix}{\kw{Fix}}
\newcommand{\fix}{\kw{fix}}
\newcommand{\for}{\textsf{for}}
\newcommand{\forest}{\textsf{forest}}
\newcommand{\from}{\textsf{from}}
\newcommand{\Functor}{\kw{Functor}}
\newcommand{\haslength}{\textsf{has\_length}}
\newcommand{\hd}{\textsf{hd}}
\newcommand{\ident}{\textsf{ident}}
\newcommand{\In}{\kw{in}}
\newcommand{\Ind}[4]{\kw{Ind}[#2](#3:=#4)}
\newcommand{\ind}[3]{\kw{Ind}~[#1]\left(#2\mathrm{~:=~}#3\right)}
\newcommand{\Indp}[5]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)}
\newcommand{\Indpstr}[6]{\kw{Ind}_{#5}(#1)[#2](#3:=#4)/{#6}}
\newcommand{\injective}{\kw{injective}}
\newcommand{\kw}[1]{\textsf{#1}}
\newcommand{\lb}{\lambda}
\newcommand{\length}{\textsf{length}}
\newcommand{\letin}[3]{\kw{let}~#1:=#2~\kw{in}~#3}
\newcommand{\List}{\textsf{list}}
\newcommand{\lra}{\longrightarrow}
\newcommand{\Match}{\kw{match}}
\newcommand{\Mod}[3]{{\kw{Mod}}({#1}:{#2}\,\zeroone{:={#3}})}
\newcommand{\ModA}[2]{{\kw{ModA}}({#1}=={#2})}
\newcommand{\ModS}[2]{{\kw{Mod}}({#1}:{#2})}
\newcommand{\ModType}[2]{{\kw{ModType}}({#1}:={#2})}
\newcommand{\mto}{.\;}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\nat}{\textsf{nat}}
\newcommand{\Nil}{\textsf{nil}}
\newcommand{\nilhl}{\textsf{nil\_hl}}
\newcommand{\nO}{\textsf{O}}
\newcommand{\node}{\textsf{node}}
\newcommand{\nS}{\textsf{S}}
\newcommand{\odd}{\textsf{odd}}
\newcommand{\oddS}{\textsf{odd}_\textsf{S}}
\newcommand{\ovl}[1]{\overline{#1}}
\newcommand{\Pair}{\textsf{pair}}
\newcommand{\Prod}{\textsf{prod}}
\newcommand{\Prop}{\textsf{Prop}}
\newcommand{\return}{\kw{return}}
\newcommand{\Set}{\textsf{Set}}
\newcommand{\si}{\textsf{if}}
\newcommand{\sinon}{\textsf{else}}
\newcommand{\Sort}{\cal S}
\newcommand{\Str}{\textsf{Stream}}
\newcommand{\Struct}{\kw{Struct}}
\newcommand{\subst}[3]{#1\{#2/#3\}}
\newcommand{\tl}{\textsf{tl}}
\newcommand{\tree}{\textsf{tree}}
\newcommand{\true}{\textsf{true}}
\newcommand{\Type}{\textsf{Type}}
\newcommand{\unfold}{\textsf{unfold}}
\newcommand{\WEV}[3]{\mbox{$#1[] \vdash #2 \lra  #3$}}
\newcommand{\WEVT}[3]{\mbox{$#1[] \vdash #2 \lra$}\\ \mbox{$ #3$}}
\newcommand{\WF}[2]{{\cal W\!F}(#1)[#2]}
\newcommand{\WFE}[1]{\WF{E}{#1}}
\newcommand{\WFT}[2]{#1[] \vdash {\cal W\!F}(#2)}
\newcommand{\WFTWOLINES}[2]{{\cal W\!F}\begin{array}{l}(#1)\\\mbox{}[{#2}]\end{array}}
\newcommand{\with}{\kw{with}}
\newcommand{\WS}[3]{#1[] \vdash #2 &lt;: #3}
\newcommand{\WSE}[2]{\WS{E}{#1}{#2}}
\newcommand{\WT}[4]{#1[#2] \vdash #3 : #4}
\newcommand{\WTE}[3]{\WT{E}{#1}{#2}{#3}}
\newcommand{\WTEG}[2]{\WTE{\Gamma}{#1}{#2}}
\newcommand{\WTM}[3]{\WT{#1}{}{#2}{#3}}
\newcommand{\zeroone}[1]{[{#1}]}
\newcommand{\zeros}{\textsf{zeros}}
\end{split}\]</div>
<div class="section" id="the-ssr-proof-language">
<span id="thessreflectprooflanguage"></span><h1>The <span class="smallcaps">SSReflect</span> proof language<a class="headerlink" href="#the-ssr-proof-language" title="このヘッドラインへのパーマリンク">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Authors:</th><td class="field-body">Georges Gonthier, Assia Mahboubi, Enrico Tassi</td>
</tr>
</tbody>
</table>
<div class="section" id="introduction">
<h2>はじめに<a class="headerlink" href="#introduction" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>This chapter describes a set of tactics known as <span class="smallcaps">SSReflect</span> originally
designed to provide support for the so-called <em>small scale reflection</em>
proof methodology. Despite the original purpose this set of tactic is
of general interest and is available in <span class="smallcaps">Coq</span> starting from version 8.7.</p>
<p><span class="smallcaps">SSReflect</span> was developed independently of the tactics described in
Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. Indeed the scope of the tactics part of <span class="smallcaps">SSReflect</span> largely
overlaps with the standard set of tactics. Eventually the overlap will
be reduced in future releases of <span class="smallcaps">Coq</span>.</p>
<p>Proofs written in <span class="smallcaps">SSReflect</span> typically look quite different from the
ones written using only tactics as per Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>. We try to
summarise here the most “visible” ones in order to help the reader
already accustomed to the tactics described in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> to read
this chapter.</p>
<p>The first difference between the tactics described in this chapter and the
tactics described in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> is the way hypotheses are managed
(we call this <em>bookkeeping</em>). In Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a> the most common
approach is to avoid moving explicitly hypotheses back and forth between the
context and the conclusion of the goal. On the contrary in <span class="smallcaps">SSReflect</span> all
bookkeeping is performed on the conclusion of the goal, using for that
purpose a couple of syntactic constructions behaving similar to tacticals
(and often named as such in this chapter). The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical moves hypotheses
from the context to the conclusion, while <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> moves hypotheses from the
conclusion to the context, and <code class="docutils literal notranslate"><span class="pre">in</span></code> moves back and forth a hypothesis from the
context to the conclusion for the time of applying an action to it.</p>
<p>While naming hypotheses is commonly done by means of an <code class="docutils literal notranslate"><span class="pre">as</span></code> clause in the
basic model of Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>, it is here to <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> that this task is
devoted. Tactics frequently leave new assumptions in the conclusion, and are
often followed by <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> to explicitly name them. While generalizing the
goal is normally not explicitly needed in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>, it is an
explicit operation performed by <code class="docutils literal notranslate"><span class="pre">:</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a></p>
</div>
<p>Beside the difference of bookkeeping model, this chapter includes
specific tactics which have no explicit counterpart in Chapter <a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>
such as tactics to mix forward steps and generalizations as
<a class="reference internal" href="#coq:tacv.generally-have" title="generally have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generally</span> <span class="pre">have</span></code></a> or <a class="reference internal" href="#coq:tacv.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>.</p>
<p><span class="smallcaps">SSReflect</span> adopts the point of view that rewriting, definition
expansion and partial evaluation participate all to a same concept of
rewriting a goal in a larger sense. As such, all these functionalities
are provided by the <a class="reference internal" href="#coq:tacn.rewrite-ssreflect" title="rewrite (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic.</p>
<p><span class="smallcaps">SSReflect</span> includes a little language of patterns to select subterms in
tactics or tacticals where it matters. Its most notable application is
in the <a class="reference internal" href="#coq:tacn.rewrite-ssreflect" title="rewrite (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic, where patterns are
used to specify where the rewriting step has to take place.</p>
<p>Finally, <span class="smallcaps">SSReflect</span> supports so-called reflection steps, typically
allowing to switch back and forth between the computational view and
logical view of a concept.</p>
<p>To conclude it is worth mentioning that <span class="smallcaps">SSReflect</span> tactics can be mixed
with non <span class="smallcaps">SSReflect</span> tactics in the same proof, or in the same Ltac
expression. The few exceptions to this statement are described in
section <a class="reference internal" href="#compatibility-issues-ssr"><span class="std std-ref">Compatibility issues</span></a>.</p>
<div class="section" id="acknowledgments">
<h3>Acknowledgments<a class="headerlink" href="#acknowledgments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The authors would like to thank Frédéric Blanqui, François Pottier and
Laurence Rideau for their comments and suggestions.</p>
</div>
</div>
<div class="section" id="usage">
<h2>Usage<a class="headerlink" href="#usage" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="getting-started">
<h3>Getting started<a class="headerlink" href="#getting-started" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>To be available, the tactics presented in this manual need the
following minimal set of libraries to be loaded: <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>,
<code class="docutils literal notranslate"><span class="pre">ssrfun.v</span></code> and <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code>.
Moreover, these tactics come with a methodology
specific to the authors of <span class="smallcaps">SSReflect</span> and which requires a few options
to be set in a different way than in their default way. All in all,
this corresponds to working in the following context:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">[Loading ML file ssrmatching_plugin.cmxs ... done]
[Loading ML file ssreflect_plugin.cmxs ... done]
Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<div class="admonition seealso">
<p class="first admonition-title">参考</p>
<p class="last"><a class="reference internal" href="../language/gallina-extensions.html#coq:flag.implicit-arguments" title="Implicit Arguments"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Implicit</span> <span class="pre">Arguments</span></code></a>, <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.strict-implicit" title="Strict Implicit"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Strict</span> <span class="pre">Implicit</span></code></a>,
<a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-implicit-defensive" title="Printing Implicit Defensive"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">Implicit</span> <span class="pre">Defensive</span></code></a></p>
</div>
</div>
<div class="section" id="compatibility-issues">
<span id="compatibility-issues-ssr"></span><h3>Compatibility issues<a class="headerlink" href="#compatibility-issues" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Requiring the above modules creates an environment which is mostly
compatible with the rest of <span class="smallcaps">Coq</span>, up to a few discrepancies:</p>
<ul>
<li><p class="first">New keywords (<code class="docutils literal notranslate"><span class="pre">is</span></code>) might clash with variable, constant, tactic or
tactical names, or with quasi-keywords in tactic or vernacular
notations.</p>
</li>
<li><p class="first">New tactic(al)s names (<a class="reference internal" href="#coq:tacn.last" title="last"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">last</span></code></a>, <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a>, <a class="reference internal" href="#coq:tacn.have" title="have"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">have</span></code></a>, <a class="reference internal" href="#coq:tacv.suffices" title="suffices"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">suffices</span></code></a>,
<a class="reference internal" href="#coq:tacn.suff" title="suff"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">suff</span></code></a>, <a class="reference internal" href="#coq:tacv.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>, <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a>, <a class="reference internal" href="#coq:tacn.congr" title="congr"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">congr</span></code></a>, <a class="reference internal" href="#coq:tacn.unlock" title="unlock"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">unlock</span></code></a>)
might clash with user tactic names.</p>
</li>
<li><p class="first">Identifiers with both leading and trailing <code class="docutils literal notranslate"><span class="pre">_</span></code>, such as <code class="docutils literal notranslate"><span class="pre">_x_</span></code>, are
reserved by <span class="smallcaps">SSReflect</span> and cannot appear in scripts.</p>
</li>
<li><p class="first">The extensions to the <a class="reference internal" href="tactics.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a> tactic are partly incompatible with those
available in current versions of <span class="smallcaps">Coq</span>; in particular: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">..</span> <span class="pre">in</span>
<span class="pre">(type</span> <span class="pre">of</span> <span class="pre">k)</span></code> or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">..</span> <span class="pre">in</span> <span class="pre">*</span></code> or any other variant of <a class="reference internal" href="tactics.html#coq:tacn.rewrite" title="rewrite"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rewrite</span></code></a>
will not work, and the <span class="smallcaps">SSReflect</span> syntax and semantics for occurrence selection
and rule chaining is different. Use an explicit rewrite direction
(<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">&lt;-</span> <span class="pre">…</span></code> or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-&gt;</span> <span class="pre">…</span></code>) to access the <span class="smallcaps">Coq</span> rewrite tactic.</p>
</li>
<li><p class="first">New symbols (<code class="docutils literal notranslate"><span class="pre">//</span></code>, <code class="docutils literal notranslate"><span class="pre">/=</span></code>, <code class="docutils literal notranslate"><span class="pre">//=</span></code>) might clash with adjacent
existing symbols.
This can be avoided by inserting white spaces.</p>
</li>
<li><p class="first">New constant and theorem names might clash with the user theory.
This can be avoided by not importing all of <span class="smallcaps">SSReflect</span>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect.SsrSyntax</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p>Note that the full
syntax of <span class="smallcaps">SSReflect</span>’s rewrite and reserved identifiers are enabled
only if the ssreflect module has been required and if <code class="docutils literal notranslate"><span class="pre">SsrSyntax</span></code> has
been imported. Thus a file that requires (without importing) <code class="docutils literal notranslate"><span class="pre">ssreflect</span></code>
and imports <code class="docutils literal notranslate"><span class="pre">SsrSyntax</span></code>, can be required and imported without
automatically enabling <span class="smallcaps">SSReflect</span>’s extended rewrite syntax and
reserved identifiers.</p>
</li>
<li><p class="first">Some user notations (in particular, defining an infix <code class="docutils literal notranslate"><span class="pre">;</span></code>) might
interfere with the &quot;open term&quot;, parenthesis free, syntax of tactics
such as have, set and pose.</p>
</li>
<li><p class="first">The generalization of if statements to non-Boolean conditions is turned off
by <span class="smallcaps">SSReflect</span>, because it is mostly subsumed by Coercion to <code class="docutils literal notranslate"><span class="pre">bool</span></code> of the
<code class="docutils literal notranslate"><span class="pre">sumXXX</span></code> types (declared in <code class="docutils literal notranslate"><span class="pre">ssrfun.v</span></code>) and the
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">if</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">is</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a> <span><span class="pre">then</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">else</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> construct
(see <a class="reference internal" href="#pattern-conditional-ssr"><span class="std std-ref">Pattern conditional</span></a>).  To use the
generalized form, turn off the <span class="smallcaps">SSReflect</span> Boolean <code class="docutils literal notranslate"><span class="pre">if</span></code> notation using the command:
<code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Scope</span> <span class="pre">boolean_if_scope</span></code>.</p>
</li>
<li><p class="first">The following two options can be unset to disable the incompatible
rewrite syntax and allow reserved identifiers to appear in scripts.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-var">SsrRewrite</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-var">SsrIdents</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="gallina-extensions">
<h2><span class="smallcaps">Gallina</span> extensions<a class="headerlink" href="#gallina-extensions" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Small-scale reflection makes an extensive use of the programming
subset of <span class="smallcaps">Gallina</span>, <span class="smallcaps">Coq</span>’s logical specification language. This subset
is quite suited to the description of functions on representations,
because it closely follows the well-established design of the ML
programming language. The <span class="smallcaps">SSReflect</span> extension provides three additions
to <span class="smallcaps">Gallina</span>, for pattern assignment, pattern testing, and polymorphism;
these mitigate minor but annoying discrepancies between <span class="smallcaps">Gallina</span> and
ML.</p>
<div class="section" id="pattern-assignment">
<h3>Pattern assignment<a class="headerlink" href="#pattern-assignment" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <span class="smallcaps">SSReflect</span> extension provides the following construct for
irrefutable pattern matching, that is, destructuring assignment:</p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>let:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>Note the colon <code class="docutils literal notranslate"><span class="pre">:</span></code> after the <code class="docutils literal notranslate"><span class="pre">let</span></code> keyword, which avoids any ambiguity
with a function definition or <span class="smallcaps">Coq</span>’s basic destructuring let. The let:
construct differs from the latter in that</p>
<ul class="simple">
<li>The pattern can be nested (deep pattern matching), in particular,
this allows expression of the form:</li>
</ul>
<div class="coqdoc literal-block docutils container">
<span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">exist</span><span> (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">p_xy</span><span> := </span><span class="coqdoc-var">Hp</span><span> </span><span class="coqdoc-tactic">in</span><span> … .</span></span></div>
<ul>
<li><p class="first">The destructured constructor is explicitly given in the pattern, and
is used for type inference.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">u</span><span> := </span><span class="coqdoc-keyword">let</span><span>: (</span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">n</span><span>) := </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first last">f is defined</span></dd>
<dt><span class="coqdoc-keyword">Check</span><span> </span><span class="coqdoc-var">f</span><span>.</span></dt>
<dd><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative first">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
     : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Using <code class="code Coq docutils literal notranslate"><span class="keyword"><span class="pre">let</span></span><span class="operator"><span class="pre">:</span></span></code> Coq infers a type for <code class="code Coq docutils literal notranslate"><span class="name"><span class="pre">f</span></span></code>,
whereas with a usual <code class="docutils literal notranslate"><span class="pre">let</span></code> the same term requires an extra type
annotation in order to type check.</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">u</span><span> := </span><span class="coqdoc-keyword">let</span><span> (</span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">n</span><span>) := </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 32-33:
&gt; Definition f u := let (m, n) := u in m + n.
&gt;                                 ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Cannot infer a type for this expression.</span></dd>
</dl>
</div>
</div>
</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">let:</span></code> construct is just (more legible) notation for the primitive
<span class="smallcaps">Gallina</span> expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">with</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">end</span></span></span></code>.</p>
<p>The <span class="smallcaps">SSReflect</span> destructuring assignment supports all the dependent
match annotations; the full syntax is</p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>let:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span class="repeat-wrapper"><span class="repeat"><span>as</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>return</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>where the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> and the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> are <em>types</em>.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">as</span></code> and <code class="docutils literal notranslate"><span class="pre">return</span></code> keywords are both present, then <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is bound
in both the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> and the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>; variables
in the optional type <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> are bound only in the second term, and
other variables in the first  <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> are bound only in the third
<a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, however.</p>
</div>
<div class="section" id="pattern-conditional">
<span id="pattern-conditional-ssr"></span><h3>Pattern conditional<a class="headerlink" href="#pattern-conditional" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following construct can be used for a refutable pattern matching,
that is, pattern testing:</p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>if</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>is</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span>then</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>else</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>Although this construct is not strictly ML (it does exist in variants
such as the pattern calculus or the ρ-calculus), it turns out to be
very convenient for writing functions on representations, because most
such functions manipulate simple data types such as Peano integers,
options, lists, or binary trees, and the pattern conditional above is
almost always the right construct for analyzing such simple types. For
example, the null and all list function(al)s can be defined as follows:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<blockquote>
<div><div class="coqtop literal-block coqtop-hidden docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div></blockquote>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">d</span><span>: </span><span class="coqdoc-keyword">Set</span><span>.</span></dt>
<dd><span class="first last">d is declared</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">null</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>) :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">nil</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">false</span><span>.</span></dt>
<dd><span class="first last">null is defined
null is recursively defined (decreasing on 1st argument)</span></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">d</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd><span class="first last">a is declared</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">all</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>) : </span><span class="coqdoc-var">bool</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">x</span><span> &amp;&amp; </span><span class="coqdoc-var">all</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">true</span><span>.</span></dt>
<dd><span class="first last">all is defined
all is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
</div>
<p>The pattern conditional also provides a notation for destructuring
assignment with a refutable pattern, adapted to the pure functional
setting of <span class="smallcaps">Gallina</span>, which lacks a <code class="docutils literal notranslate"><span class="pre">Match_Failure</span></code> exception.</p>
<p>Like <code class="docutils literal notranslate"><span class="pre">let:</span></code> above, the <code class="docutils literal notranslate"><span class="pre">if…is</span></code> construct is just (more legible) notation
for the primitive <span class="smallcaps">Gallina</span> expression
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">match</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">with</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole"><span class="pre">pattern</span></span></a> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">|</span></span> <span><span class="pre">_</span></span> <span><span class="pre">=&gt;</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">end</span></span></span></code>.</p>
<p>Similarly, it will always be displayed as the expansion of this form
in terms of primitive match expressions (where the default expression
may be replicated).</p>
<p>Explicit pattern testing also largely subsumes the generalization of
the <code class="docutils literal notranslate"><span class="pre">if</span></code> construct to all binary data types; compare
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">if</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">is</span></span> <span><span class="pre">inl</span></span> <span><span class="pre">_</span></span> <span><span class="pre">then</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">else</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code> and
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">if</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">then</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a> <span><span class="pre">else</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>.</p>
<p>The latter appears to be marginally shorter, but it is quite
ambiguous, and indeed often requires an explicit annotation
<code class="docutils literal notranslate"><span class="pre">(term</span> <span class="pre">:</span> <span class="pre">{_}</span> <span class="pre">+</span> <span class="pre">{_})</span></code> to type check, which evens the character count.</p>
<p>Therefore, <span class="smallcaps">SSReflect</span> restricts by default the condition of a plain if
construct to the standard <code class="docutils literal notranslate"><span class="pre">bool</span></code> type; this avoids spurious type
annotations.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">orb</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> := </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">b2</span><span>.</span></dt>
<dd><span class="first last">orb is defined</span></dd>
</dl>
</div>
</div>
<p>As pointed out in section <a class="reference internal" href="#compatibility-issues-ssr"><span class="std std-ref">Compatibility issues</span></a>,
this restriction can be removed with
the command:</p>
<p><code class="docutils literal notranslate"><span class="pre">Close</span> <span class="pre">Scope</span> <span class="pre">boolean_if_scope.</span></code></p>
<p>Like <code class="docutils literal notranslate"><span class="pre">let:</span></code> above, the <code class="docutils literal notranslate"><span class="pre">if-is-then-else</span></code>
construct supports
the dependent match annotations:</p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>if</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>is</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span>as</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span>return</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>then</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>else</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>As in <code class="docutils literal notranslate"><span class="pre">let:</span></code> the variable <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> (and those in the type pattern)
are bound in the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>; <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is also bound in the
third <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> (but not in the fourth <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>), while the
variables in the first <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> are bound only in the third
<a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<p>Another variant allows to treat the <code class="docutils literal notranslate"><span class="pre">else</span></code> case first:</p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">+=</span> </code><span class="notation"><span>if</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>isn't</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span>then</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>else</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>Note that <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">pattern</span></code></a> eventually binds variables in the third
<a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> and not in the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
</div>
<div class="section" id="parametric-polymorphism">
<span id="parametric-polymorphism-ssr"></span><h3>Parametric polymorphism<a class="headerlink" href="#parametric-polymorphism" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Unlike ML, polymorphism in core <span class="smallcaps">Gallina</span> is explicit: the type
parameters of polymorphic functions must be declared explicitly, and
supplied at each point of use. However, <span class="smallcaps">Coq</span> provides two features to
suppress redundant parameters:</p>
<ul class="simple">
<li>Sections are used to provide (possibly implicit) parameters for a
set of definitions.</li>
<li>Implicit arguments declarations are used to tell <span class="smallcaps">Coq</span> to use type
inference to deduce some parameters from the context at each point of
call.</li>
</ul>
<p>The combination of these features provides a fairly good emulation of
ML-style polymorphism, but unfortunately this emulation breaks down
for higher-order programming. Implicit arguments are indeed not
inferred at all points of use, but only at points of call, leading to
expressions such as</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">T is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">null</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">null is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">all</span><span> : (</span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">all is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">all_null</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span>) := </span><span class="coqdoc-var">all</span><span> (&#64;</span><span class="coqdoc-var">null</span><span> </span><span class="coqdoc-var">T</span><span>) </span><span class="coqdoc-var">s</span><span>.</span></dt>
<dd><span class="first last">all_null is defined</span></dd>
</dl>
</div>
</div>
<p>Unfortunately, such higher-order expressions are quite frequent in
representation functions, especially those which use <span class="smallcaps">Coq</span>'s
<code class="docutils literal notranslate"><span class="pre">Structures</span></code> to emulate Haskell typeclasses.</p>
<p>Therefore, <span class="smallcaps">SSReflect</span> provides a variant of <span class="smallcaps">Coq</span>’s implicit argument
declaration, which causes <span class="smallcaps">Coq</span> to fill in some implicit parameters at
each point of use, e.g., the above definition can be written:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">T is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">null</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">T</span><span> : </span><span class="coqdoc-keyword">Type</span><span>, </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">null is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">all</span><span> : (</span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) -&gt; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">all is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">Prenex</span><span> </span><span class="coqdoc-var">Implicits</span><span> </span><span class="coqdoc-var">null</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">all_null</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">T</span><span>) := </span><span class="coqdoc-var">all</span><span> </span><span class="coqdoc-var">null</span><span> </span><span class="coqdoc-var">s</span><span>.</span></dt>
<dd><span class="first last">all_null is defined</span></dd>
</dl>
</div>
</div>
<p>Better yet, it can be omitted entirely, since <code class="docutils literal notranslate"><span class="pre">all_null</span> <span class="pre">s</span></code> isn’t much of
an improvement over <code class="docutils literal notranslate"><span class="pre">all</span> <span class="pre">null</span> <span class="pre">s</span></code>.</p>
<p>The syntax of the new declaration is</p>
<dl class="cmd">
<dt id="coq:cmd.prenex-implicits">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Prenex</span> <span>Implicits</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:cmd.prenex-implicits" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>Let us denote <span class="math notranslate">\(c_1\)</span> … <span class="math notranslate">\(c_n\)</span> the list of identifiers given to a
<code class="docutils literal notranslate"><span class="pre">Prenex</span> <span class="pre">Implicits</span></code> command.  The command checks that each ci is the name of
a functional constant, whose implicit arguments are prenex, i.e., the first
<span class="math notranslate">\(n_i &gt; 0\)</span> arguments of <span class="math notranslate">\(c_i\)</span> are implicit; then it assigns
<code class="docutils literal notranslate"><span class="pre">Maximal</span> <span class="pre">Implicit</span></code> status to these arguments.</p>
<p>As these prenex implicit arguments are ubiquitous and have often large
display strings, it is strongly recommended to change the default
display settings of <span class="smallcaps">Coq</span> so that they are not printed (except after
a <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Printing</span> <span class="pre">All</span></code> command). All <span class="smallcaps">SSReflect</span> library files thus start
with the incantation</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</div>
<div class="section" id="anonymous-arguments">
<h3>Anonymous arguments<a class="headerlink" href="#anonymous-arguments" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When in a definition, the type of a certain argument is mandatory, but
not its name, one usually uses “arrow” abstractions for prenex
arguments, or the <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> syntax for inner arguments. In <span class="smallcaps">SSReflect</span>,
the latter can be replaced by the open syntax <code class="docutils literal notranslate"><span class="pre">of</span> <span class="pre">term</span></code> or
(equivalently) <code class="docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">term</span></code>, which are both syntactically equivalent to a
<code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> expression. This feature almost behaves as the
following extension of the binder syntax:</p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">binder</span> <span class="pre">+=</span> </code><span class="notation"><span>&amp;</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>|</span> <span>of</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>Caveat: <code class="docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">of</span> <span class="pre">T</span></code> abbreviations have to appear at the end
of a binder list. For instance, the usual two-constructor polymorphic
type list, i.e. the one of the standard <code class="docutils literal notranslate"><span class="pre">List</span></code> library, can be
defined by the following declaration:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">list</span><span> (</span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) : </span><span class="coqdoc-keyword">Type</span><span> := </span><span class="coqdoc-var">nil</span><span> | </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">A</span><span> &amp; </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd><span class="first last">list is defined
list_rect is defined
list_ind is defined
list_rec is defined</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="wildcards">
<h3>Wildcards<a class="headerlink" href="#wildcards" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The terms passed as arguments to <span class="smallcaps">SSReflect</span> tactics can contain
<em>holes</em>, materialized by wildcards <code class="docutils literal notranslate"><span class="pre">_</span></code>. Since <span class="smallcaps">SSReflect</span> allows a more
powerful form of type inference for these arguments, it enhances the
possibilities of using such wildcards. These holes are in particular
used as a convenient shorthand for abstractions, especially in local
definitions or type expressions.</p>
<p>Wildcards may be interpreted as abstractions (see for example sections
<a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a> and ref:<cite>structure_ssr</cite>), or their content can be
inferred from the whole context of the goal (see for example section
<a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>).</p>
</div>
<div class="section" id="definitions">
<span id="definitions-ssr"></span><h3>Definitions<a class="headerlink" href="#definitions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="tacn">
<dt id="coq:tacn.pose-ssreflect">
<code class="descname"><span class="notation"><span>pose</span></span></code><a class="headerlink" href="#coq:tacn.pose-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This tactic allows to add a defined constant to a proof context.
<span class="smallcaps">SSReflect</span> generalizes this tactic in several ways. In particular, the
<span class="smallcaps">SSReflect</span> pose tactic supports <em>open syntax</em>: the body of the
definition does not need surrounding parentheses. For instance:</p>
</dd></dl>

<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-4:
&gt; pose t := x + y.
&gt; ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax error: illegal begin of vernac.</span></dd>
</dl>
</div>
<p>is a valid tactic expression.</p>
<p>The pose tactic is also improved for the local definition of higher
order terms. Local definitions of functions can use the same syntax as
global ones.
For example, the tactic <a class="reference internal" href="#coq:tacn.pose-ssreflect" title="pose (ssreflect)"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pose</span></code></a> supoprts parameters:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  f := </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>The <span class="smallcaps">SSReflect</span> pose tactic also supports (co)fixpoints, by providing
the local counterpart of the <code class="docutils literal notranslate"><span class="pre">Fixpoint</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">…</span></code> and <code class="docutils literal notranslate"><span class="pre">CoFixpoint</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">…</span></code>
constructs. For instance, the following tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-keyword">fix</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">x</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-keyword">else</span><span> 0.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-78:
&gt; pose fix f (x y : nat) {struct x} : nat :=   if x is S p then S (f p y) else 0.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfixfwd)&quot; failed.
The variable f is already declared.</span></dd>
</dl>
</div>
<p>defines a local fixpoint <code class="docutils literal notranslate"><span class="pre">f</span></code>, which mimics the standard plus operation
on natural numbers.</p>
<p>Similarly, local cofixpoints can be defined by a tactic of the form:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-keyword">cofix</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">arg</span><span> : </span><span class="coqdoc-var">T</span><span>) := … .</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 26-29:
&gt; pose cofix f (arg : T) := … .
&gt;                           ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax Error: Lexer: Undefined token</span></dd>
</dl>
</div>
<p>The possibility to include wildcards in the body of the definitions
offers a smooth way of defining local abstractions. The type of
“holes” is guessed by type inference, and the holes are abstracted.
For instance the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> := </span><span class="coqdoc-var">_</span><span> + 1.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-15:
&gt; pose f := _ + 1.
&gt; ^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfwdid) (ssrposefwd)&quot; failed.
The variable f is already declared.</span></dd>
</dl>
</div>
<p>is shorthand for:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">n</span><span> + 1.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-17:
&gt; pose f n := n + 1.
&gt; ^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfwdid) (ssrposefwd)&quot; failed.
The variable f is already declared.</span></dd>
</dl>
</div>
<p>When the local definition of a function involves both arguments and
holes, hole abstractions appear first. For instance, the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-17:
&gt; pose f x := x + _.
&gt; ^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfwdid) (ssrposefwd)&quot; failed.
The variable f is already declared.</span></dd>
</dl>
</div>
<p>is shorthand for:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-19:
&gt; pose f n x := x + n.
&gt; ^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfwdid) (ssrposefwd)&quot; failed.
The variable f is already declared.</span></dd>
</dl>
</div>
<p>The interaction of the pose tactic with the interpretation of implicit
arguments results in a powerful and concise syntax for local
definitions involving dependent types. For instance, the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> := (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-20:
&gt; pose f x y := (x, y).
&gt; ^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfwdid) (ssrposefwd)&quot; failed.
The variable f is already declared.</span></dd>
</dl>
</div>
<p>adds to the context the local definition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">Tx</span><span> </span><span class="coqdoc-var">Ty</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">Tx</span><span>) (</span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">Ty</span><span>) := (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-49:
&gt; pose f (Tx Ty : Type) (x : Tx) (y : Ty) := (x, y).
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfwdid) (ssrposefwd)&quot; failed.
The variable f is already declared.</span></dd>
</dl>
</div>
<p>The generalization of wildcards makes the use of the pose tactic
resemble ML-like definitions of polymorphic functions.</p>
</div>
<div class="section" id="abbreviations">
<span id="abbreviations-ssr"></span><h3>Abbreviations<a class="headerlink" href="#abbreviations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <span class="smallcaps">SSReflect</span> set tactic performs abbreviations: it introduces a
defined constant for a subterm appearing in the goal and/or in the
context.</p>
<p><span class="smallcaps">SSReflect</span> extends the set tactic by supplying:</p>
<ul class="simple">
<li>an open syntax, similarly to the pose tactic;</li>
<li>a more aggressive matching algorithm;</li>
<li>an improved interpretation of wildcards, taking advantage of the
matching algorithm;</li>
<li>an improved occurrence selection mechanism allowing to abstract only
selected occurrences of a term.</li>
</ul>
<p>The general syntax of this tactic is</p>
<dl class="tacn">
<dt id="coq:tacn.set-ssreflect">
<code class="descname"><span class="notation"><span>set</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.set-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-occ_switch">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">occ_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span>+</span> <span class="meta">|</span> <span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">*</span></span> }</span></span></code><a class="headerlink" href="#grammar-token-occ_switch" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where:</p>
<ul class="simple">
<li><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a fresh identifier chosen by the user.</li>
<li>term 1 is an optional type annotation. The type annotation term 1
can be given in open syntax (no surrounding parentheses). If no
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (described hereafter) is present,
it is also the case for the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.
On the other hand, in presence of <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>, parentheses
surrounding the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> are mandatory.</li>
<li>In the occurrence switch <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>, if the first element of the
list is a natural, this element should be a number, and not an Ltac
variable. The empty list <code class="docutils literal notranslate"><span class="pre">{}</span></code> is not interpreted as a valid occurrence
switch.</li>
</ul>
<p>The tactic:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">f is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> :  </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := {2}(</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>The type annotation may contain wildcards, which will be filled
with the appropriate value by the matching process.</p>
<p>The tactic first tries to find a subterm of the goal matching
the second <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>
(and its type), and stops at the first subterm it finds. Then
the occurrences of this subterm selected by the optional <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>
are replaced by <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> and a definition <code class="docutils literal notranslate"><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole"><span class="pre">ident</span></span></a> <span><span class="pre">:=</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole"><span class="pre">term</span></span></a></span></code>
is added to the
context. If no <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> is present, then all the occurrences are
abstracted.</p>
<div class="section" id="matching">
<h4>Matching<a class="headerlink" href="#matching" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The matching algorithm compares a pattern <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> with a subterm of the
goal by comparing their heads and then pairwise unifying their
arguments (modulo conversion). Head symbols match under the following
conditions:</p>
<ul class="simple">
<li>If the head of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is a constant, then it should be syntactically
equal to the head symbol of the subterm.</li>
<li>If this head is a projection of a canonical structure, then
canonical structure equations are used for the matching.</li>
<li>If the head of term is <em>not</em> a constant, the subterm should have the
same structure (λ abstraction,let…in structure …).</li>
<li>If the head of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is a hole, the subterm should have at least as
many arguments as <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) :  </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t := </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<ul>
<li><p class="first">In the special case where <code class="docutils literal notranslate"><span class="pre">term</span></code> is of the form
<code class="docutils literal notranslate"><span class="pre">(let</span> <span class="pre">f</span> <span class="pre">:=</span> <span class="pre">t0</span> <span class="pre">in</span> <span class="pre">f)</span> <span class="pre">t1</span> <span class="pre">…</span> <span class="pre">tn</span></code> , then the pattern <code class="docutils literal notranslate"><span class="pre">term</span></code> is treated
as <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">t1</span> <span class="pre">…</span> <span class="pre">tn)</span></code>. For each
subterm in the goal having the form <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">u1</span> <span class="pre">…</span> <span class="pre">um)</span></code> with m ≥ n, the
matching algorithm successively tries to find the largest partial
application <code class="docutils literal notranslate"><span class="pre">(A</span> <span class="pre">u1</span> <span class="pre">…</span> <span class="pre">uj)</span></code> convertible to the head <code class="docutils literal notranslate"><span class="pre">t0</span></code> of <code class="docutils literal notranslate"><span class="pre">term</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> 1) 2 3 = 6.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">let</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> f := </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">in</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1) 2 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">g</span><span>) 2.</span></dt>
<dd><span class="first">1 subgoal
  
  t := (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">unkeyed</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)) 2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
</dl>
</div>
</div>
<p>The notation <code class="docutils literal notranslate"><span class="pre">unkeyed</span></code> defined in <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> is a shorthand for
the degenerate term <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">…</span> <span class="pre">in</span> <span class="pre">x</span></code>.</p>
</li>
</ul>
<p>Moreover:</p>
<ul>
<li><p class="first">Multiple holes in <code class="docutils literal notranslate"><span class="pre">term</span></code> are treated as independent placeholders.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</li>
<li><p class="first">The type of the subterm matched should fit the type (possibly casted
by some type annotations) of the pattern <code class="docutils literal notranslate"><span class="pre">term</span></code>.</p>
</li>
<li><p class="first">The replacement of the subterm found by the instantiated pattern
should not capture variables. In the example above <code class="docutils literal notranslate"><span class="pre">x</span></code> is bound
and should not be captured.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> + 1 = 0.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">_</span><span> + 1.</span></dt>
<dd><span class="first">Toplevel input, characters 0-14:
&gt; set t := _ + 1.
&gt; ^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrfwdid) (ssrsetfwd) (ssrclauses)&quot; failed.
The pattern (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 1) did not match and has holes. Did you mean pose?</span></dd>
</dl>
</div>
</div>
</li>
<li><p class="first">Typeclass inference should fill in any residual hole, but matching
should never assign a value to a global existential variable.</p>
</li>
</ul>
</div>
<div class="section" id="occurrence-selection">
<span id="occurrence-selection-ssr"></span><h4>Occurrence selection<a class="headerlink" href="#occurrence-selection" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p><span class="smallcaps">SSReflect</span> provides a generic syntax for the selection of occurrences
by their position indexes. These <em>occurrence switches</em> are shared by
all <span class="smallcaps">SSReflect</span> tactics which require control on subterm selection like
rewriting, generalization, …</p>
<p>An <em>occurrence switch</em> can be:</p>
<ul>
<li><p class="first">A list natural numbers <code class="docutils literal notranslate"><span class="pre">{+</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code>
of occurrences affected by the tactic.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">f is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 8 = </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 2.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 8</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 2</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">x</span><span> := {+1 3}(</span><span class="coqdoc-var">f</span><span> 2).</span></dt>
<dd><span class="first">1 subgoal
  
  x := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 8</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Notice that some occurrences of a given term may be
hidden to the user, for example because of a notation. The vernacular
<code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">Printing</span> <span class="pre">All</span></code> command displays all these hidden occurrences and
should be used to find the correct coding of the occurrences to be
selected <a class="footnote-reference" href="#id12" id="id1">[10]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;a &lt; b&quot;:= (</span><span class="coqdoc-var">le</span><span> (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">a</span><span>) </span><span class="coqdoc-var">b</span><span>).</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</li>
<li><p class="first">A list of natural numbers between <code class="docutils literal notranslate"><span class="pre">{n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code>.
This is equivalent to the previous <code class="docutils literal notranslate"><span class="pre">{+</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code> but the list
should start with a number, and not with an Ltac variable.</p>
</li>
<li><p class="first">A list <code class="docutils literal notranslate"><span class="pre">{-</span> <span class="pre">n1</span> <span class="pre">…</span> <span class="pre">nm}</span></code> of occurrences <em>not</em> to be affected by the
tactic.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">f is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 8 = </span><span class="coqdoc-var">f</span><span> 2 + </span><span class="coqdoc-var">f</span><span> 2.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 8</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 2</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">x</span><span> := {-2}(</span><span class="coqdoc-var">f</span><span> 2).</span></dt>
<dd><span class="first">1 subgoal
  
  x := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 8</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Note that, in this goal, it behaves like <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">{1</span> <span class="pre">3}(f</span> <span class="pre">2).</span></code></p>
</li>
<li><p class="first">In particular, the switch <code class="docutils literal notranslate"><span class="pre">{+}</span></code> selects <em>all</em> the occurrences. This
switch is useful to turn off the default behavior of a tactic which
automatically clears some assumptions (see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a> for
instance).</p>
</li>
<li><p class="first">The switch <code class="docutils literal notranslate"><span class="pre">{-}</span></code> imposes that <em>no</em> occurrences of the term should be
affected by the tactic. The tactic: <code class="docutils literal notranslate"><span class="pre">set</span> <span class="pre">x</span> <span class="pre">:=</span> <span class="pre">{-}(f</span> <span class="pre">2).</span></code> leaves the goal
unchanged and adds the definition <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">:=</span> <span class="pre">f</span> <span class="pre">2</span></code> to the context. This kind
of tactic may be used to take advantage of the power of the matching
algorithm in a local definition, instead of copying large terms by
hand.</p>
</li>
</ul>
<p>It is important to remember that matching <em>preceeds</em> occurrence
selection.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">z</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">a</span><span> := {2}(</span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">_</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div></blockquote>
<p>Hence, in the following goal, the same tactic fails since there is
only one occurrence of the selected term.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>) + (</span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">z</span><span>) = </span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">z</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">a</span><span> := {2}(</span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">_</span><span>).</span></dt>
<dd><span class="first">Toplevel input, characters 0-19:
&gt; set a := {2}(_ + _).
&gt; ^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">set</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrfwdid) (ssrsetfwd) (ssrclauses)&quot; failed.
Only 1 &lt; 2 occurence of (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">))</span></dd>
</dl>
</div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="basic-localization">
<span id="basic-localization-ssr"></span><h3>Basic localization<a class="headerlink" href="#basic-localization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>It is possible to define an abbreviation for a term appearing in the
context of a goal thanks to the in tactical.</p>
<p>A tactic of the form:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>set</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<p>introduces a defined constant called <code class="docutils literal notranslate"><span class="pre">x</span></code> in the context, and folds it in
the context entries mentioned on the right hand side of <code class="docutils literal notranslate"><span class="pre">in</span></code>.
The body of <code class="docutils literal notranslate"><span class="pre">x</span></code> is the first subterm matching these context entries
(taken in the given order).</p>
<p>A tactic of the form:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>set</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>*</span></span></code></dt>
<dd></dd></dl>

<p>matches term and then folds <code class="docutils literal notranslate"><span class="pre">x</span></code> similarly in all the given context entries
but also folds <code class="docutils literal notranslate"><span class="pre">x</span></code> in the goal.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">t</span><span> (</span><span class="coqdoc-var">Hx</span><span> : </span><span class="coqdoc-var">x</span><span> = 3) : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">t</span><span> = 4.</span></dt>
<dd><span class="first">1 subgoal
  
  x, t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hx : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 4</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">z</span><span> := 3 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">Hx</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  z := 3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hx : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 4</span></dd>
</dl>
</div>
</div>
</div></blockquote>
<p>If the localization also mentions the goal, then the result is the following one:</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">t</span><span> (</span><span class="coqdoc-var">Hx</span><span> : </span><span class="coqdoc-var">x</span><span> = 3) : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">t</span><span> = 4.</span></dt>
<dd><span class="first">1 subgoal
  
  x, t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hx : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 4</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">z</span><span> := 3 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">Hx</span><span> * .</span></dt>
<dd><span class="first">1 subgoal
  
  x, t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  z := 3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hx : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div></blockquote>
<p>Indeed, remember that 4 is just a notation for (S 3).</p>
<p>The use of the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical is not limited to the localization of
abbreviations: for a complete description of the in tactical, see
section <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a> and <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>.</p>
</div>
</div>
<div class="section" id="basic-tactics">
<span id="basic-tactics-ssr"></span><h2>Basic tactics<a class="headerlink" href="#basic-tactics" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>A sizable fraction of proof scripts consists of steps that do not
&quot;prove&quot; anything new, but instead perform menial bookkeeping tasks
such as selecting the names of constants and assumptions or splitting
conjuncts. Although they are logically trivial, bookkeeping steps are
extremely important because they define the structure of the data-flow
of a proof script. This is especially true for reflection-based
proofs, which often involve large numbers of constants and
assumptions. Good bookkeeping consists in always explicitly declaring
(i.e., naming) all new constants and assumptions in the script, and
systematically pruning irrelevant constants and assumptions in the
context. This is essential in the context of an interactive
development environment (IDE), because it facilitates navigating the
proof, allowing to instantly &quot;jump back&quot; to the point at which a
questionable assumption was added, and to find relevant assumptions by
browsing the pruned context. While novice or casual <span class="smallcaps">Coq</span> users may find
the automatic name selection feature convenient, the usage of such a
feature severely undermines the readability and maintainability of
proof scripts, much like automatic variable declaration in programming
languages. The <span class="smallcaps">SSReflect</span> tactics are therefore designed to support
precise bookkeeping and to eliminate name generation heuristics. The
bookkeeping features of <span class="smallcaps">SSReflect</span> are implemented as tacticals (or
pseudo-tacticals), shared across most <span class="smallcaps">SSReflect</span> tactics, and thus form
the foundation of the <span class="smallcaps">SSReflect</span> proof language.</p>
<div class="section" id="bookkeeping">
<span id="bookkeeping-ssr"></span><h3>Bookkeeping<a class="headerlink" href="#bookkeeping" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>During the course of a proof <span class="smallcaps">Coq</span> always present the user with a
<em>sequent</em> whose general form is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>ci : Ti
…
dj := ej : Tj
…
Fk : Pk
…
=================
forall (xl : Tl ) …,
let ym := bm in … in
Pn -&gt; … -&gt; C
</pre></div>
</div>
<p>The <em>goal</em> to be proved appears below the double line; above the line
is the <em>context</em> of the sequent, a set of declarations of <em>constants</em>
<code class="docutils literal notranslate"><span class="pre">ci</span></code> , <em>defined constants</em> d i , and <em>facts</em> <code class="docutils literal notranslate"><span class="pre">Fk</span></code> that can be used to
prove the goal (usually, <code class="docutils literal notranslate"><span class="pre">Ti</span></code> , <code class="docutils literal notranslate"><span class="pre">Tj</span> <span class="pre">:</span> <span class="pre">Type</span></code> and <code class="docutils literal notranslate"><span class="pre">Pk</span> <span class="pre">:</span> <span class="pre">Prop</span></code>).
The various
kinds of declarations can come in any order. The top part of the
context consists of declarations produced by the Section
commands <code class="docutils literal notranslate"><span class="pre">Variable</span></code>, <code class="docutils literal notranslate"><span class="pre">Let</span></code>, and <code class="docutils literal notranslate"><span class="pre">Hypothesis</span></code>.
This <em>section context</em> is never
affected by the <span class="smallcaps">SSReflect</span> tactics: they only operate on the lower part
— the <em>proof context</em>. As in the figure above, the goal often
decomposes into a series of (universally) quantified <em>variables</em>
<code class="docutils literal notranslate"><span class="pre">(xl</span> <span class="pre">:</span> <span class="pre">Tl)</span></code>, local <em>definitions</em>
<code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">ym</span> <span class="pre">:=</span> <span class="pre">bm</span> <span class="pre">in</span></code>, and <em>assumptions</em>
<code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span> <span class="pre">-&gt;</span></code>,
and a <em>conclusion</em> <code class="docutils literal notranslate"><span class="pre">C</span></code> (as in the context, variables, definitions, and
assumptions can appear in any order). The conclusion is what actually
needs to be proved — the rest of the goal can be seen as a part of the
proof context that happens to be “below the line”.</p>
<p>However, although they are logically equivalent, there are fundamental
differences between constants and facts on the one hand, and variables
and assumptions on the others. Constants and facts are <em>unordered</em>,
but <em>named</em> explicitly in the proof text; variables and assumptions
are <em>ordered</em>, but <em>unnamed</em>: the display names of variables may
change at any time because of α-conversion.</p>
<p>Similarly, basic deductive steps such as apply can only operate on the
goal because the <span class="smallcaps">Gallina</span> terms that control their action (e.g., the
type of the lemma used by <code class="docutils literal notranslate"><span class="pre">apply</span></code>) only provide unnamed bound variables.
<a class="footnote-reference" href="#id13" id="id2">[11]</a> Since the proof script can only refer directly to the context, it
must constantly shift declarations from the goal to the context and
conversely in between deductive steps.</p>
<p>In <span class="smallcaps">SSReflect</span> these moves are performed by two <em>tacticals</em> <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">:</span></code>, so that the bookkeeping required by a deductive step can be
directly associated to that step, and that tactics in an <span class="smallcaps">SSReflect</span>
script correspond to actual logical steps in the proof rather than
merely shuffle facts. Still, some isolated bookkeeping is unavoidable,
such as naming variables and assumptions at the beginning of a
proof. <span class="smallcaps">SSReflect</span> provides a specific <code class="docutils literal notranslate"><span class="pre">move</span></code> tactic for this purpose.</p>
<p>Now <code class="docutils literal notranslate"><span class="pre">move</span></code> does essentially nothing: it is mostly a placeholder for
<code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">:</span></code>. The <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical moves variables, local definitions,
and assumptions to the context, while the <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical moves facts and
constants to the goal.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>For example, the proof of <a class="footnote-reference" href="#id14" id="id3">[12]</a></p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">subnK</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">n</span><span> &lt;= </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">m</span><span> - </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> m n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>might start with</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  m, n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  le_n_m : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>where move does nothing, but <code class="docutils literal notranslate"><span class="pre">=&gt;</span> <span class="pre">m</span> <span class="pre">n</span> <span class="pre">le_m_n</span></code> changes
the variables and assumption of the goal in the constants
<code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat</span></code> and the fact <code class="docutils literal notranslate"><span class="pre">le_n_m</span> <span class="pre">:</span> <span class="pre">n</span> <span class="pre">&lt;=</span>&#160; <span class="pre">m</span></code>, thus exposing the
conclusion <code class="docutils literal notranslate"><span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical is the converse of <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>, indeed it removes facts and
constants from the context by turning them into variables and
assumptions.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">turns back <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">le_m_n</span></code> into a variable and an assumption,
removing them from the proof context, and changing the goal to
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>
which can be proved by induction on <code class="docutils literal notranslate"><span class="pre">n</span></code> using <code class="docutils literal notranslate"><span class="pre">elim:</span> <span class="pre">n</span></code>.</p>
</div>
<p>Because they are tacticals, <code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> can be combined, as in</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> =&gt; </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">le_n_p</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 8-14:
&gt; move: m le_n_m =&gt; p le_n_p.
&gt;         ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">move</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrmovearg) (ssrclauses)&quot; failed.
       The reference le_n_m was not found in the current environment.</span></dd>
</dl>
</div>
<p>simultaneously renames <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">le_m_n</span></code> into <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">le_n_p</span></code>,
respectively, by first turning them into unnamed variables, then
turning these variables back into constants and facts.</p>
<p>Furthermore, <span class="smallcaps">SSReflect</span> redefines the basic <span class="smallcaps">Coq</span> tactics <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code>,
and <code class="docutils literal notranslate"><span class="pre">apply</span></code> so that they can take better advantage of
<code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>. In there
<span class="smallcaps">SSReflect</span> variants, these tactic operate on the first variable or
constant of the goal and they do not use or change the proof context.
The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical is used to operate on an element in the context.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<blockquote>
<div>For instance the proof of <code class="docutils literal notranslate"><span class="pre">subnK</span></code> could continue with <code class="docutils literal notranslate"><span class="pre">elim:</span> <span class="pre">n</span></code>.
Instead of <code class="docutils literal notranslate"><span class="pre">elim</span> <span class="pre">n</span></code> (note, no colon), this has the advantage of
removing n from the context. Better yet, this <code class="docutils literal notranslate"><span class="pre">elim</span></code> can be combined
with previous move and with the branching version of the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical
(described in <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>),
to encapsulate the inductive step in a single
command:</div></blockquote>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">subnK</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">n</span><span> &lt;= </span><span class="coqdoc-var">m</span><span> -&gt; </span><span class="coqdoc-var">m</span><span> - </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> m n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  m, n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  le_n_m : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">IHn</span><span>] </span><span class="coqdoc-var">m</span><span> =&gt; [</span><span class="coqdoc-var">_</span><span> | </span><span class="coqdoc-var">lt_n_m</span><span>].</span></dt>
<dd><span class="first">2 subgoals
  
  m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">which breaks down the proof into two subgoals, the second one
having in its context
<code class="docutils literal notranslate"><span class="pre">lt_n_m</span> <span class="pre">:</span> <span class="pre">S</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span></code> and
<code class="docutils literal notranslate"><span class="pre">IHn</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">m,</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">m</span> <span class="pre">-&gt;</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">m</span></code>.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> and <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tacticals can be explained very simply if one views
the goal as a stack of variables and assumptions piled on a conclusion:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">:</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> pushes the context constants <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code> as goal
variables <em>before</em> performing tactic.</li>
<li><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c</span></code> pops the top three goal variables as context
constants <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, <code class="docutils literal notranslate"><span class="pre">c</span></code>, <em>after</em> tactic has been performed.</li>
</ul>
<p>These pushes and pops do not need to balance out as in the examples
above, so <code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">m</span> <span class="pre">le_n_m</span> <span class="pre">=&gt;</span> <span class="pre">p</span></code>
would rename <code class="docutils literal notranslate"><span class="pre">m</span></code> into <code class="docutils literal notranslate"><span class="pre">p</span></code>, but leave an extra assumption <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">p</span></code>
in the goal.</p>
<p>Basic tactics like apply and elim can also be used without the ’:’
tactical: for example we can directly start a proof of <code class="docutils literal notranslate"><span class="pre">subnK</span></code> by
induction on the top variable <code class="docutils literal notranslate"><span class="pre">m</span></code> with</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>=&gt; [|</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">IHm</span><span>] </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">le_n</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-22:
&gt; elim=&gt; [|m IHm] n le_n.
&gt; ^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">elim</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrarg) (ssrclauses)&quot; failed.
No assumption in (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>The general form of the localization tactical in is also best
explained in terms of the goal stack:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>tactic in a H1 H2 *.
</pre></div>
</div>
<p>is basically equivalent to</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span>; </span><span class="coqdoc-var">tactic</span><span> =&gt; </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">H1</span><span> </span><span class="coqdoc-var">H2</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 15-21:
&gt; move: a H1 H2; tactic =&gt; a H1 H2.
&gt;                ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference tactic was not found in the current environment.</span></dd>
</dl>
</div>
<p>with two differences: the in tactical will preserve the body of a ifa
is a defined constant, and if the <code class="docutils literal notranslate"><span class="pre">*</span></code> is omitted it will use a
temporary abbreviation to hide the statement of the goal from
<code class="docutils literal notranslate"><span class="pre">tactic</span></code>.</p>
<p>The general form of the in tactical can be used directly with the
<code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code> and <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactics, so that one can write</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">IHn</span><span>] </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> *.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 25-31:
&gt; elim: n =&gt; [|n IHn] in m le_n_m *.
&gt;                          ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No such hypothesis: le_n_m</span></dd>
</dl>
</div>
<p>instead of</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">IHn</span><span>] </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">le_n_m</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 10-16:
&gt; elim: n m le_n_m =&gt; [|n IHn] m le_n_m.
&gt;           ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">elim</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrarg) (ssrclauses)&quot; failed.
       The reference le_n_m was not found in the current environment.</span></dd>
</dl>
</div>
<p>This is quite useful for inductive proofs that involve many facts.</p>
<p>See section <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a> for
the general syntax and presentation of the in
tactical.</p>
</div>
<div class="section" id="the-defective-tactics">
<span id="the-defective-tactics-ssr"></span><h3>The defective tactics<a class="headerlink" href="#the-defective-tactics" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In this section we briefly present the three basic tactics performing
context manipulations and the main backward chaining tool.</p>
<div class="section" id="the-move-tactic">
<h4>The move tactic.<a class="headerlink" href="#the-move-tactic" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The move tactic, in its defective form, behaves like the primitive <code class="docutils literal notranslate"><span class="pre">hnf</span></code>
<span class="smallcaps">Coq</span> tactic. For example, such a defective:</p>
<dl class="tacn">
<dt id="coq:tacn.move">
<code class="descname"><span class="notation"><span>move</span></span></code><a class="headerlink" href="#coq:tacn.move" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>exposes the first assumption in the goal, i.e. its changes the
goal <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">False</span></code> into <code class="docutils literal notranslate"><span class="pre">False</span> <span class="pre">-&gt;</span> <span class="pre">False</span></code>.</p>
<p>More precisely, the <code class="docutils literal notranslate"><span class="pre">move</span></code> tactic inspects the goal and does nothing
(<code class="docutils literal notranslate"><span class="pre">idtac</span></code>) if an introduction step is possible, i.e. if the goal is a
product or a <code class="docutils literal notranslate"><span class="pre">let…in</span></code>, and performs <code class="docutils literal notranslate"><span class="pre">hnf</span></code> otherwise.</p>
<p>Of course this tactic is most often used in combination with the
bookkeeping tacticals (see section <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a> and <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>). These
combinations mostly subsume the <a class="reference internal" href="tactics.html#coq:tacv.intros" title="intros"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">intros</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.generalize" title="generalize"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">generalize</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.revert" title="revert"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">revert</span></code></a>, <a class="reference internal" href="tactics.html#coq:tacn.rename" title="rename"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">rename</span></code></a>,
<a class="reference internal" href="tactics.html#coq:tacn.clear" title="clear"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">clear</span></code></a> and <a class="reference internal" href="tactics.html#coq:tacn.pattern" title="pattern"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">pattern</span></code></a> tactics.</p>
</div>
<div class="section" id="the-case-tactic">
<h4>The case tactic<a class="headerlink" href="#the-case-tactic" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic performs <em>primitive case analysis</em> on (co)inductive
types; specifically, it destructs the top variable or assumption of
the goal, exposing its constructor(s) and its arguments, as well as
setting the value of its type family indices if it belongs to a type
family (see section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>).</p>
<p>The <span class="smallcaps">SSReflect</span> case tactic has a special behavior on equalities. If the
top assumption of the goal is an equality, the case tactic “destructs”
it as a set of equalities between the constructor arguments of its
left and right hand sides, as per the tactic injection. For example,
<code class="docutils literal notranslate"><span class="pre">case</span></code> changes the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>(x, y) = (1, 2) -&gt; G.
</pre></div>
</div>
<p>into:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>x = 1 -&gt; y = 2 -&gt; G.
</pre></div>
</div>
<p>Note also that the case of <span class="smallcaps">SSReflect</span> performs <code class="docutils literal notranslate"><span class="pre">False</span></code> elimination, even
if no branch is generated by this case operation. Hence the command:
<code class="docutils literal notranslate"><span class="pre">case.</span></code> on a goal of the form <code class="docutils literal notranslate"><span class="pre">False</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code> will succeed and
prove the goal.</p>
</div>
<div class="section" id="the-elim-tactic">
<h4>The elim tactic<a class="headerlink" href="#the-elim-tactic" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic performs inductive elimination on inductive types. The
defective:</p>
<dl class="tacn">
<dt id="coq:tacn.elim-ssreflect">
<code class="descname"><span class="notation"><span>elim</span></span></code><a class="headerlink" href="#coq:tacn.elim-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>tactic performs inductive elimination on a goal whose top assumption
has an inductive type.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">elim</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="the-apply-tactic">
<span id="apply-ssr"></span><h4>The apply tactic<a class="headerlink" href="#the-apply-tactic" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">apply</span></code> tactic is the main backward chaining tactic of the proof
system. It takes as argument any <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> and applies it to the goal.
Assumptions in the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> that don’t directly match the goal
may generate one or more subgoals.</p>
<p>In fact the <span class="smallcaps">SSReflect</span> tactic:</p>
<dl class="tacn">
<dt id="coq:tacn.apply-ssreflect">
<code class="descname"><span class="notation"><span>apply</span></span></code><a class="headerlink" href="#coq:tacn.apply-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>is a synonym for:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>intro top; first [refine top | refine (top _) | refine (top _ _) | …]; clear top.
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">top</span></code> is a fresh name, and the sequence of refine tactics tries to
catch the appropriate number of wildcards to be inserted. Note that
this use of the refine tactic implies that the tactic tries to match
the goal up to expansion of constants and evaluation of subterms.</p>
<p><span class="smallcaps">SSReflect</span>’s apply has a special behavior on goals containing
existential metavariables of sort Prop.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">lt_trans</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span>, </span><span class="coqdoc-var">a</span><span> &lt; </span><span class="coqdoc-var">b</span><span> -&gt; </span><span class="coqdoc-var">b</span><span> &lt; </span><span class="coqdoc-var">c</span><span> -&gt; </span><span class="coqdoc-var">a</span><span> &lt; </span><span class="coqdoc-var">c</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">lt_trans is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">y</span><span>, 1 &lt; </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">y</span><span> &lt; 2 -&gt; </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span> : { </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">n</span><span> &lt; 3 }, 0 &lt; </span><span class="coqdoc-var">proj1_sig</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
  1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exists</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">{</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">}</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">proj1_sig</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">y_gt1</span><span> </span><span class="coqdoc-var">y_lt2</span><span>; </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">ex_intro</span><span> </span><span class="coqdoc-var">_</span><span> (</span><span class="coqdoc-var">exist</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">_</span><span>)).</span></dt>
<dd><span class="first">2 focused subgoals
(shelved: 2)
  
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y_gt1 : 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y_lt2 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Hyp0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3, 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">proj1_sig</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exist</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Hyp0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">lt_trans</span><span> </span><span class="coqdoc-var">y_lt2</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y_gt1 : 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  y_lt2 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Hyp0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3, 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">proj1_sig</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exist</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Hyp0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">y_lt3</span><span>; </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">lt_trans</span><span> </span><span class="coqdoc-var">y_gt1</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
<p>Note that the last <code class="docutils literal notranslate"><span class="pre">_</span></code> of the tactic
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">(ex_intro</span> <span class="pre">_</span> <span class="pre">(exist</span> <span class="pre">_</span> <span class="pre">y</span> <span class="pre">_))</span></code>
represents a proof that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>. Instead of generating the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0 &lt; proj1_sig (exist (fun n : nat =&gt; n &lt; 3) y ?Goal).
</pre></div>
</div>
<p>the system tries to prove <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> calling the trivial tactic.
If it succeeds, let’s say because the context contains
<code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>, then the
system generates the following goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>0 &lt; proj1_sig (exist (fun n =&gt; n &lt; 3) y H).
</pre></div>
</div>
<p>Otherwise the missing proof is considered to be irrelevant, and is
thus discharged generating the two goals shown above.</p>
<p class="last">Last, the user can replace the trivial tactic by defining an Ltac
expression named <code class="docutils literal notranslate"><span class="pre">ssrautoprop</span></code>.</p>
</div>
</div>
</div>
<div class="section" id="discharge">
<span id="discharge-ssr"></span><h3>Discharge<a class="headerlink" href="#discharge" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The general syntax of the discharging tactical <code class="docutils literal notranslate"><span class="pre">:</span></code> is:</p>
<dl class="tacn">
<dt id="coq:tacn.ssreflect">
<code class="descname"><span class="notation"><span class="hole">tactic</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-d_item">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">d_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#grammar-token-d_item" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-clear_switch">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">clear_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> }</span></span></code><a class="headerlink" href="#grammar-token-clear_switch" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>with the following requirements:</p>
<ul class="simple">
<li><code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> must be one of the four basic tactics described in <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>,
i.e., <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code> or <code class="docutils literal notranslate"><span class="pre">apply</span></code>, the <code class="docutils literal notranslate"><span class="pre">exact</span></code>
tactic (section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>),
the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic (section <a class="reference internal" href="#congruence-ssr"><span class="std std-ref">Congruence</span></a>),
or the application of the <em>view</em>
tactical ‘/’ (section <a class="reference internal" href="#interpreting-assumptions-ssr"><span class="std std-ref">Interpreting assumptions</span></a>) to one of move, case, or elim.</li>
<li>The optional <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> specifies <em>equation generation</em> (section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>),
and is only allowed if tactic is <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>, or the
application of the view tactical ‘/’ (section <a class="reference internal" href="#interpreting-assumptions-ssr"><span class="std std-ref">Interpreting assumptions</span></a>) to <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>.</li>
<li>An <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> selects occurrences of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, as in <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>; <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>
is not allowed if <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> is <code class="docutils literal notranslate"><span class="pre">apply</span></code> or <code class="docutils literal notranslate"><span class="pre">exact</span></code>.</li>
<li>A clear item <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> specifies facts and constants to be
deleted from the proof context (as per the clear tactic).</li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical first <em>discharges</em> all the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, right to left,
and then performs tactic, i.e., for each <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, starting with the last one :</p>
<ol class="arabic simple">
<li>The <span class="smallcaps">SSReflect</span> matching algorithm described in section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a> is
used to find occurrences of term in the goal, after filling any holes
‘_’ in term; however if tactic is apply or exact a different matching
algorithm, described below, is used <a class="footnote-reference" href="#id15" id="id4">[13]</a>.</li>
<li>These occurrences are replaced by a new variable; in particular, if
term is a fact, this adds an assumption to the goal.</li>
<li>If term is <em>exactly</em> the name of a constant or fact in the proof
context, it is deleted from the context, unless there is an
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a>.</li>
</ol>
<p>Finally, tactic is performed just after the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
has been generalized
— that is, between steps 2 and 3. The names listed in
the final <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> (if it is present) are cleared first, before
<a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> n is discharged.</p>
<p>Switches affect the discharging of a <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> as follows:</p>
<ul class="simple">
<li>An <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> restricts generalization (step 2) to a specific subset
of the occurrences of term, as per section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>, and prevents clearing (step
3).</li>
<li>All the names specified by a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> are deleted from the
context in step 3, possibly in addition to term.</li>
</ul>
<p>For example, the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>: </span><span class="coqdoc-var">n</span><span> {2}</span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">refl_equal</span><span> </span><span class="coqdoc-var">n</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-28:
&gt; move: n {2}n (refl_equal n).
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No such goal.</span></dd>
</dl>
</div>
<ul class="simple">
<li>first generalizes <code class="docutils literal notranslate"><span class="pre">(refl_equal</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">n)</span></code>;</li>
<li>then generalizes the second occurrence of <code class="docutils literal notranslate"><span class="pre">n</span></code>.</li>
<li>finally generalizes all the other occurrences of <code class="docutils literal notranslate"><span class="pre">n</span></code>, and clears <code class="docutils literal notranslate"><span class="pre">n</span></code>
from the proof context (assuming n is a proof constant).</li>
</ul>
<p>Therefore this tactic changes any goal <code class="docutils literal notranslate"><span class="pre">G</span></code> into</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">n0</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n0</span><span> -&gt; </span><span class="coqdoc-var">G</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-6:
&gt; forall n n0 : nat, n = n0 -&gt; G.
&gt; ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax error: illegal begin of vernac.</span></dd>
</dl>
</div>
<p>where the name <code class="docutils literal notranslate"><span class="pre">n0</span></code> is picked by the <span class="smallcaps">Coq</span> display function, and assuming
<code class="docutils literal notranslate"><span class="pre">n</span></code> appeared only in <code class="docutils literal notranslate"><span class="pre">G</span></code>.</p>
<p>Finally, note that a discharge operation generalizes defined constants
as variables, and not as local definitions. To override this behavior,
prefix the name of the local definition with a <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, like in <code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">&#64;n</span></code>.</p>
<p>This is in contrast with the behavior of the in tactical (see
section <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>), which preserves local
definitions by default.</p>
<div class="section" id="clear-rules">
<h4>Clear rules<a class="headerlink" href="#clear-rules" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The clear step will fail if term is a proof constant that appears in
other facts; in that case either the facts should be cleared
explicitly with a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>, or the clear step should be disabled.
The latter can be done by adding an <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> or simply by putting
parentheses around term: both
<code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">(n).</span></code>
and
<code class="docutils literal notranslate"><span class="pre">move:</span> <span class="pre">{+}n.</span></code>
generalize <code class="docutils literal notranslate"><span class="pre">n</span></code> without clearing <code class="docutils literal notranslate"><span class="pre">n</span></code> from the proof context.</p>
<p>The clear step will also fail if the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> contains a <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> that
is not in the <em>proof</em> context. Note that <span class="smallcaps">SSReflect</span> never clears a
section constant.</p>
<p>If tactic is <code class="docutils literal notranslate"><span class="pre">move</span></code> or <code class="docutils literal notranslate"><span class="pre">case</span></code> and an equation <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is given, then clear
(step 3) for <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> is suppressed (see section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>).</p>
</div>
<div class="section" id="matching-for-apply-and-exact">
<h4>Matching for apply and exact<a class="headerlink" href="#matching-for-apply-and-exact" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The matching algorithm for <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> of the <span class="smallcaps">SSReflect</span>
<code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">exact</span></code>
tactics exploits the type of the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> to interpret
wildcards in the
other <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> and to determine which occurrences of these should be
generalized. Therefore, occur switches are not needed for apply and
exact.</p>
<p>Indeed, the <span class="smallcaps">SSReflect</span> tactic <code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">H</span> <span class="pre">x</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">(&#64;H</span> <span class="pre">_</span> <span class="pre">…</span> <span class="pre">_</span> <span class="pre">x);</span> <span class="pre">clear</span> <span class="pre">H</span> <span class="pre">x</span></code>
with an appropriate number of wildcards between <code class="docutils literal notranslate"><span class="pre">H</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<p>Note that this means that matching for <code class="docutils literal notranslate"><span class="pre">apply</span></code> and <code class="docutils literal notranslate"><span class="pre">exact</span></code> has much more
context to interpret wildcards; in particular it can accommodate the
<code class="docutils literal notranslate"><span class="pre">_</span></code> <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>, which would always be rejected after <code class="docutils literal notranslate"><span class="pre">move:</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">f</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">f is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">g</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">g is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">Hfg</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">x</span><span>) </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  Hfg : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">trans_equal</span><span> (</span><span class="coqdoc-var">Hfg</span><span> </span><span class="coqdoc-var">_</span><span>) </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  Hfg : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>This tactic is equivalent (see section
<a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>) to:
<code class="docutils literal notranslate"><span class="pre">refine</span> <span class="pre">(trans_equal</span> <span class="pre">(Hfg</span> <span class="pre">_)</span> <span class="pre">_).</span></code>
and this is a common idiom for applying transitivity on the left hand
side of an equation.</p>
</div>
<div class="section" id="the-abstract-tactic">
<span id="abstract-ssr"></span><h4>The abstract tactic<a class="headerlink" href="#the-abstract-tactic" title="このヘッドラインへのパーマリンク">¶</a></h4>
<dl class="tacn">
<dt id="coq:tacn.abstract-ssreflect">
<code class="descname"><span class="notation"><span>abstract:</span> <span class="repeat-wrapper"><span class="repeat"><span>d</span><span>_</span><span>item</span></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.abstract-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic assigns an abstract constant previously introduced with the <code class="docutils literal notranslate"><span class="pre">[:</span>
<span class="pre">name</span> <span class="pre">]</span></code> intro pattern (see section <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>).</p>
<p>In a goal like the following:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
abs : &lt;hidden&gt;
n : nat
=============
m &lt; 5 + n
</pre></div>
</div>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">abstract:</span> <span class="pre">abs</span> <span class="pre">n</span></code> first generalizes the goal with respect ton
(that is not visible to the abstract constant abs) and then assigns
abs. The resulting goal is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
n : nat
=============
m &lt; 5 + n
</pre></div>
</div>
<p>Once this subgoal is closed, all other goals having abs in their
context see the type assigned to <code class="docutils literal notranslate"><span class="pre">abs</span></code>. In this case:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>m : nat
abs : forall n, m &lt; 5 + n
=============
…
</pre></div>
</div>
<p>For a more detailed example the reader should refer to
section <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a>.</p>
</div>
</div>
<div class="section" id="introduction-in-the-context">
<span id="introduction-ssr"></span><h3>Introduction in the context<a class="headerlink" href="#introduction-in-the-context" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The application of a tactic to a given goal can generate (quantified)
variables, assumptions, or definitions, which the user may want to
<em>introduce</em> as new facts, constants or defined constants,
respectively. If the tactic splits the goal into several subgoals,
each of them may require the introduction of different constants and
facts. Furthermore it is very common to immediately decompose or
rewrite with an assumption instead of adding it to the context, as the
goal can often be simplified and even proved after this.</p>
<p>All these operations are performed by the introduction tactical <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code>,
whose general syntax is</p>
<dl class="tacn">
<dt id="coq:tacn.">
<code class="descname"><span class="notation"><span class="hole">tactic</span> <span>=&gt;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn." title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-i_item">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">i_item</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> <span class="meta">|</span> <span>/</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#grammar-token-i_item" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-s_item">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">s_item</span> <span class="pre">::=</span> </code><span class="notation"><span>/=</span> <span class="meta">|</span> <span>//</span> <span class="meta">|</span> <span>//=</span></span></code><a class="headerlink" href="#grammar-token-s_item" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-i_pattern">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">i_pattern</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="meta">|</span> <span>_</span> <span class="meta">|</span> <span>?</span> <span class="meta">|</span> <span>*</span> <span class="meta">|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span>-&gt;</span> <span class="meta">|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span><span>&lt;-</span> <span class="meta">|</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span><span class="notation-sub">|</span></span> <span>]</span> <span class="meta">|</span> <span>-</span> <span class="meta">|</span> <span>[:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>]</span></span></code><a class="headerlink" href="#grammar-token-i_pattern" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical first executes tactic, then the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> s,
left to right. An <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> specifies a
simplification operation; a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>
h specifies context pruning as in <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>.
The <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> s can be seen as a variant of <em>intro patterns</em>
<a class="reference internal" href="tactics.html#tactics"><span class="std std-ref">Tactics</span></a>: each performs an introduction operation, i.e., pops some
variables or assumptions from the goal.</p>
<p>An <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can simplify the set of subgoals or the subgoals themselves:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">//</span></code> removes all the “trivial” subgoals that can be resolved by the
<span class="smallcaps">SSReflect</span> tactic <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> described in <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>, i.e.,
it executes <code class="docutils literal notranslate"><span class="pre">try</span> <span class="pre">done</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">/=</span></code> simplifies the goal by performing partial evaluation, as per the
tactic <code class="docutils literal notranslate"><span class="pre">simpl</span></code> <a class="footnote-reference" href="#id16" id="id5">[14]</a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">//=</span></code> combines both kinds of simplification; it is equivalent to
<code class="docutils literal notranslate"><span class="pre">/=</span> <span class="pre">//</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">simpl;</span> <span class="pre">try</span> <span class="pre">done</span></code>.</li>
</ul>
<p>When an <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> bears a <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a>, then the
<a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> is executed
<em>after</em> the <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a>, e.g., <code class="docutils literal notranslate"><span class="pre">{IHn}//</span></code> will solve some subgoals,
possibly using the fact <code class="docutils literal notranslate"><span class="pre">IHn</span></code>, and will erase <code class="docutils literal notranslate"><span class="pre">IHn</span></code> from the context
of the remaining subgoals.</p>
<p>The last entry in the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> grammar rule, <code class="docutils literal notranslate"><span class="pre">/</span></code><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>,
represents a view (see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>).
If the next <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> is a view, then the view is
applied to the assumption in top position once all the
previous <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> have been performed.</p>
<p>The view is applied to the top assumption.</p>
<p><span class="smallcaps">SSReflect</span> supports the following <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> s:</p>
<dl class="docutils">
<dt><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a></dt>
<dd>pops the top variable, assumption, or local definition into
a new constant, fact, or defined constant <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>, respectively.
Note that defined constants cannot be introduced when δ-expansion is
required to expose the top variable or assumption.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">?</span></code></dt>
<dd>pops the top variable into an anonymous constant or fact, whose name
is picked by the tactic interpreter. <span class="smallcaps">SSReflect</span> only generates names that cannot
appear later in the user script <a class="footnote-reference" href="#id17" id="id6">[15]</a>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">_</span></code></dt>
<dd>pops the top variable into an anonymous constant that will be deleted
from the proof context of all the subgoals produced by the <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical.
They should thus never be displayed, except in an error message if the
constant is still actually used in the goal or context after the last
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> has been executed (<a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can erase goals or
terms where the constant appears).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">*</span></code></dt>
<dd><p class="first">pops all the remaining apparent variables/assumptions as anonymous
constants/facts. Unlike <code class="docutils literal notranslate"><span class="pre">?</span></code> and <code class="docutils literal notranslate"><span class="pre">move</span></code> the <code class="docutils literal notranslate"><span class="pre">*</span></code>
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> does not
expand definitions in the goal to expose quantifiers, so it may be useful
to repeat a <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> tactic, e.g., on the goal:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>forall a b : bool, a &lt;&gt; b
</pre></div>
</div>
<p class="last">a first <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> adds only <code class="docutils literal notranslate"><span class="pre">_a_</span> <span class="pre">:</span> <span class="pre">bool</span></code> and <code class="docutils literal notranslate"><span class="pre">_b_</span> <span class="pre">:</span> <span class="pre">bool</span></code>
to the context; it takes a second <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">*</span></code> to add <code class="docutils literal notranslate"><span class="pre">_Hyp_</span> <span class="pre">:</span> <span class="pre">_a_</span> <span class="pre">=</span> <span class="pre">_b_</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code></dt>
<dd>(resp. <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> <code class="docutils literal notranslate"><span class="pre">&lt;-</span></code>)
pops the top assumption (which should be a rewritable proposition) into an
anonymous fact, rewrites (resp. rewrites right to left) the goal with this
fact (using the <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic described in section
<a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>, and honoring the optional occurrence selector), and
finally deletes the anonymous fact from the context.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code></dt>
<dd>when it is the
very <em>first</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> after tactic <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> tactical <em>and</em> tactic
is not a move, is a <em>branching</em><a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It executes the sequence
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a><span class="math notranslate">\(_i\)</span> on the i-th   subgoal produced by tactic. The
execution of tactic should thus generate exactly m subgoals, unless the
<code class="docutils literal notranslate"><span class="pre">[…]</span></code> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> comes after an initial <code class="docutils literal notranslate"><span class="pre">//</span></code> or <code class="docutils literal notranslate"><span class="pre">//=</span></code>
<a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> that closes some of the goals produced by <code class="docutils literal notranslate"><span class="pre">tactic</span></code>, in
which case exactly m subgoals should remain after thes- item, or we have
the trivial branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> [], which always does nothing,
regardless of the number of remaining subgoals.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code></dt>
<dd>when it is <em>not</em>
the first <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> or when tactic is a <code class="docutils literal notranslate"><span class="pre">move</span></code>, is a
<em>destructing</em> <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>. It starts by destructing the top
variable, using the <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic described in
<a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a>. It then behaves as the corresponding
branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, executing the
sequence:token:<cite>i_item</cite><span class="math notranslate">\(_i\)</span>  in the i-th subgoal generated by the
case analysis; unless we have the trivial destructing <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>
<code class="docutils literal notranslate"><span class="pre">[]</span></code>, the latter should generate exactly m subgoals, i.e., the top
variable should have an inductive type with exactly m constructors <a class="footnote-reference" href="#id18" id="id7">[16]</a>.
While it is good style to use the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> i * to pop the variables
and assumptions corresponding to each constructor, this is not enforced by
<span class="smallcaps">SSReflect</span>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">-</span></code></dt>
<dd>does nothing, but counts as an intro pattern. It can also be used to
force the interpretation of <code class="docutils literal notranslate"><span class="pre">[</span></code> <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span></code>
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> * <code class="docutils literal notranslate"><span class="pre">]</span></code> as a case analysis like in <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">-[H1</span> <span class="pre">H2]</span></code>. It
can also be used to indicate explicitly the link between a view and a name
like in <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">/eqP-H1</span></code>.  Last, it can serve as a separator between
views.  Section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a> <a class="footnote-reference" href="#id20" id="id8">[18]</a> explains in which
respect the tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">/v1/v2</span></code> differs from the tactic <code class="docutils literal notranslate"><span class="pre">move=&gt;</span>
<span class="pre">/v1-/v2</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">[:</span></code> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> <code class="docutils literal notranslate"><span class="pre">…]</span></code></dt>
<dd>introduces in the context an abstract constant
for each <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>.  Its type has to be fixed later on by using the
<code class="docutils literal notranslate"><span class="pre">abstract</span></code> tactic.  Before then the type displayed is <code class="docutils literal notranslate"><span class="pre">&lt;hidden&gt;</span></code>.</dd>
</dl>
<p>Note that <span class="smallcaps">SSReflect</span> does not support the syntax <code class="docutils literal notranslate"><span class="pre">(ipat,</span> <span class="pre">…,</span> <span class="pre">ipat)</span></code> for
destructing intro-patterns.</p>
<p>Clears are deferred until the end of the intro pattern.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">Nat.leb</span><span> 0 </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">true</span><span> -&gt; (</span><span class="coqdoc-var">Nat.leb</span><span> 0 </span><span class="coqdoc-var">x</span><span>) &amp;&amp; (</span><span class="coqdoc-var">Nat.leb</span><span> </span><span class="coqdoc-var">y</span><span> 2) = </span><span class="coqdoc-var">true</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">leb</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">leb</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">leb</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>=&gt; {</span><span class="coqdoc-var">x</span><span>} -&gt;.</span></dt>
<dd><span class="first">1 subgoal
  
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">leb</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>If the cleared names are reused in the same intro pattern, a renaming
is performed behind the scenes.</p>
<p>Facts mentioned in a clear switch must be valid names in the proof
context (excluding the section context).</p>
<p>The rules for interpreting branching and destructing <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> are
motivated by the fact that it would be pointless to have a branching
pattern if tactic is a <code class="docutils literal notranslate"><span class="pre">move</span></code>, and in most of the remaining cases
tactic is <code class="docutils literal notranslate"><span class="pre">case</span></code> or <code class="docutils literal notranslate"><span class="pre">elim</span></code>, which implies destruction.
The rules above imply that:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">[a</span> <span class="pre">b].</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">[a</span> <span class="pre">b].</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">a</span> <span class="pre">b.</span></code></li>
</ul>
<p>are all equivalent, so which one to use is a matter of style; <code class="docutils literal notranslate"><span class="pre">move</span></code> should
be used for casual decomposition, such as splitting a pair, and <code class="docutils literal notranslate"><span class="pre">case</span></code>
should be used for actual decompositions, in particular for type families
(see <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>) and proof by contradiction.</p>
<p>The trivial branching <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> can be used to force the branching
interpretation, e.g.:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">case=&gt;</span> <span class="pre">[]</span> <span class="pre">[a</span> <span class="pre">b]</span> <span class="pre">c.</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">move=&gt;</span> <span class="pre">[[a</span> <span class="pre">b]</span> <span class="pre">c].</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">case;</span> <span class="pre">case=&gt;</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">c.</span></code></li>
</ul>
<p>are all equivalent.</p>
</div>
<div class="section" id="generation-of-equations">
<span id="generation-of-equations-ssr"></span><h3>Generation of equations<a class="headerlink" href="#generation-of-equations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The generation of named equations option stores the definition of a
new constant as an equation. The tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span> </span><span class="coqdoc-var">En</span><span>: (</span><span class="coqdoc-var">size</span><span> </span><span class="coqdoc-var">l</span><span>) =&gt; </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 10-14:
&gt; move En: (size l) =&gt; n.
&gt;           ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">move</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrmovearg) (ssrclauses)&quot; failed.
       The reference size was not found in the current environment.</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">l</span></code> is a list, replaces <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">l</span></code> by <code class="docutils literal notranslate"><span class="pre">n</span></code> in the goal and
adds the fact <code class="docutils literal notranslate"><span class="pre">En</span> <span class="pre">:</span> <span class="pre">size</span> <span class="pre">l</span> <span class="pre">=</span> <span class="pre">n</span></code> to the context.
This is quite different from:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">pose</span><span> </span><span class="coqdoc-var">n</span><span> := (</span><span class="coqdoc-var">size</span><span> </span><span class="coqdoc-var">l</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 11-15:
&gt; pose n := (size l).
&gt;            ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pose</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrfwdid) (ssrposefwd)&quot; failed.
       The reference size was not found in the current environment.</span></dd>
</dl>
</div>
<p>which generates a definition <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">:=</span> <span class="pre">(size</span> <span class="pre">l)</span></code>. It is not possible to
generalize or rewrite such a definition; on the other hand, it is
automatically expanded during computation, whereas expanding the
equation <code class="docutils literal notranslate"><span class="pre">En</span></code> requires explicit rewriting.</p>
<p>The use of this equation name generation option with a <code class="docutils literal notranslate"><span class="pre">case</span></code> or an
<code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic changes the status of the first <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, in order to
deal with the possible parameters of the constants introduced.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> :</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">a</span><span> &lt;&gt; </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">E</span><span> : </span><span class="coqdoc-var">a</span><span> =&gt; [|</span><span class="coqdoc-var">n</span><span>].</span></dt>
<dd><span class="first">2 subgoals
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  E : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>If the user does not provide a branching <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> as first
<a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a>, or if the <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> does not provide enough names for
the arguments of a constructor, then the constants generated are introduced
under fresh <span class="smallcaps">SSReflect</span> names.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> :</span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">a</span><span> &lt;&gt; </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">E</span><span> : </span><span class="coqdoc-var">a</span><span> =&gt; </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  E : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  H : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Show</span><span> 2.</span></dt>
<dd><span class="first">subgoal 2 is:
  
  a, b, _n_ : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  E : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_n_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_n_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Combining the generation of named equations mechanism with thecase
tactic strengthens the power of a case analysis. On the other hand,
when combined with the elim tactic, this feature is mostly useful for
debug purposes, to trace the values of decomposed parameters and
pinpoint failing branches.</p>
</div>
<div class="section" id="type-families">
<span id="type-families-ssr"></span><h3>Type families<a class="headerlink" href="#type-families" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When the top assumption of a goal has an inductive type, two specific
operations are possible: the case analysis performed by the <code class="docutils literal notranslate"><span class="pre">case</span></code>
tactic, and the application of an induction principle, performed by
the <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic. When this top assumption has an inductive type, which
is moreover an instance of a type family, <span class="smallcaps">Coq</span> may need help from the
user to specify which occurrences of the parameters of the type should
be substituted.</p>
<p>A specific <code class="docutils literal notranslate"><span class="pre">/</span></code> switch indicates the type family parameters of the type
of a <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> immediately following this <code class="docutils literal notranslate"><span class="pre">/</span></code> switch,
using the syntax:</p>
<dl class="tacv">
<dt id="coq:tacv.case-ssreflect">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>case:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacv.case-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>elim:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<p>The <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> on the right side of the <code class="docutils literal notranslate"><span class="pre">/</span></code> switch are discharged as
described in section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>. The case analysis or elimination
will be done on the type of the top assumption after these discharge
operations.</p>
<p>Every <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> preceding the <code class="docutils literal notranslate"><span class="pre">/</span></code> is interpreted as arguments of this
type, which should be an instance of an inductive type family. These terms
are not actually generalized, but rather selected for substitution.
Occurrence switches can be used to restrict the substitution. If a term is
left completely implicit (e.g. writing just <code class="docutils literal notranslate"><span class="pre">_</span></code>), then a pattern is
inferred looking at the type of the top assumption. This allows for the
compact syntax:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">case</span><span>: {2}</span><span class="coqdoc-var">_</span><span> / </span><span class="coqdoc-var">eqP</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 13-16:
&gt; case: {2}_ / eqP.
&gt;              ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">case</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrcasearg) (ssrclauses)&quot; failed.
       The reference eqP was not found in the current environment.</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">_</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">==</span> <span class="pre">_)</span></code> since
<code class="docutils literal notranslate"><span class="pre">eqP</span> <span class="pre">T</span> <span class="pre">a</span> <span class="pre">b</span> <span class="pre">:</span> <span class="pre">reflect</span> <span class="pre">(a</span> <span class="pre">=</span> <span class="pre">b)</span> <span class="pre">(a</span> <span class="pre">==</span> <span class="pre">b)</span></code> and reflect is a type family with
one index.</p>
<p>Moreover if the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> list is too short, it is padded with an
initial sequence of <code class="docutils literal notranslate"><span class="pre">_</span></code> of the right length.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Here is a small example on lists. We define first a function which
adds an element at the end of a given list.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">List</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">LastCases</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span></dt>
<dd><span class="first last">A is declared</span></dd>
<dt><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-keyword">Type</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">with</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">nil</span><span> =&gt; </span><span class="coqdoc-var">a</span><span> :: </span><span class="coqdoc-var">nil</span><span>
&nbsp;&nbsp;| </span><span class="coqdoc-var">hd</span><span> :: </span><span class="coqdoc-var">tl</span><span> =&gt; </span><span class="coqdoc-var">hd</span><span> :: (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">tl</span><span>) </span><span class="coqdoc-keyword">end</span><span>.</span></dt>
<dd><span class="first last">add_last is defined
add_last is recursively defined (decreasing on 2nd argument)</span></dd>
</dl>
</div>
<p>Then we define an inductive predicate for case analysis on lists
according to their last element:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">last_spec</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">LastSeq0</span><span> : </span><span class="coqdoc-var">last_spec</span><span> </span><span class="coqdoc-var">nil</span><span>
| </span><span class="coqdoc-var">LastAdd</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">last_spec</span><span> (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">s</span><span>).</span></dt>
<dd><span class="first last">last_spec is defined
last_spec_rect is defined
last_spec_ind is defined
last_spec_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Theorem</span><span> </span><span class="coqdoc-var">lastP</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>, </span><span class="coqdoc-var">last_spec</span><span> </span><span class="coqdoc-var">l</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">last_spec</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">Admitted</span><span>.</span></dt>
<dd><span class="first last">lastP is declared</span></dd>
</dl>
</div>
<p>We are now ready to use <code class="docutils literal notranslate"><span class="pre">lastP</span></code> in conjunction with <code class="docutils literal notranslate"><span class="pre">case</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">l</span><span> : (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span>) * 2 = </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">l</span><span> ++ </span><span class="coqdoc-var">l</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">case</span><span>: (</span><span class="coqdoc-var">lastP</span><span> </span><span class="coqdoc-var">l</span><span>).</span></dt>
<dd><span class="first">2 subgoals
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (s : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>Applied to the same goal, the command:
<code class="docutils literal notranslate"><span class="pre">case:</span> <span class="pre">l</span> <span class="pre">/</span> <span class="pre">(lastP</span> <span class="pre">l).</span></code>
generates the same subgoals but <code class="docutils literal notranslate"><span class="pre">l</span></code> has been cleared from both contexts.</p>
<p>Again applied to the same goal, the command.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">l</span><span> : (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span>) * 2 = </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">l</span><span> ++ </span><span class="coqdoc-var">l</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">case</span><span>: {1 3}</span><span class="coqdoc-var">l</span><span> / (</span><span class="coqdoc-var">lastP</span><span> </span><span class="coqdoc-var">l</span><span>).</span></dt>
<dd><span class="first">2 subgoals
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (s : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p class="last">Note that selected occurrences on the left of the <code class="docutils literal notranslate"><span class="pre">/</span></code>
switch have been substituted with l instead of being affected by
the case analysis.</p>
</div>
<p>The equation name generation feature combined with a type family /
switch generates an equation for the <em>first</em> dependent <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
specified by the user. Again starting with the above goal, the
command:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">l</span><span> : (</span><span class="coqdoc-var">length</span><span> </span><span class="coqdoc-var">l</span><span>) * 2 = </span><span class="coqdoc-var">length</span><span> (</span><span class="coqdoc-var">l</span><span> ++ </span><span class="coqdoc-var">l</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">E</span><span>: {1 3}</span><span class="coqdoc-var">l</span><span> / (</span><span class="coqdoc-var">lastP</span><span> </span><span class="coqdoc-var">l</span><span>) =&gt; [|</span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">x</span><span>].</span></dt>
<dd><span class="first">2 subgoals
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  E : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-keyword">Show</span><span> 2.</span></dt>
<dd><span class="first">subgoal 2 is:
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l, s : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  E : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">length</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ++</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">s</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
</div>
<p>There must be at least one <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> to the left of the / switch; this
prevents any confusion with the view feature. However, the <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
to the right of the <code class="docutils literal notranslate"><span class="pre">/</span></code> are optional, and if they are omitted the first
assumption provides the instance of the type family.</p>
<p>The equation always refers to the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a> in the actual tactic
call, before any padding with initial <code class="docutils literal notranslate"><span class="pre">_</span></code>. Thus, if an inductive type
has two family parameters, it is possible to have|SSR| generate an
equation for the second one by omitting the pattern for the first;
note however that this will fail if the type of the second parameter
depends on the value of the first parameter.</p>
</div>
</div>
<div class="section" id="control-flow">
<h2>Control flow<a class="headerlink" href="#control-flow" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="indentation-and-bullets">
<span id="indentation-ssr"></span><h3>Indentation and bullets<a class="headerlink" href="#indentation-and-bullets" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>A linear development of <span class="smallcaps">Coq</span> scripts gives little information on the
structure of the proof. In addition, replaying a proof after some
changes in the statement to be proved will usually not display
information to distinguish between the various branches of case
analysis for instance.</p>
<p>To help the user in this organization of the proof script at development
time, <span class="smallcaps">SSReflect</span> provides some bullets to highlight the structure of branching
proofs. The available bullets are <code class="docutils literal notranslate"><span class="pre">-</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code>.  Combined with
tabulation, this lets us highlight four nested levels of branching; the most
we have ever needed is three. Indeed, the use of “simpl and closing”
switches, of terminators (see above section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>) and
selectors (see section <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>) is powerful enough to avoid most
of the time more than two levels of indentation.</p>
<p>Here is a fragment of such a structured script:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>case E1: (abezoutn _ _) =&gt; [[| k1] [| k2]].
- rewrite !muln0 !gexpn0 mulg1 =&gt; H1.
  move/eqP: (sym_equal F0); rewrite -H1 orderg1 eqn_mul1.
  by case/andP; move/eqP.
- rewrite muln0 gexpn0 mulg1 =&gt; H1.
  have F1: t %| t * S k2.+1 - 1.
    apply: (@dvdn_trans (orderg x)); first by rewrite F0; exact: dvdn_mull.
    rewrite orderg_dvd; apply/eqP; apply: (mulgI x).
    rewrite -{1}(gexpn1 x) mulg1 gexpn_add leq_add_sub //.
    by move: P1; case t.
  rewrite dvdn_subr in F1; last by exact: dvdn_mulr.
  + rewrite H1 F0 -{2}(muln1 (p ^ l)); congr (_ * _).
    by apply/eqP; rewrite -dvdn1.
  + by move: P1; case: (t) =&gt; [| [| s1]].
- rewrite muln0 gexpn0 mul1g =&gt; H1.
...
</pre></div>
</div>
</div>
<div class="section" id="terminators">
<span id="terminators-ssr"></span><h3>Terminators<a class="headerlink" href="#terminators" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>To further structure scripts, <span class="smallcaps">SSReflect</span> supplies <em>terminating</em>
tacticals to explicitly close off tactics. When replaying scripts, we
then have the nice property that an error immediately occurs when a
closed tactic fails to prove its subgoal.</p>
<p>It is hence recommended practice that the proof of any subgoal should
end with a tactic which <em>fails if it does not solve the current goal</em>,
like discriminate, contradiction or assumption.</p>
<p>In fact, <span class="smallcaps">SSReflect</span> provides a generic tactical which turns any tactic
into a closing one (similar to now). Its general syntax is:</p>
<dl class="tacn">
<dt id="coq:tacn.by">
<code class="descname"><span class="notation"><span>by</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacn.by" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The Ltac expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">by</span></span> <span><span class="pre">[</span></span><span class="hole"><span class="pre">tactic</span></span> <span><span class="pre">|</span></span> <span><span class="pre">[</span></span><span class="hole"><span class="pre">tactic</span></span> <span><span class="pre">|</span></span> <span><span class="pre">…]</span></span></span></code> is equivalent to
<code class="docutils literal notranslate"><span class="notation"><span><span class="pre">[by</span></span> <span class="hole"><span class="pre">tactic</span></span> <span><span class="pre">|</span></span> <span><span class="pre">by</span></span> <span class="hole"><span class="pre">tactic</span></span> <span><span class="pre">|</span></span> <span><span class="pre">...]</span></span></span></code> and this form should be preferred
to the former.</p>
<p>In the script provided as example in section <a class="reference internal" href="#indentation-ssr"><span class="std std-ref">Indentation and bullets</span></a>, the
paragraph corresponding to each sub-case ends with a tactic line prefixed
with a <code class="docutils literal notranslate"><span class="pre">by</span></code>, like in:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">eqP</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> -</span><span class="coqdoc-var">dvdn1</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 9-12:
&gt; by apply/eqP; rewrite -dvdn1.
&gt;          ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">by</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrhintarg)&quot; failed.
       The reference eqP was not found in the current environment.</span></dd>
</dl>
</div>
<dl class="tacn">
<dt id="coq:tacn.done">
<code class="descname"><span class="notation"><span>done</span></span></code><a class="headerlink" href="#coq:tacn.done" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The <a class="reference internal" href="#coq:tacn.by" title="by"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">by</span></code></a> tactical is implemented using the user-defined, and extensible
<a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> tactic. This <a class="reference internal" href="#coq:tacn.done" title="done"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">done</span></code></a> tactic tries to solve the current goal by some
trivial means and fails if it doesn’t succeed. Indeed, the tactic
expression <code class="docutils literal notranslate"><span class="notation"><span><span class="pre">by</span></span> <span class="hole"><span class="pre">tactic</span></span></span></code> is equivalent to <code class="docutils literal notranslate"><span class="notation"><span class="hole"><span class="pre">tactic</span></span><span><span class="pre">;</span></span> <span><span class="pre">done</span></span></span></code>.</p>
<p>Conversely, the tactic</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">by</span><span> [ ].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-6:
&gt; by [ ].
&gt; ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">by</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrhintarg)&quot; failed.
       No applicable tactic.</span></dd>
</dl>
</div>
<p>is equivalent to:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">done</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-4:
&gt; done.
&gt; ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">done</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">&quot; failed.
       No applicable tactic.</span></dd>
</dl>
</div>
<p>The default implementation of the done tactic, in the <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>
file, is:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">done</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-tactic">trivial</span><span>; </span><span class="coqdoc-tactic">hnf</span><span>; </span><span class="coqdoc-tactic">intros</span><span>; </span><span class="coqdoc-tactic">solve</span><span>
&nbsp;&nbsp;&nbsp;[ </span><span class="coqdoc-tactic">do</span><span> ![</span><span class="coqdoc-tactic">solve</span><span> [</span><span class="coqdoc-tactic">trivial</span><span> | </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">sym_equal</span><span>; </span><span class="coqdoc-tactic">trivial</span><span>]</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-tactic">discriminate</span><span> | </span><span class="coqdoc-var">contradiction</span><span> | </span><span class="coqdoc-tactic">split</span><span>]</span><span>
&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">not_locked_false_eq_true</span><span>; </span><span class="coqdoc-tactic">assumption</span><span>
&nbsp;&nbsp;&nbsp;| </span><span class="coqdoc-keyword">match</span><span> </span><span class="coqdoc-keyword">goal</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">H</span><span> : ~ </span><span class="coqdoc-var">_</span><span> |- </span><span class="coqdoc-var">_</span><span> =&gt; </span><span class="coqdoc-tactic">solve</span><span> [</span><span class="coqdoc-tactic">case</span><span> </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-tactic">trivial</span><span>] </span><span class="coqdoc-keyword">end</span><span> ].</span></dt>
<dd class="coqtop-hidden"><span class="first last">done is defined</span></dd>
</dl>
</div>
<p>The lemma <code class="docutils literal notranslate"><span class="pre">not_locked_false_eq_true</span></code> is needed to discriminate
<em>locked</em> boolean predicates (see section <a class="reference internal" href="#locking-ssr"><span class="std std-ref">Locking, unlocking</span></a>). The iterator
tactical do is presented in section <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>. This tactic can be
customized by the user, for instance to include an <code class="docutils literal notranslate"><span class="pre">auto</span></code> tactic.</p>
<p>A natural and common way of closing a goal is to apply a lemma which
is the exact one needed for the goal to be solved. The defective form
of the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">exact</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-5:
&gt; exact.
&gt; ^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exact</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">&quot; failed.
       No product even after head-reduction.</span></dd>
</dl>
</div>
<p>is equivalent to:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">do</span><span> [</span><span class="coqdoc-var">done</span><span> | </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">top</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">top</span><span>].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-36:
&gt; do [done | by move=&gt; top; apply top].
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No applicable tactic.</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">top</span></code> is a fresh name assigned to the top assumption of the goal.
This applied form is supported by the : discharge tactical, and the
tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">exact</span><span>: </span><span class="coqdoc-var">MyLemma</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 7-14:
&gt; exact: MyLemma.
&gt;        ^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exact</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrexactarg)&quot; failed.
       The reference MyLemma was not found in the current environment.</span></dd>
</dl>
</div>
<p>is equivalent to:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">MyLemma</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 10-17:
&gt; by apply: MyLemma.
&gt;           ^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">by</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrhintarg)&quot; failed.
       The reference MyLemma was not found in the current environment.</span></dd>
</dl>
</div>
<p>(see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a> for the documentation of the apply: combination).</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>The list of tactics (possibly chained by semicolons) that
follows the <code class="docutils literal notranslate"><span class="pre">by</span></code> keyword is considered to be a parenthesized block applied to
the current goal. Hence for example if the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">my_lemma1</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 11-20:
&gt; by rewrite my_lemma1.
&gt;            ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">by</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrhintarg)&quot; failed.
       The reference my_lemma1 was not found in the current environment.</span></dd>
</dl>
</div>
<p>succeeds, then the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">my_lemma1</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">my_lemma2</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 11-20:
&gt; by rewrite my_lemma1; apply my_lemma2.
&gt;            ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">by</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrhintarg)&quot; failed.
       The reference my_lemma1 was not found in the current environment.</span></dd>
</dl>
</div>
<p>usually fails since it is equivalent to:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">by</span><span> (</span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">my_lemma1</span><span>; </span><span class="coqdoc-tactic">apply</span><span> </span><span class="coqdoc-var">my_lemma2</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 12-21:
&gt; by (rewrite my_lemma1; apply my_lemma2).
&gt;             ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">by</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrhintarg)&quot; failed.
       The reference my_lemma1 was not found in the current environment.</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="selectors">
<span id="selectors-ssr"></span><h3>Selectors<a class="headerlink" href="#selectors" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>When composing tactics, the two tacticals <code class="docutils literal notranslate"><span class="pre">first</span></code> and <code class="docutils literal notranslate"><span class="pre">last</span></code> let the user
restrict the application of a tactic to only one of the subgoals
generated by the previous tactic. This covers the frequent cases where
a tactic generates two subgoals one of which can be easily disposed
of.</p>
<p>This is another powerful way of linearization of scripts, since it
happens very often that a trivial subgoal can be solved in a less than
one line tactic. For instance, the tactic:</p>
<dl class="tacn">
<dt id="coq:tacn.last">
<code class="descname"><span class="notation"><span class="hole">tactic</span> <span>;</span> <span>last</span> <span>by</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacn.last" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>tries to solve the last subgoal generated by the first
tactic using the given second tactic, and fails if it does not succeed.
Its analogue</p>
<dl class="tacn">
<dt id="coq:tacn.first-ssreflect">
<code class="descname"><span class="notation"><span class="hole">tactic</span> <span>;</span> <span>first</span> <span>by</span> <span class="hole">tactic</span></span></code><a class="headerlink" href="#coq:tacn.first-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>tries to solve the first subgoal generated by the first tactic using the
second given tactic, and fails if it does not succeed.</p>
<p><span class="smallcaps">SSReflect</span> also offers an extension of this facility, by supplying
tactics to <em>permute</em> the subgoals generated by a tactic. The tactic:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="hole">tactic</span><span>;</span> <span>last</span> <span>first</span></span></code></dt>
<dd></dd></dl>

<p>inverts the order of the subgoals generated by tactic. It is
equivalent to:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="hole">tactic</span><span>;</span> <span>first</span> <span>last</span></span></code></dt>
<dd></dd></dl>

<p>More generally, the tactic:</p>
<dl class="tacn">
<dt id="coq:tacn.last-first">
<code class="descname"><span class="notation"><span class="hole">tactic</span><span>;</span> <span>last</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>first</span></span></code><a class="headerlink" href="#coq:tacn.last-first" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> is a <span class="smallcaps">Coq</span> numeral, or an Ltac variable
denoting a <span class="smallcaps">Coq</span>
numeral, having the value k. It rotates the n subgoals G1 , …, Gn
generated by tactic. The first subgoal becomes Gn + 1 − k and the
circular order of subgoals remains unchanged.</p>
<p>Conversely, the tactic:</p>
<dl class="tacn">
<dt id="coq:tacn.first-last">
<code class="descname"><span class="notation"><span class="hole">tactic</span><span>;</span> <span>first</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>last</span></span></code><a class="headerlink" href="#coq:tacn.first-last" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>rotates the n subgoals G1 , …, Gn generated by tactic in order that
the first subgoal becomes Gk .</p>
<p>Finally, the tactics <code class="docutils literal notranslate"><span class="pre">last</span></code> and <code class="docutils literal notranslate"><span class="pre">first</span></code> combine with the branching syntax
of Ltac: if the tactic generates n subgoals on a given goal,
then the tactic</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">tactic</span><span> ; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-var">k</span><span> [ </span><span class="coqdoc-var">tactic1</span><span> |…| </span><span class="coqdoc-var">tacticm</span><span> ] || </span><span class="coqdoc-var">tacticn</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 27-30:
&gt; tactic ; last k [ tactic1 |…| tacticm ] || tacticn.
&gt;                            ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax Error: Lexer: Undefined token</span></dd>
</dl>
</div>
<p>where natural denotes the integer k as above, applies tactic1 to the n
−k + 1-th goal, … tacticm to the n −k + 2 − m-th goal and tactic n
to the others.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Here is a small example on lists. We define first a function which
adds an element at the end of a given list.</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-6:
&gt; Abort.
&gt; ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No focused proof (No proof-editing in progress).</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span> :=</span><span>
| </span><span class="coqdoc-var">C1</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 1 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">C2</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 2 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">C3</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 3 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>
| </span><span class="coqdoc-var">C4</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">n</span><span> = 4 : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first last">test is defined
test_ind is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">example</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">t</span><span> : </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">test</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">case</span><span>: </span><span class="coqdoc-var">t</span><span>; </span><span class="coqdoc-var">last</span><span> 2 [</span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">k</span><span>| </span><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">l</span><span>]; </span><span class="coqdoc-tactic">idtac</span><span>.</span></dt>
<dd><span class="first">4 subgoals
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
subgoal 3 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
subgoal 4 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="iteration">
<span id="iteration-ssr"></span><h3>Iteration<a class="headerlink" href="#iteration" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><span class="smallcaps">SSReflect</span> offers an accurate control on the repetition of tactics,
thanks to the do tactical, whose general syntax is:</p>
<dl class="tacn">
<dt id="coq:tacn.do-ssreflect">
<code class="descname"><span class="notation"><span>do</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span>(</span> <span class="hole">tactic</span> <span>|</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>]</span> <span>)</span></span></code><a class="headerlink" href="#coq:tacn.do-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where <a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> is a <em>multiplier</em>.</p>
<p>Brackets can only be omitted if a single tactic is given <em>and</em> a
multiplier is present.</p>
<p>A tactic of the form:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">do</span><span> [ </span><span class="coqdoc-var">tactic</span><span> 1 | … | </span><span class="coqdoc-var">tactic</span><span> </span><span class="coqdoc-var">n</span><span> ].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 16-19:
&gt; do [ tactic 1 | … | tactic n ].
&gt;                 ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax Error: Lexer: Undefined token</span></dd>
</dl>
</div>
<p>is equivalent to the standard Ltac expression:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">first</span><span> [ </span><span class="coqdoc-var">tactic</span><span> 1 | … | </span><span class="coqdoc-var">tactic</span><span> </span><span class="coqdoc-var">n</span><span> ].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 19-22:
&gt; first [ tactic 1 | … | tactic n ].
&gt;                    ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax Error: Lexer: Undefined token</span></dd>
</dl>
</div>
<p>The optional multiplier <a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> specifies how many times the action of
tactic should be repeated on the current subgoal.</p>
<p>There are four kinds of multipliers:</p>
<dl class="prodn">
<dt id="grammar-token-mult">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">mult</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>!</span> <span class="meta">|</span> <span>!</span> <span class="meta">|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span>?</span> <span class="meta">|</span> <span>?</span></span></code><a class="headerlink" href="#grammar-token-mult" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>Their meaning is:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">n!</span></code> the step tactic is repeated exactly n times (where n is a
positive integer argument).</li>
<li><code class="docutils literal notranslate"><span class="pre">!</span></code> the step tactic is repeated as many times as possible, and done
at least once.</li>
<li><code class="docutils literal notranslate"><span class="pre">?</span></code> the step tactic is repeated as many times as possible,
optionally.</li>
<li><code class="docutils literal notranslate"><span class="pre">n?</span></code> the step tactic is repeated up to n times, optionally.</li>
</ul>
<p>For instance, the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">tactic</span><span>; </span><span class="coqdoc-tactic">do</span><span> 1? </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">mult_comm</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-6:
&gt; tactic; do 1? rewrite mult_comm.
&gt; ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference tactic was not found in the current environment.</span></dd>
</dl>
</div>
<p>rewrites at most one time the lemma <code class="docutils literal notranslate"><span class="pre">mult_comm</span></code> in all the subgoals
generated by tactic , whereas the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">tactic</span><span>; </span><span class="coqdoc-tactic">do</span><span> 2! </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">mult_comm</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-6:
&gt; tactic; do 2! rewrite mult_comm.
&gt; ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference tactic was not found in the current environment.</span></dd>
</dl>
</div>
<p>rewrites exactly two times the lemma <code class="docutils literal notranslate"><span class="pre">mult_comm</span></code> in all the subgoals
generated by tactic, and fails if this rewrite is not possible in some
subgoal.</p>
<p>Note that the combination of multipliers and rewrite is so often used
that multipliers are in fact integrated to the syntax of the
<span class="smallcaps">SSReflect</span> rewrite tactic, see section <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a>.</p>
</div>
<div class="section" id="localization">
<span id="localization-ssr"></span><h3>Localization<a class="headerlink" href="#localization" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In sections <a class="reference internal" href="#basic-localization-ssr"><span class="std std-ref">Basic localization</span></a> and <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a>, we have
already presented the <em>localization</em> tactical in, whose general syntax is:</p>
<dl class="tacn">
<dt id="coq:tacn.in">
<code class="descname"><span class="notation"><span class="hole">tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span>*</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.in" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a name in the
context. On the left side of <code class="docutils literal notranslate"><span class="pre">in</span></code>,
<code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code> can be <code class="docutils literal notranslate"><span class="pre">move</span></code>, <code class="docutils literal notranslate"><span class="pre">case</span></code>, <code class="docutils literal notranslate"><span class="pre">elim</span></code>, <code class="docutils literal notranslate"><span class="pre">rewrite</span></code>, <code class="docutils literal notranslate"><span class="pre">set</span></code>,
or any tactic formed with the general iteration tactical <code class="docutils literal notranslate"><span class="pre">do</span></code> (see section
<a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>).</p>
<p>The operation described by tactic is performed in the facts listed after
<code class="docutils literal notranslate"><span class="pre">in</span></code> and in the goal if a <code class="docutils literal notranslate"><span class="pre">*</span></code> ends the list of names.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical successively:</p>
<ul class="simple">
<li>generalizes the selected hypotheses, possibly “protecting” the goal
if <code class="docutils literal notranslate"><span class="pre">*</span></code> is not present,</li>
<li>performs <code class="xref std std-token docutils literal notranslate"><span class="pre">tactic</span></code>, on the obtained goal,</li>
<li>reintroduces the generalized facts, under the same names.</li>
</ul>
<p>This defective form of the <code class="docutils literal notranslate"><span class="pre">do</span></code> tactical is useful to avoid clashes
between standard Ltac in and the <span class="smallcaps">SSReflect</span> tactical in.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Ltac</span><span> </span><span class="coqdoc-var">mytac</span><span> </span><span class="coqdoc-var">H</span><span> := </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first last">mytac is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> (</span><span class="coqdoc-var">H1</span><span> : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>) (</span><span class="coqdoc-var">H2</span><span> : </span><span class="coqdoc-var">y</span><span> = 3) : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = 6.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H2 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
<dt><span class="coqdoc-tactic">do</span><span> [</span><span class="coqdoc-var">mytac</span><span> </span><span class="coqdoc-var">H2</span><span>] </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">H1</span><span> *.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H2 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
  H1 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
</dl>
</div>
<p class="last">the last tactic rewrites the hypothesis <code class="docutils literal notranslate"><span class="pre">H2</span> <span class="pre">:</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">3</span></code> both in
<code class="docutils literal notranslate"><span class="pre">H1</span> <span class="pre">:</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></code> and in the goal <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">6</span></code>.</p>
</div>
<p>By default <code class="docutils literal notranslate"><span class="pre">in</span></code> keeps the body of local definitions. To erase the body
of a local definition during the generalization phase, the name of the
local definition must be written between parentheses, like in
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">H</span> <span class="pre">in</span> <span class="pre">H1</span> <span class="pre">(def_n)</span> <span class="pre">H2.</span></code></p>
<p>From <span class="smallcaps">SSReflect</span> 1.5 the grammar for the in tactical has been extended
to the following one:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span class="hole">tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> <span>|</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>|</span> <span>(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>)</span> <span>|</span> <span>(</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span>)</span></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span>*</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>In its simplest form the last option lets one rename hypotheses that
can’t be cleared (like section variables). For example, <code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">:=</span> <span class="pre">x)</span></code>
generalizes over <code class="docutils literal notranslate"><span class="pre">x</span></code> and reintroduces the generalized variable under the
name <code class="docutils literal notranslate"><span class="pre">y</span></code> (and does not clear <code class="docutils literal notranslate"><span class="pre">x</span></code>).
For a more precise description of this form of localization refer
to <a class="reference internal" href="#advanced-generalization-ssr"><span class="std std-ref">Advanced generalization</span></a>.</p>
</div>
<div class="section" id="structure">
<span id="structure-ssr"></span><h3>Structure<a class="headerlink" href="#structure" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Forward reasoning structures the script by explicitly specifying some
assumptions to be added to the proof context. It is closely associated
with the declarative style of proof, since an extensive use of these
highlighted statements make the script closer to a (very detailed)
textbook proof.</p>
<p>Forward chaining tactics allow to state an intermediate lemma and start a
piece of script dedicated to the proof of this statement. The use of closing
tactics (see section <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a>) and of indentation makes
syntactically explicit the portion of the script building the proof of the
intermediate statement.</p>
<div class="section" id="the-have-tactic">
<h4>The have tactic.<a class="headerlink" href="#the-have-tactic" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The main <span class="smallcaps">SSReflect</span> forward reasoning tactic is the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic. It can
be use in two modes: one starts a new (sub)proof for an intermediate
result in the main proof, and the other provides explicitly a proof
term for this intermediate step.</p>
<p>In the first mode, the syntax of have in its defective form is:</p>
<dl class="tacn">
<dt id="coq:tacn.have">
<code class="descname"><span class="notation"><span>have</span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.have" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic supports open syntax for <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. Applied to a goal <code class="docutils literal notranslate"><span class="pre">G</span></code>, it
generates a first subgoal requiring a proof of <code class="docutils literal notranslate"><span class="pre">term</span></code> in the context of
<code class="docutils literal notranslate"><span class="pre">G</span></code>. The second generated subgoal is of the form <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>, where term
becomes the new top assumption, instead of being introduced with a
fresh name. At the proof-term level, the have tactic creates a β
redex, and introduces the lemma under a fresh name, automatically
chosen.</p>
<p>Like in the case of the <code class="docutils literal notranslate"><span class="pre">pose</span></code> tactic (see section <a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a>), the types of
the holes are abstracted in term.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-var">_</span><span> * 0 = 0.</span></dt>
<dd><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>The invokation of <code class="docutils literal notranslate"><span class="pre">have</span></code> is equivalent to:</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">n</span><span> * 0 = 0.</span></dt>
<dd><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>The have tactic also enjoys the same abstraction mechanism as the <code class="docutils literal notranslate"><span class="pre">pose</span></code>
tactic for the non-inferred implicit arguments. For instance, the
tactic:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span>) = (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">y</span><span> + 0).</span></dt>
<dd><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (T : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (T : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">opens a new subgoal where the type of <code class="docutils literal notranslate"><span class="pre">x</span></code> is quantified.</p>
</div>
<p>The behavior of the defective have tactic makes it possible to
generalize it in the following general construction:</p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a> <span>|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>|</span> <span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>Open syntax is supported for both <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>. For the description
of <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> and <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> see section
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>. The first mode of the
have tactic, which opens a sub-proof for an intermediate result, uses
tactics of the form:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>have</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> <a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>by</span> <span class="hole">tactic</span></span></code></dt>
<dd></dd></dl>

<p>which behave like:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span>: </span><span class="coqdoc-var">term</span><span> ; </span><span class="coqdoc-tactic">first</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-var">tactic</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 22-28:
&gt; have: term ; first by tactic.
&gt;                       ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference tactic was not found in the current environment.</span></dd>
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">clear_switch</span><span> </span><span class="coqdoc-var">i_item</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">2 subgoals
  
  clear_switch : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  i_item : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">clear_switch</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">i_item</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">i_item</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (T : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">T</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Note that the <a class="reference internal" href="#grammar-token-clear_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">clear_switch</span></code></a> <em>precedes</em> the:token:<cite>i_item</cite>, which
allows to reuse
a name of the context, possibly used by the proof of the assumption,
to introduce the new assumption itself.</p>
<p>The``by`` feature is especially convenient when the proof script of the
statement is very short, basically when it fits in one line like in:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H23</span><span> : 3 + 2 = 2 + 3 </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">addnC</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 36-41:
&gt; have H23 : 3 + 2 = 2 + 3 by rewrite addnC.
&gt;                                     ^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">have</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrhavefwdwbinders)&quot; failed.
       The reference addnC was not found in the current environment.</span></dd>
</dl>
</div>
<p>The possibility of using <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> supplies a very concise syntax for
the further use of the intermediate step. For instance,</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : 3 * </span><span class="coqdoc-var">a</span><span> - 1 = </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> -&gt; : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> * </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">Note how the second goal was rewritten using the stated equality.
Also note that in this last subgoal, the intermediate result does not
appear in the context.</p>
</div>
<p>Thanks to the deferred execution of clears, the following idiom is
also supported (assuming x occurs in the goal only):</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span> {</span><span class="coqdoc-var">x</span><span>} -&gt; : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 6-7:
&gt; have {x} -&gt; : x = y.
&gt;       ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No such hypothesis: x</span></dd>
</dl>
</div>
<p>Another frequent use of the intro patterns combined with <code class="docutils literal notranslate"><span class="pre">have</span></code> is the
destruction of existential assumptions like in the tactic:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> [</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>]: </span><span class="coqdoc-tactic">exists</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> &gt; 0.</span></dt>
<dd><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">exists</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">Focus</span><span> 2.</span></dt>
<dd><span class="first">Toplevel input, characters 0-7:
&gt; Focus 2
&gt; ^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> The Focus command is deprecated; use '2: {' instead
[deprecated-focus,deprecated]
1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Px : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>An alternative use of the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic is to provide the explicit proof
term for the intermediate lemma, using tactics of the form:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span>term</span></span></code></dt>
<dd></dd></dl>

<p>This tactic creates a new assumption of type the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.
If the
optional <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is present, this assumption is introduced under the
name <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a>. Note that the body of the constant is lost for the user.</p>
<p>Again, non inferred implicit arguments and explicit holes are
abstracted.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H</span><span> := </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span>) = (</span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  H : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">adds to the context <code class="docutils literal notranslate"><span class="pre">H</span> <span class="pre">:</span> <span class="pre">Type</span> <span class="pre">-&gt;</span> <span class="pre">Prop.</span></code> This is a schematic example but
the feature is specially useful when the proof term to give involves
for instance a lemma with some hidden implicit arguments.</p>
</div>
<p>After the <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, a list of binders is allowed.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Omega</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">[Loading ML file z_syntax_plugin.cmxs ... done]
[Loading ML file quote_plugin.cmxs ... done]
[Loading ML file newring_plugin.cmxs ... done]
[Loading ML file omega_plugin.cmxs ... done]</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">nat</span><span>) : 2 * </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">omega</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>A proof term provided after <code class="docutils literal notranslate"><span class="pre">:=</span></code> can mention these bound variables
(that are automatically introduced with the given names).
Since the <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a> can be omitted, to avoid ambiguity,
bound variables can be surrounded
with parentheses even if no type is specified:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span> (</span><span class="coqdoc-var">x</span><span>) : 2 * </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">omega</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>The <a class="reference internal" href="#grammar-token-i_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_item</span></code></a> and <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> can be used to interpret the asserted
hypothesis with views (see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) or simplify the resulting
goals.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic also supports a <code class="docutils literal notranslate"><span class="pre">suff</span></code> modifier which allows for
asserting that a given statement implies the current goal without
copying the goal itself.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">suff</span><span> </span><span class="coqdoc-var">H</span><span> : 2 + 2 = 3.</span></dt>
<dd><span class="first">2 subgoals
  
  ============================
  2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">Focus</span><span> 2.</span></dt>
<dd><span class="first">Toplevel input, characters 0-7:
&gt; Focus 2
&gt; ^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> The Focus command is deprecated; use '2: {' instead
[deprecated-focus,deprecated]
1 subgoal
  
  H : 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">Note that H is introduced in the second goal.</p>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">suff</span></code> modifier is not
compatible with the presence of a list of binders.</p>
</div>
<div class="section" id="generating-let-in-context-entries-with-have">
<span id="generating-let-ssr"></span><h4>Generating let in context entries with have<a class="headerlink" href="#generating-let-in-context-entries-with-have" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Since <span class="smallcaps">SSReflect</span> 1.5 the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic supports a “transparent” modifier
to generate let in context entries: the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> symbol in front of the
context entry name.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-var">Depth</span><span> 15.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first last">Ord is defined
Ord_rect is defined
Ord_ind is defined
Ord_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;'I_ n&quot; := (</span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 8, </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 2, </span><span class="coqdoc-var">format</span><span> &quot;''I_' n&quot;).</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">Sub</span><span> {</span><span class="coqdoc-var">_</span><span>} </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> &#64;</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span>); </span><span class="coqdoc-tactic">omega</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  i := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Sub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
         (</span><span class="ansi-fg-light-magenta ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Decidable</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">dec_not_not</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">dec_lt</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> ... =&gt; ... ...))
   : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Note that the sub-term produced by <code class="docutils literal notranslate"><span class="pre">omega</span></code> is in general huge and
uninteresting, and hence one may want to hide it.
For this purpose the <code class="docutils literal notranslate"><span class="pre">[:</span> <span class="pre">name</span> <span class="pre">]</span></code> intro pattern and the tactic
<code class="docutils literal notranslate"><span class="pre">abstract</span></code> (see <a class="reference internal" href="#abstract-ssr"><span class="std std-ref">The abstract tactic</span></a>) are provided.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> [:</span><span class="coqdoc-var">pm</span><span>] &#64;</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span> </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span>); </span><span class="coqdoc-tactic">abstract</span><span>: </span><span class="coqdoc-var">pm</span><span>; </span><span class="coqdoc-tactic">omega</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  pm : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(*</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">*)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  i := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Sub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pm</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">The type of <code class="docutils literal notranslate"><span class="pre">pm</span></code> can be cleaned up by its annotation <code class="docutils literal notranslate"><span class="pre">(*1*)</span></code> by just
simplifying it. The annotations are there for technical reasons only.</p>
</div>
<p>When intro patterns for abstract constants are used in conjunction
with have and an explicit term, they must be used as follows:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> [:</span><span class="coqdoc-var">pm</span><span>] &#64;</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span> := </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">pm</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">omega</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  pm : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(*</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">*)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  i := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Sub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pm</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>In this case the abstract constant <code class="docutils literal notranslate"><span class="pre">pm</span></code> is assigned by using it in
the term that follows <code class="docutils literal notranslate"><span class="pre">:=</span></code> and its corresponding goal is left to be
solved. Goals corresponding to intro patterns for abstract constants
are opened in the order in which the abstract constants are declared
(not in the “order” in which they are used in the term).</p>
<p>Note that abstract constants do respect scopes. Hence, if a variable
is declared after their introduction, it has to be properly
generalized (i.e. explicitly passed to the abstract constant when one
makes use of it).</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">m</span><span> + 1 &lt; </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> [:</span><span class="coqdoc-var">pm</span><span>] &#64;</span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-var">k</span><span> : '</span><span class="coqdoc-var">I_</span><span>(</span><span class="coqdoc-var">n</span><span>+</span><span class="coqdoc-var">k</span><span>) </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">apply</span><span>: (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">m</span><span>); </span><span class="coqdoc-tactic">abstract</span><span>: </span><span class="coqdoc-var">pm</span><span> </span><span class="coqdoc-var">k</span><span>; </span><span class="coqdoc-tactic">omega</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  pm : (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> k : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(*</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">*)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  i := </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">fun</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> k : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Sub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pm</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> k : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">k</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Last, notice that the use of intro patterns for abstract constants is
orthogonal to the transparent flag <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> for have.</p>
</div>
<div class="section" id="the-have-tactic-and-typeclass-resolution">
<h4>The have tactic and typeclass resolution<a class="headerlink" href="#the-have-tactic-and-typeclass-resolution" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Since <span class="smallcaps">SSReflect</span> 1.5 the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic behaves as follows with respect to
typeclass inference.</p>
<blockquote>
<div><div class="coqtop literal-block coqtop-hidden docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">ty</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">ty is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">t</span><span> : </span><span class="coqdoc-var">ty</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">t is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Goal</span><span> </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div></blockquote>
<ul>
<li><div class="coqtop literal-block first docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> : </span><span class="coqdoc-var">ty</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">2 subgoals
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ty</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Full inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code>. The first subgoal demands a
proof of such instantiated statement.</p>
</li>
<li><div class="coqdoc literal-block first docutils container">
<span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> : </span><span class="coqdoc-var">ty</span><span> := .</span></span></div>
<p>No inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code>. Unresolved instances are
quantified in <code class="docutils literal notranslate"><span class="pre">ty</span></code>. The first subgoal demands a proof of such quantified
statement. Note that no proof term follows <code class="docutils literal notranslate"><span class="pre">:=</span></code>, hence two subgoals are
generated.</p>
</li>
<li><div class="coqtop literal-block first docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> : </span><span class="coqdoc-var">ty</span><span> := </span><span class="coqdoc-var">t</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  foo : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ty</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>No inference for <code class="docutils literal notranslate"><span class="pre">ty</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</li>
<li><div class="coqtop literal-block first docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">foo</span><span> := </span><span class="coqdoc-var">t</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  foo : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ty</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>No inference for <code class="docutils literal notranslate"><span class="pre">t</span></code>. Unresolved instances are
quantified in the (inferred) type of <code class="docutils literal notranslate"><span class="pre">t</span></code> and abstracted in <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
</li>
</ul>
<dl class="flag">
<dt id="coq:flag.ssrhave-notcresolution">
<em class="property"><span class="sigannot">Flag</span></em> <code class="descname"><span class="notation"><span>SsrHave</span> <span>NoTCResolution</span></span></code><a class="headerlink" href="#coq:flag.ssrhave-notcresolution" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>This option restores the behavior of <span class="smallcaps">SSReflect</span> 1.4 and below (never resolve typeclasses).</p>
</dd></dl>

</div>
<div class="section" id="variants-the-suff-and-wlog-tactics">
<h4>Variants: the suff and wlog tactics<a class="headerlink" href="#variants-the-suff-and-wlog-tactics" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>As it is often the case in mathematical textbooks, forward reasoning
may be used in slightly different variants. One of these variants is
to show that the intermediate step L easily implies the initial goal
G. By easily we mean here that the proof of L ⇒ G is shorter than the
one of L itself. This kind of reasoning step usually starts with: “It
suffices to show that …”.</p>
<p>This is such a frequent way of reasoning that <span class="smallcaps">SSReflect</span> has a variant
of the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic called <code class="docutils literal notranslate"><span class="pre">suffices</span></code> (whose abridged name is <code class="docutils literal notranslate"><span class="pre">suff</span></code>).
The
<code class="docutils literal notranslate"><span class="pre">have</span></code> and <code class="docutils literal notranslate"><span class="pre">suff</span></code> tactics are equivalent and have the same syntax but:</p>
<ul>
<li><p class="first">the order of the generated subgoals is inversed</p>
</li>
<li><p class="first">but the optional clear item is still performed in the <em>second</em>
branch. This means that the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">suff</span><span> {</span><span class="coqdoc-var">H</span><span>} </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> &gt;= 0.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 6-7:
&gt; suff {H} H : forall x : nat, x &gt;= 0.
&gt;       ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No such hypothesis: H</span></dd>
</dl>
</div>
<p>fails if the context of the current goal indeed contains an
assumption named <code class="docutils literal notranslate"><span class="pre">H</span></code>.</p>
</li>
</ul>
<p>The rationale of this clearing policy is to make possible “trivial”
refinements of an assumption, without changing its name in the main
branch of the reasoning.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">have</span></code> modifier can follow the <code class="docutils literal notranslate"><span class="pre">suff</span></code> tactic.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axioms</span><span> </span><span class="coqdoc-var">G</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">G is declared
P is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">G</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">G</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">suff</span><span> </span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  H : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">G</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">G</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">G</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">Note that, in contrast with <code class="docutils literal notranslate"><span class="pre">have</span> <span class="pre">suff</span></code>, the name H has been introduced
in the first goal.</p>
</div>
<p>Another useful construct is reduction, showing that a particular case
is in fact general enough to prove a general property. This kind of
reasoning step usually starts with: “Without loss of generality, we
can suppose that …”. Formally, this corresponds to the proof of a goal
<code class="docutils literal notranslate"><span class="pre">G</span></code> by introducing a cut <code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. Hence the user shall
provide a proof for both <code class="docutils literal notranslate"><span class="pre">(wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G)</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code> and
<code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. However, such cuts are usually rather
painful to perform by
hand, because the statement <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code> is tedious to write by hand,
and sometimes even to read.</p>
<p><span class="smallcaps">SSReflect</span> implements this kind of reasoning step through the <a class="reference internal" href="#coq:tacv.without-loss" title="without loss"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code></a>
tactic, whose short name is <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a>. It offers support to describe
the shape of the cut statements, by providing the simplifying
hypothesis and by pointing at the elements of the initial goals which
should be generalized. The general syntax of without loss is:</p>
<dl class="tacn">
<dt id="coq:tacn.wlog">
<code class="descname"><span class="notation"><span>wlog</span> <span class="repeat-wrapper"><span class="repeat"><span>suff</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">*</span></span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.wlog" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.without-loss">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>without</span> <span>loss</span> <span class="repeat-wrapper"><span class="repeat"><span>suff</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">*</span></span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacv.without-loss" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where each <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is a constant in the context
of the goal. Open syntax is supported for <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>.</p>
<p>In its defective form:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>wlog:</span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>without</span> <span>loss:</span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>on a goal G, it creates two subgoals: a first one to prove the
formula (term -&gt; G) -&gt; G and a second one to prove the formula
term -&gt; G.</p>
<p>If the optional list of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is present
on the left side of <code class="docutils literal notranslate"><span class="pre">/</span></code>, these constants are generalized in the
premise (term -&gt; G) of the first subgoal. By default bodies of local
definitions are erased. This behavior can be inhibited by prefixing the
name of the local definition with the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> character.</p>
<p>In the second subgoal, the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">clear_switch</span><span> </span><span class="coqdoc-var">i_item</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-26:
&gt; move=&gt; clear_switch i_item.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">move</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrmovearg) (ssrclauses)&quot; failed.
No assumption in </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">G</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>is performed if at least one of these optional switches is present in
the <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a> tactic.</p>
<p>The <a class="reference internal" href="#coq:tacn.wlog" title="wlog"><code class="xref coq coq-tacn docutils literal notranslate"><span class="pre">wlog</span></code></a> tactic is specially useful when a symmetry argument
simplifies a proof. Here is an example showing the beginning of the
proof that quotient and reminder of natural number euclidean division
are unique.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">quo_rem_unicity</span><span> </span><span class="coqdoc-var">d</span><span> </span><span class="coqdoc-var">q1</span><span> </span><span class="coqdoc-var">q2</span><span> </span><span class="coqdoc-var">r1</span><span> </span><span class="coqdoc-var">r2</span><span> :</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">q1</span><span>*</span><span class="coqdoc-var">d</span><span> + </span><span class="coqdoc-var">r1</span><span> = </span><span class="coqdoc-var">q2</span><span>*</span><span class="coqdoc-var">d</span><span> + </span><span class="coqdoc-var">r2</span><span> -&gt; </span><span class="coqdoc-var">r1</span><span> &lt; </span><span class="coqdoc-var">d</span><span> -&gt; </span><span class="coqdoc-var">r2</span><span> &lt; </span><span class="coqdoc-var">d</span><span> -&gt; (</span><span class="coqdoc-var">q1</span><span>, </span><span class="coqdoc-var">r1</span><span>) = (</span><span class="coqdoc-var">q2</span><span>, </span><span class="coqdoc-var">r2</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  d, q1, q2, r1, r2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">wlog</span><span>: </span><span class="coqdoc-var">q1</span><span> </span><span class="coqdoc-var">q2</span><span> </span><span class="coqdoc-var">r1</span><span> </span><span class="coqdoc-var">r2</span><span> / </span><span class="coqdoc-var">q1</span><span> &lt;= </span><span class="coqdoc-var">q2</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  d, q1, q2, r1, r2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> q3 q4 r3 r4 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
   </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q4</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
   </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q4</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r4</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r4</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q4</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r4</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">case</span><span> (</span><span class="coqdoc-var">le_gt_dec</span><span> </span><span class="coqdoc-var">q1</span><span> </span><span class="coqdoc-var">q2</span><span>)=&gt; </span><span class="coqdoc-var">H</span><span>; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-tactic">symmetry</span><span>; </span><span class="coqdoc-tactic">eauto</span><span> </span><span class="coqdoc-keyword">with</span><span> </span><span class="coqdoc-var">arith</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  d, q1, q2, r1, r2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">(</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">q2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">r2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">wlog</span> <span class="pre">suff</span></code> variant is simpler, since it cuts <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code> instead
of <code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>. It thus opens the goals
<code class="docutils literal notranslate"><span class="pre">wlog_statement</span> <span class="pre">-&gt;</span> <span class="pre">G</span></code>
and <code class="docutils literal notranslate"><span class="pre">wlog_statement</span></code>.</p>
<p>In its simplest form the <code class="docutils literal notranslate"><span class="pre">generally</span> <span class="pre">have</span> <span class="pre">:</span> <span class="pre">…</span></code> tactic is equivalent to
<code class="docutils literal notranslate"><span class="pre">wlog</span> <span class="pre">suff</span> <span class="pre">:</span> <span class="pre">…</span></code> followed by last first. When the <code class="docutils literal notranslate"><span class="pre">have</span></code> tactic is used
with the <code class="docutils literal notranslate"><span class="pre">generally</span></code> (or <code class="docutils literal notranslate"><span class="pre">gen</span></code>) modifier it accepts an extra identifier
followed by a comma before the usual intro pattern. The identifier
will name the new hypothesis in its more general form, while the intro
pattern will be used to process its instance.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">P is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axioms</span><span> </span><span class="coqdoc-var">eqn</span><span> </span><span class="coqdoc-var">leqn</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">eqn is declared
leqn is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Notation</span><span> &quot;a != b&quot; := (</span><span class="coqdoc-var">eqn</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 70) : </span><span class="coqdoc-var">this_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Notation</span><span> &quot;a &lt;= b&quot; := (</span><span class="coqdoc-var">leqn</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 70) : </span><span class="coqdoc-var">this_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Open</span><span> </span><span class="coqdoc-keyword">Scope</span><span> </span><span class="coqdoc-var">this_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-tactic">simple</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">ngt0</span><span> : 0 &lt; </span><span class="coqdoc-var">n</span><span> ) : </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ngt0 : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">gen</span><span> </span><span class="coqdoc-var">have</span><span> </span><span class="coqdoc-var">ltnV</span><span>, /</span><span class="coqdoc-var">andP</span><span>[</span><span class="coqdoc-var">nge0</span><span> </span><span class="coqdoc-var">neq0</span><span>] : </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">ngt0</span><span> / (0 &lt;= </span><span class="coqdoc-var">n</span><span>) &amp;&amp; (</span><span class="coqdoc-var">n</span><span> != 0).</span></dt>
<dd><span class="first">2 subgoals
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ngt0 : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">!= </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">0)

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">Focus</span><span> 2.</span></dt>
<dd><span class="first">Toplevel input, characters 0-7:
&gt; Focus 2
&gt; ^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> The Focus command is deprecated; use '2: {' instead
[deprecated-focus,deprecated]
1 subgoal
  
  n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ngt0 : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ltnV : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">!= </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">0)
  nge0 : 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  neq0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">!= </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">0
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<div class="section" id="advanced-generalization">
<span id="advanced-generalization-ssr"></span><h5>Advanced generalization<a class="headerlink" href="#advanced-generalization" title="このヘッドラインへのパーマリンク">¶</a></h5>
<p>The complete syntax for the items on the left hand side of the <code class="docutils literal notranslate"><span class="pre">/</span></code>
separator is the following one:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>wlog</span> <span>…</span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> <span>|</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>|</span> <span>(</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a><span>)</span></span><span class="notation-sup">?</span></span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>Clear operations are intertwined with generalization operations. This
helps in particular avoiding dependency issues while generalizing some
facts.</p>
<p>If an <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is prefixed with the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> mark, then a let-in redex is
created, which keeps track if its body (if any). The syntax
<code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">ident</span> <span class="pre">:=</span> <span class="pre">c_pattern)</span></code> allows to generalize an arbitrary term using a
given name. Note that its simplest form <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">:=</span> <span class="pre">y)</span></code> is just a renaming of
<code class="docutils literal notranslate"><span class="pre">y</span></code> into <code class="docutils literal notranslate"><span class="pre">x</span></code>. In particular, this can be useful in order to simulate the
generalization of a section variable, otherwise not allowed. Indeed
renaming does not require the original variable to be cleared.</p>
<p>The syntax <code class="docutils literal notranslate"><span class="pre">(&#64;x</span> <span class="pre">:=</span> <span class="pre">y)</span></code> generates a let-in abstraction but with the
following caveat: <code class="docutils literal notranslate"><span class="pre">x</span></code> will not bind <code class="docutils literal notranslate"><span class="pre">y</span></code>, but its body, whenever <code class="docutils literal notranslate"><span class="pre">y</span></code> can be
unfolded. This covers the case of both local and global definitions, as
illustrated in the following example.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd><span class="first last">x is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first last">addx is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">addx</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">wlog</span><span> </span><span class="coqdoc-var">H</span><span> : (</span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">x</span><span>) (&#64;</span><span class="coqdoc-var">twoy</span><span> := </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>) / </span><span class="coqdoc-var">twoy</span><span> = 2 * </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">let</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> twoy := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">in</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">twoy</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">twoy</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">addx</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">twoy</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>To avoid unfolding the term captured by the pattern add x one can use
the pattern <code class="docutils literal notranslate"><span class="pre">id</span> <span class="pre">(addx</span> <span class="pre">x)</span></code>, that would produce the following first
subgoal</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span> </span><span class="coqdoc-keyword">All</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">Omega</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-30:
&gt; From Coq Require Import Omega.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Use of “Require” inside a section is deprecated.</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-17:
&gt; Variable x : nat.
&gt; ^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> x already exists.</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">z</span><span> := </span><span class="coqdoc-var">z</span><span> + </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-27:
&gt; Definition addx z := z + x.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> addx already exists.</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">x</span><span> &lt;= </span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">addx</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">wlog</span><span> </span><span class="coqdoc-var">H</span><span> : (</span><span class="coqdoc-var">y</span><span> := </span><span class="coqdoc-var">x</span><span>) (&#64;</span><span class="coqdoc-var">twoy</span><span> := </span><span class="coqdoc-var">id</span><span> (</span><span class="coqdoc-var">addx</span><span> </span><span class="coqdoc-var">x</span><span>)) / </span><span class="coqdoc-var">twoy</span><span> = 2 * </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">let</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> twoy := </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">addx</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">in</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">twoy</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">addx</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">addx</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">addx</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="rewriting">
<span id="rewriting-ssr"></span><h2>Rewriting<a class="headerlink" href="#rewriting" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The generalized use of reflection implies that most of the
intermediate results handled are properties of effectively computable
functions. The most efficient mean of establishing such results are
computation and simplification of expressions involving such
functions, i.e., rewriting. <span class="smallcaps">SSReflect</span> therefore includes an
extended <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic, that unifies and combines most of the
rewriting functionalities.</p>
<div class="section" id="an-extended-rewrite-tactic">
<h3>An extended rewrite tactic<a class="headerlink" href="#an-extended-rewrite-tactic" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The main features of the rewrite tactic are:</p>
<ul class="simple">
<li>It can perform an entire series of such operations in any subset of
the goal and/or context;</li>
<li>It allows to perform rewriting, simplifications, folding/unfolding
of definitions, closing of goals;</li>
<li>Several rewriting operations can be chained in a single tactic;</li>
<li>Control over the occurrence at which rewriting is to be performed is
significantly enhanced.</li>
</ul>
<p>The general form of an <span class="smallcaps">SSReflect</span> rewrite tactic is:</p>
<dl class="tacn">
<dt id="coq:tacn.rewrite-ssreflect">
<code class="descname"><span class="notation"><span>rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-rstep"><span class="hole">rstep</span></a></span><span class="notation-sup">+</span></span></span></code><a class="headerlink" href="#coq:tacn.rewrite-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The combination of a rewrite tactic with the in tactical (see section
<a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a>) performs rewriting in both the context and the goal.</p>
<p>A rewrite step <a class="reference internal" href="#grammar-token-rstep"><code class="xref std std-token docutils literal notranslate"><span class="pre">rstep</span></code></a> has the general form:</p>
<dl class="prodn">
<dt id="grammar-token-rstep">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">rstep</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></code><a class="headerlink" href="#grammar-token-rstep" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-r_prefix">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">r_prefix</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>[</span> <a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a> <span>]</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#grammar-token-r_prefix" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-r_pattern">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">r_pattern</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="meta">|</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="meta">|</span> <span class="meta">(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <span class="meta">|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span> <span class="meta">)</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#grammar-token-r_pattern" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="prodn">
<dt id="grammar-token-r_item">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">r_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>/</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></code><a class="headerlink" href="#grammar-token-r_item" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>An <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> contains annotations to qualify where and how the rewrite
operation should be performed:</p>
<ul class="simple">
<li>The optional initial <code class="docutils literal notranslate"><span class="pre">-</span></code> indicates the direction of the rewriting of
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>:
if present the direction is right-to-left and it is left-to-right otherwise.</li>
<li>The multiplier <a class="reference internal" href="#grammar-token-mult"><code class="xref std std-token docutils literal notranslate"><span class="pre">mult</span></code></a> (see section <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a>)
specifies if and how the
rewrite operation should be repeated.</li>
<li>A rewrite operation matches the occurrences of a <em>rewrite pattern</em>,
and replaces these occurrences by another term, according to the
given <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>. The optional <em>redex switch</em> <code class="docutils literal notranslate"><span class="pre">[r_pattern]</span></code>,
which should
always be surrounded by brackets, gives explicitly this rewrite
pattern. In its simplest form, it is a regular term. If no explicit
redex switch is present the rewrite pattern to be matched is inferred
from the <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>.</li>
<li>This optional term, or the <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>, may be preceded by an occurrence
switch (see section <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a>) or a clear item
(see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>),
these two possibilities being exclusive. An occurrence switch selects
the occurrences of the rewrite pattern which should be affected by the
rewrite operation.</li>
</ul>
<p>An <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> can be:</p>
<ul>
<li><p class="first">A <em>simplification</em> <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>,
represented by a <a class="reference internal" href="#grammar-token-s_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">s_item</span></code></a> (see section
<a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a>). Simplification operations are intertwined with the possible
other rewrite operations specified by the list of <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>.</p>
</li>
<li><p class="first">A <em>folding/unfolding</em> <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>. The tactic:
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/term</span></code> unfolds the
head constant of term in every occurrence of the first matching of
term in the goal. In particular, if <code class="docutils literal notranslate"><span class="pre">my_def</span></code> is a (local or global)
defined constant, the tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/my_def.</span></code> is analogous to:
<code class="docutils literal notranslate"><span class="pre">unfold</span> <span class="pre">my_def</span></code>.
Conversely: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-/my_def.</span></code> is equivalent to: <code class="docutils literal notranslate"><span class="pre">fold</span> <span class="pre">my_def</span></code>.
When an unfold <a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a> is combined with a
redex pattern, a conversion
operation is performed. A tactic of the form:
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-[term1]/term2.</span></code>
is equivalent to: <code class="docutils literal notranslate"><span class="pre">change</span> <span class="pre">term1</span> <span class="pre">with</span> <span class="pre">term2.</span></code> If <code class="docutils literal notranslate"><span class="pre">term2</span></code> is a
single constant and <code class="docutils literal notranslate"><span class="pre">term1</span></code> head symbol is not <code class="docutils literal notranslate"><span class="pre">term2</span></code>, then the head
symbol of <code class="docutils literal notranslate"><span class="pre">term1</span></code> is repeatedly unfolded until <code class="docutils literal notranslate"><span class="pre">term2</span></code> appears.</p>
</li>
<li><dl class="first docutils">
<dt>A <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a>, which can be:</dt>
<dd><ul class="first last simple">
<li>A term whose type has the form:
<code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">(x1</span> <span class="pre">:</span> <span class="pre">A1</span> <span class="pre">)…(xn</span> <span class="pre">:</span> <span class="pre">An</span> <span class="pre">),</span> <span class="pre">eq</span> <span class="pre">term1</span> <span class="pre">term2</span></code> where
<code class="docutils literal notranslate"><span class="pre">eq</span></code> is the Leibniz equality or a registered setoid
equality.</li>
<li>A list of terms <code class="docutils literal notranslate"><span class="pre">(t1</span> <span class="pre">,…,tn)</span></code>, each <code class="docutils literal notranslate"><span class="pre">ti</span></code> having a type above.
The tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">r_prefix</span> <span class="pre">(t1</span> <span class="pre">,…,tn</span> <span class="pre">).</span></code>
is equivalent to: <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">[rewrite</span> <span class="pre">r_prefix</span> <span class="pre">t1</span> <span class="pre">|</span> <span class="pre">…</span> <span class="pre">|</span> <span class="pre">rewrite</span> <span class="pre">r_prefix</span> <span class="pre">tn</span> <span class="pre">].</span></code></li>
<li>An anonymous rewrite lemma <code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code>, where term has a type as above.  tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">term)</span></code> is in fact synonym of: <code class="docutils literal notranslate"><span class="pre">cutrewrite</span> <span class="pre">(term).</span></code>.</li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">double</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first last">double is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">ddouble</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">double</span><span> (</span><span class="coqdoc-var">double</span><span> </span><span class="coqdoc-var">x</span><span>).</span></dt>
<dd><span class="first last">ddouble is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">ddouble</span><span> </span><span class="coqdoc-var">x</span><span> = 4 * </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">ddouble</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">ddouble</span><span> </span><span class="coqdoc-var">_</span><span>]/</span><span class="coqdoc-var">double</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">double</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">double</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>The <span class="smallcaps">SSReflect</span> terms containing holes are <em>not</em> typed as
abstractions in this context. Hence the following script fails.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> := </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> =&gt; </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first last">f is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> -[</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span>]/(</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">_</span><span>).</span></dt>
<dd><span class="first">Toplevel input, characters 0-22:
&gt; rewrite -[f y]/(y + _).
&gt; ^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rewrite</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrrwargs) (ssrclauses)&quot; failed.
fold pattern (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) does not match redex (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>but the following script succeeds</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Restart</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> -[</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">x</span><span>]/(</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">_</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</li>
</ul>
</div>
<div class="section" id="remarks-and-examples">
<h3>Remarks and examples<a class="headerlink" href="#remarks-and-examples" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="rewrite-redex-selection">
<h4>Rewrite redex selection<a class="headerlink" href="#rewrite-redex-selection" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The general strategy of <span class="smallcaps">SSReflect</span> is to grasp as many redexes as
possible and to let the user select the ones to be rewritten thanks to
the improved syntax for the control of rewriting.</p>
<p>This may be a source of incompatibilities between the two rewrite
tactics.</p>
<p>In a rewrite tactic of the form:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">occ_switch</span><span> [</span><span class="coqdoc-var">term1</span><span>]</span><span class="coqdoc-var">term2</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 8-18:
&gt; rewrite occ_switch [term1]term2.
&gt;         ^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rewrite</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrrwargs) (ssrclauses)&quot; failed.
       The reference occ_switch was not found in the current environment.</span></dd>
</dl>
</div>
<p><code class="docutils literal notranslate"><span class="pre">term1</span></code> is the explicit rewrite redex and <code class="docutils literal notranslate"><span class="pre">term2</span></code> is the rewrite rule.
This execution of this tactic unfolds as follows:</p>
<ul class="simple">
<li>First <code class="docutils literal notranslate"><span class="pre">term1</span></code> and <code class="docutils literal notranslate"><span class="pre">term2</span></code> are βι normalized. Then <code class="docutils literal notranslate"><span class="pre">term2</span></code>
is put in head
normal form if the Leibniz equality constructor <code class="docutils literal notranslate"><span class="pre">eq</span></code> is not the head
symbol. This may involve ζ reductions.</li>
<li>Then, the matching algorithm (see section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>)
determines the
first subterm of the goal matching the rewrite pattern. The rewrite
pattern is given by <code class="docutils literal notranslate"><span class="pre">term1</span></code>, if an explicit redex pattern switch is
provided, or by the type of <code class="docutils literal notranslate"><span class="pre">term2</span></code> otherwise. However, matching skips
over matches that would lead to trivial rewrites. All the occurrences
of this subterm in the goal are candidates for rewriting.</li>
<li>Then only the occurrences coded by <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> (see again section
<a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>) are finally selected for rewriting.</li>
<li>The left hand side of <code class="docutils literal notranslate"><span class="pre">term2</span></code> is unified with the subterm found by
the matching algorithm, and if this succeeds, all the selected
occurrences in the goal are replaced by the right hand side of <code class="docutils literal notranslate"><span class="pre">term2</span></code>.</li>
<li>Finally the goal is βι normalized.</li>
</ul>
<p>In the case <code class="docutils literal notranslate"><span class="pre">term2</span></code> is a list of terms, the first top-down (in the
goal) left-to-right (in the list) matching rule gets selected.</p>
</div>
<div class="section" id="chained-rewrite-steps">
<h4>Chained rewrite steps<a class="headerlink" href="#chained-rewrite-steps" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The possibility to chain rewrite operations in a single tactic makes
scripts more compact and gathers in a single command line a bunch of
surgical operations which would be described by a one sentence in a
pen and paper proof.</p>
<p>Performing rewrite and simplification operations in a single tactic
enhances significantly the concision of scripts. For instance the
tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> /</span><span class="coqdoc-var">my_def</span><span> {2}[</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>]/= </span><span class="coqdoc-var">my_eq</span><span> //=.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 9-15:
&gt; rewrite /my_def {2}[f _]/= my_eq //=.
&gt;          ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rewrite</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrrwargs) (ssrclauses)&quot; failed.
       The reference my_def was not found in the current environment.</span></dd>
</dl>
</div>
<p>unfolds <code class="docutils literal notranslate"><span class="pre">my_def</span></code> in the goal, simplifies the second occurrence of the
first subterm matching pattern <code class="docutils literal notranslate"><span class="pre">[f</span> <span class="pre">_]</span></code>, rewrites <code class="docutils literal notranslate"><span class="pre">my_eq</span></code>, simplifies the
goals and closes trivial goals.</p>
<p>Here are some concrete examples of chained rewrite operations, in the
proof of basic results on natural numbers arithmetic.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addn0</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">m</span><span> + 0 = </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd><span class="first last">addn0 is declared</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addnS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>).</span></dt>
<dd><span class="first last">addnS is declared</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addSnnS</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first last">addSnnS is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">addnCA</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">m</span><span> + (</span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">p</span><span>) = </span><span class="coqdoc-var">n</span><span> + (</span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">p</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  m, n, p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span> =&gt; [ | </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">Hrec</span><span>] </span><span class="coqdoc-var">p</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> ?</span><span class="coqdoc-var">addSnnS</span><span> -?</span><span class="coqdoc-var">addnS</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd><span class="first last">addnCA is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">addnC</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> -{1}[</span><span class="coqdoc-var">n</span><span>]</span><span class="coqdoc-var">addn0</span><span> </span><span class="coqdoc-var">addnCA</span><span> </span><span class="coqdoc-var">addn0</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd><span class="first last">addnC is defined</span></dd>
</dl>
</div>
</div>
<p>Note the use of the <code class="docutils literal notranslate"><span class="pre">?</span></code> switch for parallel rewrite operations in the
proof of <code class="docutils literal notranslate"><span class="pre">addnCA</span></code>.</p>
</div>
<div class="section" id="explicit-redex-switches-are-matched-first">
<h4>Explicit redex switches are matched first<a class="headerlink" href="#explicit-redex-switches-are-matched-first" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>If an <a class="reference internal" href="#grammar-token-r_prefix"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_prefix</span></code></a> involves a <em>redex switch</em>, the first step is to find a
subterm matching this redex pattern, independently from the left hand
side of the equality the user wants to rewrite.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">u</span><span>, </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">u</span><span> = </span><span class="coqdoc-var">u</span><span> + </span><span class="coqdoc-var">t</span><span>) </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> t u : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> t u : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Note that if this first pattern matching is not compatible with the
<a class="reference internal" href="#grammar-token-r_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_item</span></code></a>, the rewrite fails, even if the goal contains a
correct redex matching both the redex switch and the left hand side of
the equality.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">t</span><span> </span><span class="coqdoc-var">u</span><span>, </span><span class="coqdoc-var">t</span><span> + </span><span class="coqdoc-var">u</span><span> * 0 = </span><span class="coqdoc-var">t</span><span>) </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> * 4 + 2 * 0 = </span><span class="coqdoc-var">x</span><span> + 2 * 0.</span></dt>
<dd><span class="first">1 subgoal
  
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> t u : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 0-16:
&gt; rewrite [x + _]H.
&gt; ^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rewrite</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrrwargs) (ssrclauses)&quot; failed.
pattern (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 4) does not match LHS of </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">Indeed the left hand side of <code class="docutils literal notranslate"><span class="pre">H</span></code> does not match
the redex identified by the pattern <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">*</span> <span class="pre">4</span></code>.</p>
</div>
</div>
<div class="section" id="occurrence-switches-and-redex-switches">
<h4>Occurrence switches and redex switches<a class="headerlink" href="#occurrence-switches-and-redex-switches" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + 0 = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">y</span><span> + 0 + 0 + (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + 0).</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0)</span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> {2}[</span><span class="coqdoc-var">_</span><span> + </span><span class="coqdoc-var">y</span><span> + 0](</span><span class="coqdoc-var">_</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">z</span><span>, </span><span class="coqdoc-var">z</span><span> + 0 = </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd><span class="first">2 subgoals
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
</div>
<p>The second subgoal is generated by the use of an anonymous lemma in
the rewrite tactic. The effect of the tactic on the initial goal is to
rewrite this lemma at the second occurrence of the first matching
<code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">0</span></code> of the explicit rewrite redex <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">+</span> <span class="pre">0</span></code>.</p>
</div>
<div class="section" id="occurrence-selection-and-repetition">
<h4>Occurrence selection and repetition<a class="headerlink" href="#occurrence-selection-and-repetition" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>Occurrence selection has priority over repetition switches. This means
the repetition of a rewrite tactic specified by a multiplier will
perform matching each time an elementary rewrite operation is
performed. Repeated rewrite tactics apply to every subgoal generated
by the previous tactic, including the previous instances of the
repetition.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> (</span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">x</span><span> + 1 = </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> + 1.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 1</span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> 2!(</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">_</span><span> + 1 = </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd><span class="first">4 subgoals
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
subgoal 3 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
subgoal 4 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>This last tactic generates <em>three</em> subgoals because
the second rewrite operation specified with the <code class="docutils literal notranslate"><span class="pre">2!</span></code> multiplier
applies to the two subgoals generated by the first rewrite.</p>
</div>
<div class="section" id="multi-rule-rewriting">
<h4>Multi-rule rewriting<a class="headerlink" href="#multi-rule-rewriting" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The rewrite tactic can be provided a <em>tuple</em> of rewrite rules, or more
generally a tree of such rules, since this tuple can feature arbitrary
inner parentheses. We call <em>multirule</em> such a generalized rewrite
rule. This feature is of special interest when it is combined with
multiplier switches, which makes the rewrite tactic iterate the
rewrite operations prescribed by the rules on the current goal.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variables</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span> : </span><span class="coqdoc-var">nat</span><span>).</span></dt>
<dd><span class="first last">a is declared
b is declared
c is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqab</span><span> : </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first last">eqab is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqac</span><span> : </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">c</span><span>.</span></dt>
<dd><span class="first last">eqac is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b, c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqab : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqac : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">eqab</span><span>, </span><span class="coqdoc-var">eqac</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  a, b, c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqab : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqac : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Indeed rule <code class="docutils literal notranslate"><span class="pre">eqab</span></code> is the first to apply among the ones
gathered in the tuple passed to the rewrite tactic. This multirule
<code class="docutils literal notranslate"><span class="pre">(eqab,</span> <span class="pre">eqac)</span></code> is actually a <span class="smallcaps">Coq</span> term and we can name it with a
definition:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi1</span><span> := (</span><span class="coqdoc-var">eqab</span><span>, </span><span class="coqdoc-var">eqac</span><span>).</span></dt>
<dd><span class="first last">multi1 is defined</span></dd>
</dl>
</div>
<p class="last">In this case, the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">multi1</span></code> is a synonym for
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(eqab,</span> <span class="pre">eqac)</span></code>.</p>
</div>
<p>More precisely, a multirule rewrites the first subterm to which one of
the rules applies in a left-to-right traversal of the goal, with the
first rule from the multirule tree in left-to-right order. Matching is
performed according to the algorithm described in
Section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>, but
literal matches have priority.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">d</span><span> := </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first last">d is defined</span></dd>
<dt><span class="coqdoc-keyword">Hypotheses</span><span> </span><span class="coqdoc-var">eqd0</span><span> : </span><span class="coqdoc-var">d</span><span> = 0.</span></dt>
<dd><span class="first last">eqd0 is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi2</span><span> := (</span><span class="coqdoc-var">eqab</span><span>, </span><span class="coqdoc-var">eqd0</span><span>).</span></dt>
<dd><span class="first last">multi2 is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">d</span><span> = </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b, c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqab : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqac : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqd0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">multi2</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b, c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqab : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqac : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqd0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">Indeed rule <code class="docutils literal notranslate"><span class="pre">eqd0</span></code> applies without unfolding the
definition of <code class="docutils literal notranslate"><span class="pre">d</span></code>.</p>
</div>
<p>For repeated rewrites the selection process is
repeated anew.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eq_adda_b</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first last">eq_adda_b is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eq_adda_c</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">a</span><span> = </span><span class="coqdoc-var">c</span><span>.</span></dt>
<dd><span class="first last">eq_adda_c is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqb0</span><span> : </span><span class="coqdoc-var">b</span><span> = 0.</span></dt>
<dd><span class="first last">eqb0 is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi3</span><span> := (</span><span class="coqdoc-var">eq_adda_b</span><span>, </span><span class="coqdoc-var">eq_adda_c</span><span>, </span><span class="coqdoc-var">eqb0</span><span>).</span></dt>
<dd><span class="first last">multi3 is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : 1 + </span><span class="coqdoc-var">a</span><span> = 12 + </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b, c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqab : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqac : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqd0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  eq_adda_b : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eq_adda_c : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqb0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 12</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> 2!</span><span class="coqdoc-var">multi3</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b, c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqab : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqac : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqd0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  eq_adda_b : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eq_adda_c : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  eqb0 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 12</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">It uses <code class="docutils literal notranslate"><span class="pre">eq_adda_b</span></code> then <code class="docutils literal notranslate"><span class="pre">eqb0</span></code> on the left-hand
side only. Without the bound <code class="docutils literal notranslate"><span class="pre">2</span></code> one would obtain <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
</div>
<p>The grouping of rules inside a multirule does not affect the selection
strategy but can make it easier to include one rule set in another or
to (universally) quantify over the parameters of a subset of rules (as
there is special code that will omit unnecessary quantifiers for rules
that can be syntactically extracted). It is also possible to reverse
the direction of a rule subset, using a special dedicated syntax: the
tactic rewrite <code class="docutils literal notranslate"><span class="pre">(=~</span> <span class="pre">multi1)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">multi1_rev</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqba</span><span> : </span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first last">eqba is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">eqca</span><span> : </span><span class="coqdoc-var">c</span><span> = </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first last">eqca is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">multi1_rev</span><span> := (</span><span class="coqdoc-var">eqba</span><span>, </span><span class="coqdoc-var">eqca</span><span>).</span></dt>
<dd><span class="first last">multi1_rev is defined</span></dd>
</dl>
</div>
</div>
<p>except that the constants <code class="docutils literal notranslate"><span class="pre">eqba</span></code>, <code class="docutils literal notranslate"><span class="pre">eqab</span></code>, <code class="docutils literal notranslate"><span class="pre">mult1_rev</span></code>
have not been created.</p>
<p>Rewriting with multirules is useful to implement simplification or
transformation procedures, to be applied on terms of small to medium
size. For instance the library <cite>ssrnat</cite> (Mathematical Components library)
provides two implementations
for arithmetic operations on natural numbers: an elementary one and a
tail recursive version, less inefficient but also less convenient for
reasoning purposes. The library also provides one lemma per such
operation, stating that both versions return the same values when
applied to the same arguments:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">addE</span><span> : </span><span class="coqdoc-var">add</span><span> =2 </span><span class="coqdoc-var">addn</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 13-16:
&gt; Lemma addE : add =2 addn.
&gt;              ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference add was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">doubleE</span><span> : </span><span class="coqdoc-var">double</span><span> =1 </span><span class="coqdoc-var">doublen</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 16-22:
&gt; Lemma doubleE : double =1 doublen.
&gt;                 ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference double was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">add_mulE</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">add_mul</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">s</span><span> = </span><span class="coqdoc-var">addn</span><span> (</span><span class="coqdoc-var">muln</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span>) </span><span class="coqdoc-var">s</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 23-30:
&gt; Lemma add_mulE n m s : add_mul n m s = addn (muln n m) s.
&gt;                        ^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference add_mul was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">mulE</span><span> : </span><span class="coqdoc-var">mul</span><span> =2 </span><span class="coqdoc-var">muln</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 13-16:
&gt; Lemma mulE : mul =2 muln.
&gt;              ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference mul was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">mul_expE</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">mul_exp</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">muln</span><span> (</span><span class="coqdoc-var">expn</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">p</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 23-30:
&gt; Lemma mul_expE m n p : mul_exp m n p = muln (expn m n) p.
&gt;                        ^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference mul_exp was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">expE</span><span> : </span><span class="coqdoc-var">exp</span><span> =2 </span><span class="coqdoc-var">expn</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 13-16:
&gt; Lemma expE : exp =2 expn.
&gt;              ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference exp was not found in the current environment.</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">oddE</span><span> : </span><span class="coqdoc-var">odd</span><span> =1 </span><span class="coqdoc-var">oddn</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 13-16:
&gt; Lemma oddE : odd =1 oddn.
&gt;              ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference odd was not found in the current environment.</span></dd>
</dl>
</div>
<p>The operation on the left hand side of each lemma is the efficient
version, and the corresponding naive implementation is on the right
hand side. In order to reason conveniently on expressions involving
the efficient operations, we gather all these rules in the definition
<code class="docutils literal notranslate"><span class="pre">trecE</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">trecE</span><span> := (</span><span class="coqdoc-var">addE</span><span>, (</span><span class="coqdoc-var">doubleE</span><span>, </span><span class="coqdoc-var">oddE</span><span>), (</span><span class="coqdoc-var">mulE</span><span>, </span><span class="coqdoc-var">add_mulE</span><span>, (</span><span class="coqdoc-var">expE</span><span>, </span><span class="coqdoc-var">mul_expE</span><span>))).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 21-25:
&gt; Definition trecE := (addE, (doubleE, oddE), (mulE, add_mulE, (expE, mul_expE))).
&gt;                      ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference addE was not found in the current environment.</span></dd>
</dl>
</div>
<p>The tactic: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">!trecE.</span></code>
restores the naive versions of each operation in a goal involving the
efficient ones, e.g. for the purpose of a correctness proof.</p>
</div>
<div class="section" id="wildcards-vs-abstractions">
<h4>Wildcards vs abstractions<a class="headerlink" href="#wildcards-vs-abstractions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The rewrite tactic supports <code class="xref std std-token docutils literal notranslate"><span class="pre">r_items</span></code> containing holes. For example, in
the tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">_</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0).</span></code>
the term <code class="docutils literal notranslate"><span class="pre">_</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0</span></code> is interpreted as <code class="docutils literal notranslate"><span class="pre">forall</span> <span class="pre">n</span> <span class="pre">:</span> <span class="pre">nat,</span> <span class="pre">n</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0.</span></code>
Anyway this tactic is <em>not</em> equivalent to
<code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">(_</span> <span class="pre">:</span> <span class="pre">forall</span> <span class="pre">x,</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">0</span> <span class="pre">=</span> <span class="pre">0).</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">y</span><span> * 0 + </span><span class="coqdoc-var">y</span><span> * (</span><span class="coqdoc-var">z</span><span> * 0) = 0.</span></dt>
<dd><span class="first">1 subgoal
  
  y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-var">_</span><span> * 0 = 0).</span></dt>
<dd><span class="first">2 subgoals
  
  y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
<p>while the other tactic results in</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> (</span><span class="coqdoc-var">_</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> * 0 = 0).</span></dt>
<dd><span class="first">2 subgoals
  
  y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0

subgoal 2 is:
 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
<p class="last">The first tactic requires you to prove the instance of the (missing)
lemma that was used, while the latter requires you prove the quantified
form.</p>
</div>
</div>
<div class="section" id="when-ssr-rewrite-fails-on-standard-coq-licit-rewrite">
<h4>When <span class="smallcaps">SSReflect</span> rewrite fails on standard <span class="smallcaps">Coq</span> licit rewrite<a class="headerlink" href="#when-ssr-rewrite-fails-on-standard-coq-licit-rewrite" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>In a few cases, the <span class="smallcaps">SSReflect</span> rewrite tactic fails rewriting some
redexes which standard <span class="smallcaps">Coq</span> successfully rewrites. There are two main
cases:</p>
<ul>
<li><p class="first"><span class="smallcaps">SSReflect</span> never accepts to rewrite indeterminate patterns like:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">foo</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">unit</span><span>) : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">tt</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">unit</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">tt</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p><span class="smallcaps">SSReflect</span> will however accept the
ηζ expansion of this rule:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">fubar</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">unit</span><span>) : (</span><span class="coqdoc-keyword">let</span><span> </span><span class="coqdoc-var">u</span><span> := </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">u</span><span>) = </span><span class="coqdoc-var">tt</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
</li>
<li><p class="first">The standard rewrite tactic provided by <span class="smallcaps">Coq</span> uses a different algorithm
to find instances of the rewrite rule.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">g</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span>.</span></dt>
<dd><span class="first last">g is declared</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> := </span><span class="coqdoc-var">g</span><span>.</span></dt>
<dd><span class="first last">f is defined</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">g</span><span> </span><span class="coqdoc-var">x</span><span> = 0.</span></dt>
<dd><span class="first last">H is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">f</span><span> 3 + </span><span class="coqdoc-var">f</span><span> 3 = </span><span class="coqdoc-var">f</span><span> 6.</span></dt>
<dd><span class="first">1 subgoal
  
  g : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> -&gt; </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  g : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
</dl>
</div>
<p>This rewriting is not possible in <span class="smallcaps">SSReflect</span> because
there is no occurrence of the head symbol <code class="docutils literal notranslate"><span class="pre">f</span></code> of the rewrite rule in the
goal.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  g : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 0-9:
&gt; rewrite H.
&gt; ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rewrite</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrrwargs) (ssrclauses)&quot; failed.
The LHS of </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
    (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)
does not match any subterm of the goal</span></dd>
</dl>
</div>
<p>Rewriting with <code class="docutils literal notranslate"><span class="pre">H</span></code> first requires unfolding the occurrences of
<code class="docutils literal notranslate"><span class="pre">f</span></code>
where the substitution is to be performed (here there is a single such
occurrence), using tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/f</span></code> (for a global replacement of
f by g) or <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">pattern/f</span></code>, for a finer selection.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-5:
&gt; Undo.
&gt; ^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Anomaly &quot;error with no safe_id attached: Cannot undo.&quot;
Please report at http://coq.inria.fr/bugs/.</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> /</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  g : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
</dl>
</div>
<p>alternatively one can override the pattern inferred from <code class="docutils literal notranslate"><span class="pre">H</span></code></p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Undo</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  g : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  g : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 6</span></dd>
</dl>
</div>
</div>
</li>
</ul>
</div>
<div class="section" id="existential-metavariables-and-rewriting">
<h4>Existential metavariables and rewriting<a class="headerlink" href="#existential-metavariables-and-rewriting" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The rewrite tactic will not instantiate existing existential
metavariables when matching a redex pattern.</p>
<p>If a rewrite rule generates a goal with new existential metavariables
in the <code class="docutils literal notranslate"><span class="pre">Prop</span></code> sort, these will be generalized as for <code class="docutils literal notranslate"><span class="pre">apply</span></code>
(see <a class="reference internal" href="#apply-ssr"><span class="std std-ref">The apply tactic</span></a>) and
corresponding new goals will be generated.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">leq</span><span> : </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">nat</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>.</span></dt>
<dd><span class="first last">leq is declared</span></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;m &lt;= n&quot; := (</span><span class="coqdoc-var">leq</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">nat_scope</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 0-43:
&gt; Notation &quot;m &lt;= n&quot; := (leq m n) : nat_scope.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Notation _ &lt;= _ was already used in scope nat_scope.</span></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;m &lt; n&quot;  := (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">nat_scope</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 0-44:
&gt; Notation &quot;m &lt; n&quot;  := (S m &lt;= n) : nat_scope.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Notation _ &lt; _ was already used in scope nat_scope.</span></dd>
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span> := </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">of</span><span> </span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first last">Ord is defined
Ord_rect is defined
Ord_ind is defined
Ord_rec is defined</span></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;'I_ n&quot; := (</span><span class="coqdoc-var">Ord</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 8, </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 2, </span><span class="coqdoc-var">format</span><span> &quot;''I_' n&quot;).</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-var">Arguments</span><span> </span><span class="coqdoc-var">Sub</span><span> {</span><span class="coqdoc-var">_</span><span>} </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">val</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">i</span><span> : '</span><span class="coqdoc-var">I_n</span><span>) := </span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">_</span><span> := </span><span class="coqdoc-var">i</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first last">val is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">insub</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> &#64;</span><span class="coqdoc-var">idP</span><span> (</span><span class="coqdoc-var">x</span><span> &lt; </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">ReflectT</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">Px</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">Some</span><span> (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">None</span><span>.</span></dt>
<dd><span class="first last">insub is defined</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">insubT</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>, </span><span class="coqdoc-var">insub</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">Some</span><span> (</span><span class="coqdoc-var">Sub</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">Px</span><span>).</span></dt>
<dd><span class="first last">insubT is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> : '</span><span class="coqdoc-var">I_2</span><span>) </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">Some</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">insub</span><span> 2 </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">insub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">insubT</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  x : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Hyp0 : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Sub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Hyp0</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 2</span></dd>
</dl>
</div>
<p>Since the argument corresponding to Px is not supplied by the user, the
resulting goal should be <code class="docutils literal notranslate"><span class="pre">Some</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">Some</span> <span class="pre">(Sub</span> <span class="pre">y</span> <span class="pre">?Goal).</span></code>
Instead, <span class="smallcaps">SSReflect</span> <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic hides the existential variable.</p>
<p>As in <a class="reference internal" href="#apply-ssr"><span class="std std-ref">The apply tactic</span></a>, the <code class="docutils literal notranslate"><span class="pre">ssrautoprop</span></code> tactic is used to try to
solve the existential variable.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> : '</span><span class="coqdoc-var">I_2</span><span>) </span><span class="coqdoc-var">y</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">y</span><span> &lt; 2) : </span><span class="coqdoc-var">Some</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">insub</span><span> 2 </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">insub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">insubT</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Sub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
</div>
<p>As a temporary limitation, this behavior is available only if the
rewriting rule is stated using Leibniz equality (as opposed to setoid
relations). It will be extended to other rewriting relations in the
future.</p>
</div>
</div>
<div class="section" id="locking-unlocking">
<span id="locking-ssr"></span><h3>Locking, unlocking<a class="headerlink" href="#locking-unlocking" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>As program proofs tend to generate large goals, it is important to be
able to control the partial evaluation performed by the simplification
operations that are performed by the tactics. These evaluations can
for example come from a <code class="docutils literal notranslate"><span class="pre">/=</span></code> simplification switch, or from rewrite
steps which may expand large terms while performing conversion. We
definitely want to avoid repeating large subterms of the goal in the
proof script. We do this by “clamping down” selected function symbols
in the goal, which prevents them from being considered in
simplification or rewriting steps. This clamping is accomplished by
using the occurrence switches (see section:ref:<cite>abbreviations_ssr</cite>)
together with “term tagging” operations.</p>
<p><span class="smallcaps">SSReflect</span> provides two levels of tagging.</p>
<p>The first one uses auxiliary definitions to introduce a provably equal
copy of any term t. However this copy is (on purpose) <em>not
convertible</em> to t in the <span class="smallcaps">Coq</span> system <a class="footnote-reference" href="#id19" id="id9">[17]</a>. The job is done by the
following construction:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">master_key</span><span> : </span><span class="coqdoc-var">unit</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">unit</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Proof</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-tactic">exact</span><span> </span><span class="coqdoc-var">tt</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">No more subgoals.</span></dd>
<dt><span class="coqdoc-keyword">Qed</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">master_key is defined
1 subgoal
  
  x : </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">'I_</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">2
  y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 2
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Some</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Sub</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">H</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">locked</span><span> </span><span class="coqdoc-var">A</span><span> := </span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">tt</span><span> := </span><span class="coqdoc-var">master_key</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">A</span><span> =&gt; </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">locked is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">lock</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">x</span><span>, </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">locked</span><span> </span><span class="coqdoc-var">x</span><span> :&gt; </span><span class="coqdoc-var">A</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (x : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">locked</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Note that the definition of <em>master_key</em> is explicitly opaque. The
equation <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">=</span> <span class="pre">locked</span> <span class="pre">t</span></code> given by the <code class="docutils literal notranslate"><span class="pre">lock</span></code> lemma can be used for
selective rewriting, blocking on the fly the reduction in the term <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrfun</span><span> </span><span class="coqdoc-var">ssrbool</span><span> </span><span class="coqdoc-var">List</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">A</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span></dt>
<dd><span class="first last">A is declared</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">has</span><span> (</span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">A</span><span>) : </span><span class="coqdoc-var">bool</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">l</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">x</span><span> || (</span><span class="coqdoc-var">has</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">l</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">false</span><span>.</span></dt>
<dd><span class="first last">has is defined
has is recursively defined (decreasing on 2nd argument)</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">l</span><span> (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">true</span><span>) : </span><span class="coqdoc-var">has</span><span> </span><span class="coqdoc-var">p</span><span> ( </span><span class="coqdoc-var">x</span><span> :: </span><span class="coqdoc-var">y</span><span> :: </span><span class="coqdoc-var">l</span><span>) = </span><span class="coqdoc-var">true</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">has</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> {2}[</span><span class="coqdoc-var">cons</span><span>]</span><span class="coqdoc-var">lock</span><span> /= -</span><span class="coqdoc-var">lock</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  A : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">A</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">has</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">:: </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>It is sometimes desirable to globally prevent a definition from being
expanded by simplification; this is done by adding locked in the
definition.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">lid</span><span> := </span><span class="coqdoc-var">locked</span><span> (</span><span class="coqdoc-keyword">fun</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> =&gt; </span><span class="coqdoc-var">x</span><span>).</span></dt>
<dd><span class="first last">lid is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> : </span><span class="coqdoc-var">lid</span><span> 3 = 3.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">lid</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 3</span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> /=.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">lid</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 3</span></dd>
<dt><span class="coqdoc-var">unlock</span><span> </span><span class="coqdoc-var">lid</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  ============================
  3</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 3</span></dd>
</dl>
</div>
</div>
<p>We provide a special tactic unlock for unfolding such definitions
while removing “locks”, e.g., the tactic:</p>
<dl class="tacn">
<dt id="coq:tacn.unlock">
<code class="descname"><span class="notation"><span>unlock</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#coq:tacn.unlock" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>replaces the occurrence(s) of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> coded by the
<a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> with the corresponding body.</p>
<p>We found that it was usually preferable to prevent the expansion of
some functions by the partial evaluation switch <code class="docutils literal notranslate"><span class="pre">/=</span></code>, unless this
allowed the evaluation of a condition. This is possible thanks to another
mechanism of term tagging, resting on the following <em>Notation</em>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;'nosimpl' t&quot; := (</span><span class="coqdoc-keyword">let</span><span>: </span><span class="coqdoc-var">tt</span><span> := </span><span class="coqdoc-var">tt</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">t</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-47:
&gt; Notation &quot;'nosimpl' t&quot; := (let: tt := tt in t).
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Cannot determine the level.</span></dd>
</dl>
</div>
<p>The term <code class="docutils literal notranslate"><span class="pre">(nosimpl</span> <span class="pre">t)</span></code> simplifies to <code class="docutils literal notranslate"><span class="pre">t</span></code> <em>except</em> in a definition.
More precisely, given:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">foo</span><span> := (</span><span class="coqdoc-var">nosimpl</span><span> </span><span class="coqdoc-var">bar</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 27-30:
&gt; Definition foo := (nosimpl bar).
&gt;                            ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference bar was not found in the current environment.</span></dd>
</dl>
</div>
<p>the term <code class="docutils literal notranslate"><span class="pre">foo</span></code> (or <code class="docutils literal notranslate"><span class="pre">(foo</span> <span class="pre">t’)</span></code>) will <em>not</em> be expanded by the <em>simpl</em>
tactic unless it is in a forcing context (e.g., in <code class="docutils literal notranslate"><span class="pre">match</span> <span class="pre">foo</span> <span class="pre">t’</span> <span class="pre">with</span> <span class="pre">…</span>
<span class="pre">end</span></code>, <code class="docutils literal notranslate"><span class="pre">foo</span> <span class="pre">t’</span></code> will be reduced if this allows <code class="docutils literal notranslate"><span class="pre">match</span></code> to be reduced).
Note that <code class="docutils literal notranslate"><span class="pre">nosimpl</span> <span class="pre">bar</span></code> is simply notation for a term that reduces to
<code class="docutils literal notranslate"><span class="pre">bar</span></code>; hence <code class="docutils literal notranslate"><span class="pre">unfold</span> <span class="pre">foo</span></code> will replace <code class="docutils literal notranslate"><span class="pre">foo</span></code> by <code class="docutils literal notranslate"><span class="pre">bar</span></code>, and
<code class="docutils literal notranslate"><span class="pre">fold</span> <span class="pre">foo</span></code> will replace <code class="docutils literal notranslate"><span class="pre">bar</span></code> by <code class="docutils literal notranslate"><span class="pre">foo</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p>The <code class="docutils literal notranslate"><span class="pre">nosimpl</span></code> trick only works if no reduction is apparent in
<code class="docutils literal notranslate"><span class="pre">t</span></code>; in particular, the declaration:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">foo</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">nosimpl</span><span> (</span><span class="coqdoc-var">bar</span><span> </span><span class="coqdoc-var">x</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 29-32:
&gt; Definition foo x := nosimpl (bar x).
&gt;                              ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference bar was not found in the current environment.</span></dd>
</dl>
</div>
<p>will usually not work. Anyway, the common practice is to tag only the
function, and to use the following definition, which blocks the
reduction as expected:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">foo</span><span> </span><span class="coqdoc-var">x</span><span> := </span><span class="coqdoc-var">nosimpl</span><span> </span><span class="coqdoc-var">bar</span><span> </span><span class="coqdoc-var">x</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 28-31:
&gt; Definition foo x := nosimpl bar x.
&gt;                             ^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference bar was not found in the current environment.</span></dd>
</dl>
</div>
</div>
<p>A standard example making this technique shine is the case of
arithmetic operations. We define for instance:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">addn</span><span> := </span><span class="coqdoc-var">nosimpl</span><span> </span><span class="coqdoc-var">plus</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">addn is defined</span></dd>
</dl>
</div>
<p>The operation <code class="docutils literal notranslate"><span class="pre">addn</span></code> behaves exactly like <code class="docutils literal notranslate"><span class="pre">plus</span></code>, except that
<code class="docutils literal notranslate"><span class="pre">(addn</span> <span class="pre">(S</span> <span class="pre">n)</span> <span class="pre">m)</span></code> will not simplify spontaneously to
<code class="docutils literal notranslate"><span class="pre">(S</span> <span class="pre">(addn</span> <span class="pre">n</span> <span class="pre">m))</span></code> (the two terms, however, are convertible).
In addition, the unfolding step: <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">/addn</span></code>
will replace <code class="docutils literal notranslate"><span class="pre">addn</span></code> directly with <code class="docutils literal notranslate"><span class="pre">plus</span></code>, so the <code class="docutils literal notranslate"><span class="pre">nosimpl</span></code> form is
essentially invisible.</p>
</div>
<div class="section" id="congruence">
<span id="congruence-ssr"></span><h3>Congruence<a class="headerlink" href="#congruence" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Because of the way matching interferes with parameters of type families,
the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">apply</span><span>: </span><span class="coqdoc-var">my_congr_property</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 7-24:
&gt; apply: my_congr_property.
&gt;        ^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">apply</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrapplyarg)&quot; failed.
       The reference my_congr_property was not found in the current</span></dd>
</dl>
</div>
<p>will generally fail to perform congruence simplification, even on
rather simple cases. We therefore provide a more robust alternative in
which the function is supplied:</p>
<dl class="tacn">
<dt id="coq:tacn.congr">
<code class="descname"><span class="notation"><span>congr</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#coq:tacn.congr" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>This tactic:
+ checks that the goal is a Leibniz equality
+ matches both sides of this equality with “term applied to some arguments”, inferring the right number of arguments from the goal and the type of term. This may expand some definitions or fixpoints.
+ generates the subgoals corresponding to pairwise equalities of the arguments present in the goal.</p>
<p>The goal can be a non dependent product <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">-&gt;</span> <span class="pre">Q</span></code>. In that case, the
system asserts the equation <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>, uses it to solve the goal, and
calls the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic on the remaining goal <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">Q</span></code>. This can be useful
for instance to perform a transitivity step, like in the following
situation.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) (</span><span class="coqdoc-var">H</span><span> : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span>) : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">z</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  H : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">congr</span><span> (</span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">_</span><span>) : </span><span class="coqdoc-var">H</span><span>.</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">nat</span><span>) : </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">x</span><span> = </span><span class="coqdoc-var">z</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">congr</span><span> (</span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">_</span><span>).</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>The optional <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><code class="xref std std-token docutils literal notranslate"><span class="pre">num</span></code></a> forces the number of arguments for which the
tactic should generate equality proof obligations.</p>
<p>This tactic supports equalities between applications with dependent
arguments. Yet dependent arguments should have exactly the same
parameters on both sides, and these parameters should appear as first
arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">n</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> 0 </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">mult</span><span>.</span></dt>
<dd><span class="first last">f is defined</span></dd>
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">g</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> : </span><span class="coqdoc-var">nat</span><span>) := </span><span class="coqdoc-var">plus</span><span>.</span></dt>
<dd><span class="first last">g is defined</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">f</span><span> 0 </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">g</span><span> 1 1 </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">g</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1 1 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">congr</span><span> </span><span class="coqdoc-var">plus</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
<p class="last">This script shows that the <code class="docutils literal notranslate"><span class="pre">congr</span></code> tactic matches <code class="docutils literal notranslate"><span class="pre">plus</span></code>
with <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">0</span></code> on the left hand side and <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">1</span> <span class="pre">1</span></code> on the right hand
side, and solves the goal.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-var">m</span><span> (</span><span class="coqdoc-var">Hnm</span><span> : </span><span class="coqdoc-var">m</span><span> &lt;= </span><span class="coqdoc-var">n</span><span>) : </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span> + (</span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span> - </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">m</span><span>) = </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">n</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hnm : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">congr</span><span> </span><span class="coqdoc-var">S</span><span>; </span><span class="coqdoc-tactic">rewrite</span><span> -/</span><span class="coqdoc-var">plus</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  n, m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hnm : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;=</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">The tactic <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">-/plus</span></code> folds back the expansion of plus
which was necessary for matching both sides of the equality with
an application of <code class="docutils literal notranslate"><span class="pre">S</span></code>.</p>
</div>
<p>Like most <span class="smallcaps">SSReflect</span> arguments, term can contain wildcards.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">x</span><span> + (</span><span class="coqdoc-var">y</span><span> * (</span><span class="coqdoc-var">y</span><span> + </span><span class="coqdoc-var">x</span><span> - </span><span class="coqdoc-var">x</span><span>)) = </span><span class="coqdoc-var">x</span><span> * 1 + (</span><span class="coqdoc-var">y</span><span> + 0) * </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">congr</span><span> ( </span><span class="coqdoc-var">_</span><span> + (</span><span class="coqdoc-var">_</span><span> * </span><span class="coqdoc-var">_</span><span>)).</span></dt>
<dd><span class="first">3 focused subgoals
(shelved: 3)
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> *</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0
subgoal 3 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="contextual-patterns">
<span id="contextual-patterns-ssr"></span><h2>Contextual patterns<a class="headerlink" href="#contextual-patterns" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The simple form of patterns used so far, terms possibly containing
wild cards, often require an additional <a class="reference internal" href="#grammar-token-occ_switch"><code class="xref std std-token docutils literal notranslate"><span class="pre">occ_switch</span></code></a> to be specified.
While this may work pretty fine for small goals, the use of
polymorphic functions and dependent types may lead to an invisible
duplication of function arguments. These copies usually end up in
types hidden by the implicit arguments machinery or by user-defined
notations. In these situations computing the right occurrence numbers
is very tedious because they must be counted on the goal as printed
after setting the <a class="reference internal" href="../language/gallina-extensions.html#coq:flag.printing-all" title="Printing All"><code class="xref coq coq-flag docutils literal notranslate"><span class="pre">Printing</span> <span class="pre">All</span></code></a> flag. Moreover the resulting script is
not really informative for the reader, since it refers to occurrence
numbers he cannot easily see.</p>
<p>Contextual patterns mitigate these issues allowing to specify
occurrences according to the context they occur in.</p>
<div class="section" id="syntax">
<h3>Syntax<a class="headerlink" href="#syntax" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The following table summarizes the full syntax of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> and the
corresponding subterm(s) identified by the pattern. In the third
column we use s.m.r. for “the subterms matching the redex” specified
in the second column.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a></th>
<th class="head">redex</th>
<th class="head">subterms affected</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">term</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term</span></code></td>
<td>all occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></td>
<td>subterm of <code class="docutils literal notranslate"><span class="pre">term</span></code> selected by <code class="docutils literal notranslate"><span class="pre">ident</span></code></td>
<td>all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code> in all the
occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term1</span></code> in all s.m.r.</td>
<td>in all the subterms identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code> in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term2</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">as</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">1</span></code></td>
<td>in all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident`</span>
<span class="pre">in</span> <span class="pre">all</span> <span class="pre">the</span> <span class="pre">occurrences</span> <span class="pre">of</span> <span class="pre">``term2[term</span> <span class="pre">1</span> <span class="pre">/ident]</span></code></td>
</tr>
</tbody>
</table>
<p>The rewrite tactic supports two more patterns obtained prefixing the
first two with in. The intended meaning is that the pattern identifies
all subterms of the specified context. The <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> tactic will infer a
pattern for the redex looking at the rule used for rewriting.</p>
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a></th>
<th class="head">redex</th>
<th class="head">subterms affected</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">term</span></code></td>
<td>inferred from rule</td>
<td>in all s.m.r. in all occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></td>
<td>inferred from rule</td>
<td>in all s.m.r. in all the subterms identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>
in all the occurrences of <code class="docutils literal notranslate"><span class="pre">term</span></code></td>
</tr>
</tbody>
</table>
<p>The first <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> is the simplest form matching any context but
selecting a specific redex and has been described in the previous
sections. We have seen so far that the possibility of selecting a
redex using a term with holes is already a powerful means of redex
selection. Similarly, any terms provided by the user in the more
complex forms of <code class="xref std std-token docutils literal notranslate"><span class="pre">c_patterns</span></code>
presented in the tables above can contain
holes.</p>
<p>For a quick glance at what can be expressed with the last
<a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a>
consider the goal <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">=</span> <span class="pre">b</span></code> and the tactic</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>]</span><span class="coqdoc-var">rule</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 23-27:
&gt; rewrite [in X in _ = X]rule.
&gt;                        ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rewrite</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrrwargs) (ssrclauses)&quot; failed.
       The reference rule was not found in the current environment.</span></dd>
</dl>
</div>
<p>It rewrites all occurrences of the left hand side of <code class="docutils literal notranslate"><span class="pre">rule</span></code>
inside <code class="docutils literal notranslate"><span class="pre">b</span></code>  only (<code class="docutils literal notranslate"><span class="pre">a</span></code>, and the hidden type of the equality, are ignored). Note that the
variant <code class="docutils literal notranslate"><span class="pre">rewrite</span> <span class="pre">[X</span> <span class="pre">in</span> <span class="pre">_</span> <span class="pre">=</span> <span class="pre">X]rule</span></code> would have rewritten <code class="docutils literal notranslate"><span class="pre">b</span></code>
exactly (i.e., it would only work if <code class="docutils literal notranslate"><span class="pre">b</span></code> and the left hand side
of rule can be unified).</p>
</div>
<div class="section" id="matching-contextual-patterns">
<h3>Matching contextual patterns<a class="headerlink" href="#matching-contextual-patterns" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a> and <a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a> involving terms
with holes are matched
against the goal in order to find a closed instantiation. This
matching proceeds as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a></th>
<th class="head">instantiation order and place for <code class="docutils literal notranslate"><span class="pre">term_i</span></code> and redex</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">term</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is unified with
the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is unified with the
subterm of the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code> identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code></td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term2</span></code> is matched against the goal, <code class="docutils literal notranslate"><span class="pre">term1</span></code>
is matched against the subterm of the instantiation of
<code class="docutils literal notranslate"><span class="pre">term1</span></code> identified by <code class="docutils literal notranslate"><span class="pre">ident</span></code>, redex is unified with
the instantiation of <code class="docutils literal notranslate"><span class="pre">term1</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">as</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term2</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term2[term1/ident]</span></code> is matched against
the goal, redex is unified with the instantiation of <code class="docutils literal notranslate"><span class="pre">term1</span></code></td>
</tr>
</tbody>
</table>
<p>In the following patterns, the redex is intended to be inferred from
the rewrite rule.</p>
<table border="1" class="docutils">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><a class="reference internal" href="#grammar-token-r_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">r_pattern</span></code></a></th>
<th class="head">instantiation order and place for <code class="docutils literal notranslate"><span class="pre">term_i</span></code> and redex</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, the redex is matched against
the subterm of the instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code> identified by
<code class="docutils literal notranslate"><span class="pre">ident</span></code></td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">in</span> <span class="pre">term</span></code></td>
<td><code class="docutils literal notranslate"><span class="pre">term</span></code> is matched against the goal, redex is matched against the
instantiation of <code class="docutils literal notranslate"><span class="pre">term</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="examples">
<h3>Examples<a class="headerlink" href="#examples" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="contextual-pattern-in-set-and-the-tactical">
<h4>Contextual pattern in set and the : tactical<a class="headerlink" href="#contextual-pattern-in-set-and-the-tactical" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>As already mentioned in section <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a> the <code class="docutils literal notranslate"><span class="pre">set</span></code>
tactic takes as an
argument a term in open syntax. This term is interpreted as the
simplest form of <a class="reference internal" href="#grammar-token-c_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">c_pattern</span></code></a>. To avoid confusion in the grammar, open
syntax is supported only for the simplest form of patterns, while
parentheses are required around more complex patterns.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">b</span><span> + 1 = </span><span class="coqdoc-var">b</span><span> + (</span><span class="coqdoc-var">a</span><span> + 1).</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 1)</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := (</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> {}/</span><span class="coqdoc-var">t</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 1)</span></dd>
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := (</span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  t := </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 1</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">t</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Since the user may define an infix notation for <code class="docutils literal notranslate"><span class="pre">in</span></code> the result of the former
tactic may be ambiguous. The disambiguation rule implemented is to prefer
patterns over simple terms, but to interpret a pattern with double
parentheses as a simple term. For example, the following tactic would
capture any occurrence of the term <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">in</span> <span class="pre">A</span></code>.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">t</span><span> := ((</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">A</span><span>)).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 10-18:
&gt; set t := ((a in A)).
&gt;           ^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Unknown interpretation for notation &quot;( _ in _ )&quot;.</span></dd>
</dl>
</div>
<p>Contextual patterns can also be used as arguments of the <code class="docutils literal notranslate"><span class="pre">:</span></code> tactical.
For example:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>: </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">refl_equal</span><span> </span><span class="coqdoc-var">n</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 33-34:
&gt; elim: n (n in _ = n) (refl_equal n).
&gt;                                  ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">elim</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrarg) (ssrclauses)&quot; failed.
       The reference n was not found in the current environment.</span></dd>
</dl>
</div>
</div>
<div class="section" id="contextual-patterns-in-rewrite">
<h4>Contextual patterns in rewrite<a class="headerlink" href="#contextual-patterns-in-rewrite" title="このヘッドラインへのパーマリンク">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Notation</span><span> &quot;n .+1&quot; := (</span><span class="coqdoc-var">Datatypes.S</span><span> </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-tactic">at</span><span> </span><span class="coqdoc-keyword">level</span><span> 2, </span><span class="coqdoc-tactic">left</span><span> </span><span class="coqdoc-keyword">associativity</span><span>,</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">format</span><span> &quot;n .+1&quot;) : </span><span class="coqdoc-var">nat_scope</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addSn</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span>.+1 + </span><span class="coqdoc-var">n</span><span> = (</span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span>).+1.</span></dt>
<dd><span class="first last">addSn is declared</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addn0</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span>, </span><span class="coqdoc-var">m</span><span> + 0 = </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd><span class="first last">addn0 is declared</span></dd>
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">addnC</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span>, </span><span class="coqdoc-var">m</span><span> + </span><span class="coqdoc-var">n</span><span> = </span><span class="coqdoc-var">n</span><span> + </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd><span class="first last">addnC is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> </span><span class="coqdoc-var">f</span><span> : (</span><span class="coqdoc-var">x</span><span>.+1 + </span><span class="coqdoc-var">y</span><span>) + </span><span class="coqdoc-var">f</span><span> (</span><span class="coqdoc-var">x</span><span>.+1 + </span><span class="coqdoc-var">y</span><span>) (</span><span class="coqdoc-var">z</span><span> + (</span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span>).+1) = 0.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">addSn</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
<p>Note: the simplification rule <code class="docutils literal notranslate"><span class="pre">addSn</span></code> is applied only under the <code class="docutils literal notranslate"><span class="pre">f</span></code>
symbol.
Then we simplify also the first addition and expand 0 into 0+0.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">addSn</span><span> -[</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>]</span><span class="coqdoc-var">addn0</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
<p>Note that the right hand side of <code class="docutils literal notranslate"><span class="pre">addn0</span></code> is undetermined, but the
rewrite pattern specifies the redex explicitly. The right hand side
of <code class="docutils literal notranslate"><span class="pre">addn0</span></code> is unified with the term identified by <code class="docutils literal notranslate"><span class="pre">X</span></code>, here <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p>The following pattern does not specify a redex, since it identifies an
entire region, hence the rewrite rule has to be instantiated
explicitly. Thus the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> -{2}[</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>](</span><span class="coqdoc-var">addn0</span><span> 0).</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0)</span></dd>
</dl>
</div>
<p>The following tactic is quite tricky:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">_</span><span>.+1 </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">X</span><span>](</span><span class="coqdoc-var">addnC</span><span> </span><span class="coqdoc-var">x</span><span>.+1).</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0)</span></dd>
</dl>
</div>
<p>The explicit redex <code class="docutils literal notranslate"><span class="pre">_.+1</span></code> is important since its head constant <code class="docutils literal notranslate"><span class="pre">S</span></code>
differs from the head constant inferred from
<code class="docutils literal notranslate"><span class="pre">(addnC</span> <span class="pre">x.+1)</span></code> (that is <code class="docutils literal notranslate"><span class="pre">+</span></code>).
Moreover, the pattern <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">_</span> <span class="pre">X</span></code> is important to rule out
the first occurrence of <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y).+1</span></code>.
Last, only the subterms of <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">_</span> <span class="pre">X</span></code>
identified by <code class="docutils literal notranslate"><span class="pre">X</span></code> are rewritten, thus the first argument of
<code class="docutils literal notranslate"><span class="pre">f</span></code> is skipped too.
Also note the pattern <code class="docutils literal notranslate"><span class="pre">_.+1</span></code> is interpreted in the context
identified by <code class="docutils literal notranslate"><span class="pre">X</span></code>, thus it gets instantiated to
<code class="docutils literal notranslate"><span class="pre">(y</span> <span class="pre">+</span> <span class="pre">x).+1</span></code> and not <code class="docutils literal notranslate"><span class="pre">(x</span> <span class="pre">+</span> <span class="pre">y).+1</span></code>.</p>
<p>The last rewrite pattern allows to specify exactly the shape of the
term identified by X, that is thus unified with the left hand side of
the rewrite rule.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-var">x</span><span>.+1 + </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-keyword">as</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">f</span><span> </span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-var">_</span><span>]</span><span class="coqdoc-var">addnC</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0)</span></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="patterns-for-recurrent-contexts">
<h3>Patterns for recurrent contexts<a class="headerlink" href="#patterns-for-recurrent-contexts" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The user can define shortcuts for recurrent contexts corresponding to
the <code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code> part. The notation scope identified with
<code class="docutils literal notranslate"><span class="pre">%pattern</span></code>
provides a special notation <code class="docutils literal notranslate"><span class="pre">(X</span> <span class="pre">in</span> <span class="pre">t)</span></code> the user must adopt
in order to define
context shortcuts.</p>
<p>The following example is taken from <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> where the
<code class="docutils literal notranslate"><span class="pre">LHS</span></code> and <code class="docutils literal notranslate"><span class="pre">RHS</span></code> shortcuts are defined.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Notation</span><span> </span><span class="coqdoc-var">RHS</span><span> := (</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">_</span><span> = </span><span class="coqdoc-var">X</span><span>)%</span><span class="coqdoc-tactic">pattern</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-keyword">Notation</span><span> </span><span class="coqdoc-var">LHS</span><span> := (</span><span class="coqdoc-var">X</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">X</span><span> = </span><span class="coqdoc-var">_</span><span>)%</span><span class="coqdoc-tactic">pattern</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p>Shortcuts defined this way can be freely used in place of the trailing
<code class="docutils literal notranslate"><span class="pre">ident</span> <span class="pre">in</span> <span class="pre">term</span></code> part of any contextual pattern. Some examples follow:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">set</span><span> </span><span class="coqdoc-var">rhs</span><span> := </span><span class="coqdoc-var">RHS</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  f : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  rhs := 0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0) : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rhs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">rewrite</span><span> [</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">RHS</span><span>]</span><span class="coqdoc-var">rule</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 16-20:
&gt; rewrite [in RHS]rule.
&gt;                 ^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rewrite</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrrwargs) (ssrclauses)&quot; failed.
       The reference rule was not found in the current environment.</span></dd>
<dt><span class="coqdoc-tactic">case</span><span>: (</span><span class="coqdoc-var">a</span><span> + </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">RHS</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 7-8:
&gt; case: (a + _ in RHS).
&gt;        ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">case</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrcasearg) (ssrclauses)&quot; failed.
       The variable a was not found in the current environment.</span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="views-and-reflection">
<span id="views-and-reflection-ssr"></span><h2>Views and reflection<a class="headerlink" href="#views-and-reflection" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>The bookkeeping facilities presented in section <a class="reference internal" href="#basic-tactics-ssr"><span class="std std-ref">Basic tactics</span></a> are
crafted to ease simultaneous introductions and generalizations of facts and
operations of casing, naming etc. It also a common practice to make a stack
operation immediately followed by an <em>interpretation</em> of the fact
being pushed, that is, to apply a lemma to this fact before passing it
to a tactic for decomposition, application and so on.</p>
<p><span class="smallcaps">SSReflect</span> provides a convenient, unified syntax to combine these
interpretation operations with the proof stack operations. This <em>view
mechanism</em> relies on the combination of the <code class="docutils literal notranslate"><span class="pre">/</span></code> view switch with
bookkeeping tactics and tacticals.</p>
<div class="section" id="interpreting-eliminations">
<h3>Interpreting eliminations<a class="headerlink" href="#interpreting-eliminations" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The view syntax combined with the <code class="docutils literal notranslate"><span class="pre">elim</span></code> tactic specifies an elimination
scheme to be used instead of the default, generated, one. Hence the
<span class="smallcaps">SSReflect</span> tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">V</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-6:
&gt; elim/V.
&gt; ^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">elim</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrarg) (ssrclauses)&quot; failed.
No assumption in ((</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">f</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">.+1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">rhs</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>is a synonym for:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">top</span><span>; </span><span class="coqdoc-tactic">elim</span><span> </span><span class="coqdoc-var">top</span><span> </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">V</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">top</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-9:
&gt; intro top; elim top using V; clear top.
&gt; ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">intro</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ident)&quot; failed.
No product even after head-reduction.</span></dd>
</dl>
</div>
<p>where top is a fresh name and V any second-order lemma.</p>
<p>Since an elimination view supports the two bookkeeping tacticals of
discharge and introduction (see section <a class="reference internal" href="#basic-tactics-ssr"><span class="std std-ref">Basic tactics</span></a>),
the <span class="smallcaps">SSReflect</span> tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">V</span><span>: </span><span class="coqdoc-var">x</span><span> =&gt; </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 5-6:
&gt; elim/V: x =&gt; y.
&gt;      ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">elim</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrarg) (ssrclauses)&quot; failed.
       The reference V was not found in the current environment.</span></dd>
</dl>
</div>
<p>is a synonym for:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-keyword">using</span><span> </span><span class="coqdoc-var">V</span><span>; </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">x</span><span>; </span><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">y</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 13-14:
&gt; elim x using V; clear x; intro y.
&gt;              ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference V was not found in the current environment.</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">x</span></code> is a variable in the context, <code class="docutils literal notranslate"><span class="pre">y</span></code> a fresh name and <code class="docutils literal notranslate"><span class="pre">V</span></code>
any second order lemma; <span class="smallcaps">SSReflect</span> relaxes the syntactic restrictions of the <span class="smallcaps">Coq</span>
<code class="docutils literal notranslate"><span class="pre">elim</span></code>. The first pattern following <code class="docutils literal notranslate"><span class="pre">:</span></code> can be a <code class="docutils literal notranslate"><span class="pre">_</span></code> wildcard if the
conclusion of the view <code class="docutils literal notranslate"><span class="pre">V</span></code> specifies a pattern for its last argument
(e.g., if <code class="docutils literal notranslate"><span class="pre">V</span></code> is a functional induction lemma generated by the
<code class="docutils literal notranslate"><span class="pre">Function</span></code> command).</p>
<p>The elimination view mechanism is compatible with the equation name
generation (see section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<blockquote>
<div>The following script illustrates a toy example of this feature. Let us
define a function adding an element at the end of a list:</div></blockquote>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">List</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">d</span><span> : </span><span class="coqdoc-keyword">Type</span><span>.</span></dt>
<dd><span class="first last">d is declared</span></dd>
<dt><span class="coqdoc-keyword">Fixpoint</span><span> </span><span class="coqdoc-var">add_last</span><span> (</span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>) (</span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">d</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">s</span><span>} : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">cons</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">s'</span><span> </span><span class="coqdoc-var">z</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">z</span><span> :: </span><span class="coqdoc-var">nil</span><span>.</span></dt>
<dd><span class="first last">add_last is defined
add_last is recursively defined (decreasing on 1st argument)</span></dd>
</dl>
</div>
<p>One can define an alternative, reversed, induction principle on
inductively defined lists, by proving the following lemma:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">last_ind_list</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>,</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">nil</span><span> -&gt; (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">d</span><span>), </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">s</span><span> -&gt; </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">add_last</span><span> </span><span class="coqdoc-var">s</span><span> </span><span class="coqdoc-var">x</span><span>)) -&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">s</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">s</span><span>.</span></dt>
<dd><span class="first last">last_ind_list is declared</span></dd>
</dl>
</div>
<p>Then the combination of elimination views with equation names result
in a concise syntax for reasoning inductively using the user-defined
elimination scheme.</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">d</span><span>) (</span><span class="coqdoc-var">l</span><span> : </span><span class="coqdoc-var">list</span><span> </span><span class="coqdoc-var">d</span><span>): </span><span class="coqdoc-var">l</span><span> = </span><span class="coqdoc-var">l</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  d : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">last_ind_list</span><span> </span><span class="coqdoc-var">E</span><span> : </span><span class="coqdoc-var">l</span><span>=&gt; [| </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-var">v</span><span>]; </span><span class="coqdoc-var">last</span><span> </span><span class="coqdoc-tactic">first</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  d : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Type</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  u : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  v : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  l : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">list</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">d</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  E : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">l</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">v</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">v</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">add_last</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">u</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">v</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nil</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>User-provided eliminators (potentially generated with <span class="smallcaps">Coq</span>’s <code class="docutils literal notranslate"><span class="pre">Function</span></code>
command) can be combined with the type family switches described
in section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>.
Consider an eliminator <code class="docutils literal notranslate"><span class="pre">foo_ind</span></code> of type:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">foo_ind</span><span> : </span><span class="coqdoc-keyword">forall</span><span> …, </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">T</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">p1</span><span> … </span><span class="coqdoc-var">pm</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 8-9:
&gt; foo_ind : forall …, forall x : T, P p1 … pm.
&gt;         ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [tactic:ltac_use_default] expected after [tactic:tactic] (in [vernac:tactic_command]).</span></dd>
</dl>
</div>
<p>and consider the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">foo_ind</span><span>: </span><span class="coqdoc-var">e1</span><span> … / </span><span class="coqdoc-var">en</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 17-20:
&gt; elim/foo_ind: e1 … / en.
&gt;                  ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax Error: Lexer: Undefined token</span></dd>
</dl>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">elim/</span></code> tactic distinguishes two cases:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">truncated eliminator:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body">when <code class="docutils literal notranslate"><span class="pre">x</span></code> does not occur in <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">p1</span> <span class="pre">…</span> <span class="pre">pm</span></code> and the
type of <code class="docutils literal notranslate"><span class="pre">en</span></code> unifies with <code class="docutils literal notranslate"><span class="pre">T</span></code> and <code class="docutils literal notranslate"><span class="pre">en</span></code> is not <code class="docutils literal notranslate"><span class="pre">_</span></code>.
In that case, <code class="docutils literal notranslate"><span class="pre">en</span></code> is
passed to the eliminator as the last argument (<code class="docutils literal notranslate"><span class="pre">x</span></code> in <code class="docutils literal notranslate"><span class="pre">foo_ind</span></code>) and
<code class="docutils literal notranslate"><span class="pre">en−1</span> <span class="pre">…</span> <span class="pre">e1</span></code> are used as patterns to select in the goal the occurrences that
will be bound by the predicate <code class="docutils literal notranslate"><span class="pre">P</span></code>, thus it must be possible to unify
the sub-term of the goal matched by <code class="docutils literal notranslate"><span class="pre">en−1</span></code> with <code class="docutils literal notranslate"><span class="pre">pm</span></code> , the one matched
by <code class="docutils literal notranslate"><span class="pre">en−2</span></code> with <code class="docutils literal notranslate"><span class="pre">pm−1</span></code> and so on.</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">regular eliminator:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body">in all the other cases. Here it must be possible
to unify the term matched by <code class="docutils literal notranslate"><span class="pre">en</span></code> with <code class="docutils literal notranslate"><span class="pre">pm</span></code> , the one matched by
<code class="docutils literal notranslate"><span class="pre">en−1</span></code>
with <code class="docutils literal notranslate"><span class="pre">pm−1</span></code> and so on. Note that standard eliminators have the shape
<code class="docutils literal notranslate"><span class="pre">…forall</span> <span class="pre">x,</span> <span class="pre">P</span> <span class="pre">…</span> <span class="pre">x</span></code>, thus <code class="docutils literal notranslate"><span class="pre">en</span></code> is the pattern identifying the
eliminated term, as expected.</td>
</tr>
</tbody>
</table>
<p>As explained in section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>, the initial prefix of
<code class="docutils literal notranslate"><span class="pre">ei</span></code> can be omitted.</p>
<p>Here is an example of a regular, but nontrivial, eliminator.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Here is a toy example illustrating this feature.</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">[Loading ML file extraction_plugin.cmxs ... done]
[Loading ML file recdef_plugin.cmxs ... done]</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd><span class="first last">plus is defined
plus is recursively defined (decreasing on 2nd argument)
plus_equation is defined
plus_ind is defined
plus_rec is defined
plus_rect is defined
R_plus_correct is defined
R_plus_complete is defined</span></dd>
<dt><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">plus_ind</span><span>.</span></dt>
<dd><span class="first">plus_ind :
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n _x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           | 0 =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)

Arguments m, P are implicit
Argument scopes are [nat_scope function_scope function_scope function_scope
  nat_scope]
plus_ind is transparent
Expands to: Constant Top.Test.plus_ind</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>The following tactics are all valid and perform the same elimination
on this goal.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">z</span><span> / (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">2 subgoals
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n _x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 | 0 =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: {</span><span class="coqdoc-var">z</span><span>}(</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 16-17:
&gt; elim/plus_ind: {z}(plus _ z).
&gt;                 ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No such hypothesis: z</span></dd>
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: {</span><span class="coqdoc-var">z</span><span>}</span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 16-17:
&gt; elim/plus_ind: {z}_.
&gt;                 ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No such hypothesis: z</span></dd>
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">z</span><span> / </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 15-16:
&gt; elim/plus_ind: z / _.
&gt;                ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">elim</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrarg) (ssrclauses)&quot; failed.
       The reference z was not found in the current environment.</span></dd>
</dl>
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">plus is defined
plus is recursively defined (decreasing on 2nd argument)
plus_equation is defined
plus_ind is defined
plus_rec is defined
plus_rect is defined
R_plus_correct is defined
R_plus_complete is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">plus_ind</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">plus_ind :
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n _x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           | 0 =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)

Arguments m, P are implicit
Argument scopes are [nat_scope function_scope function_scope function_scope
  nat_scope]
plus_ind is transparent
Expands to: Constant Top.Test.plus_ind</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">z</span><span> / </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd><span class="first">2 subgoals
  
  x, y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">))

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n _x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 | 0 =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
 </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>The two latter examples feature a wildcard pattern: in this case,
the resulting pattern is inferred from the type of the eliminator.
In both these examples, it is <code class="docutils literal notranslate"><span class="pre">(plus</span> <span class="pre">_</span> <span class="pre">_)</span></code>, which matches the subterm
<code class="docutils literal notranslate"><span class="pre">plus</span> <span class="pre">(plus</span> <span class="pre">x</span> <span class="pre">y)</span> <span class="pre">z</span></code> thus instantiating the last <code class="docutils literal notranslate"><span class="pre">_</span></code> with <code class="docutils literal notranslate"><span class="pre">z</span></code>.
Note that the tactic:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Function</span><span> </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">n</span><span> : </span><span class="coqdoc-var">nat</span><span>) {</span><span class="coqdoc-keyword">struct</span><span> </span><span class="coqdoc-var">n</span><span>} : </span><span class="coqdoc-var">nat</span><span> :=</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">n</span><span> </span><span class="coqdoc-keyword">is</span><span> </span><span class="coqdoc-var">S</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">S</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">m</span><span> </span><span class="coqdoc-var">p</span><span>) </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">m</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">plus is defined
plus is recursively defined (decreasing on 2nd argument)
plus_equation is defined
plus_ind is defined
plus_rec is defined
plus_rect is defined
R_plus_correct is defined
R_plus_complete is defined</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">About</span><span> </span><span class="coqdoc-var">plus_ind</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">plus_ind :
</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (m : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (P : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">p</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)))</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
(</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n _x : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">,
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">match</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">with</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           | 0 =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           | </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">S</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> _ =&gt; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">False</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
           </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">end</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">_x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> n : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">m</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">n</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)

Arguments m, P are implicit
Argument scopes are [nat_scope function_scope function_scope function_scope
  nat_scope]
plus_ind is transparent
Expands to: Constant Top.Test.plus_ind</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span> : </span><span class="coqdoc-var">plus</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>) </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">x</span><span> (</span><span class="coqdoc-var">plus</span><span> </span><span class="coqdoc-var">y</span><span> </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  x, y, z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">plus</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">plus_ind</span><span>: </span><span class="coqdoc-var">y</span><span> / </span><span class="coqdoc-var">_</span><span>.</span></dt>
<dd><span class="first">Toplevel input, characters 0-20:
&gt; elim/plus_ind: y / _.
&gt; ^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">elim</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrarg) (ssrclauses)&quot; failed.
The given pattern matches the term </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> while the inferred pattern </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> doesn't</span></dd>
</dl>
</div>
<p class="last">triggers an error: in the conclusion
of the <code class="docutils literal notranslate"><span class="pre">plus_ind</span></code> eliminator, the first argument of the predicate
<code class="docutils literal notranslate"><span class="pre">P</span></code> should be the same as the second argument of <code class="docutils literal notranslate"><span class="pre">plus</span></code>, in the
second argument of <code class="docutils literal notranslate"><span class="pre">P</span></code>, but <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code> do no unify.</p>
</div>
<p>Here is an example of a truncated eliminator:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<p>Consider the goal:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">FunInd</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">p</span><span> </span><span class="coqdoc-var">n</span><span> (</span><span class="coqdoc-var">n_gt0</span><span> : 0 &lt; </span><span class="coqdoc-var">n</span><span>) (</span><span class="coqdoc-var">pr_p</span><span> : </span><span class="coqdoc-var">prime</span><span> </span><span class="coqdoc-var">p</span><span>) :</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">p</span><span> %| \</span><span class="coqdoc-var">prod_</span><span>(</span><span class="coqdoc-var">i</span><span> &lt;- </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> | </span><span class="coqdoc-var">i</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span>) </span><span class="coqdoc-var">i</span><span>.1 ^ </span><span class="coqdoc-var">i</span><span>.2 -&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 54-55:
&gt; Lemma test p n (n_gt0 : 0 &lt; n) (pr_p : prime p) :   p %| \prod_(i &lt;- prime_decomp n | i \in prime_decomp n) i.1 ^ i.2 -&gt;     exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1.
&gt;                                                       ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax error: '.' expected after [vernac:gallina] (in [vernac_aux]).</span></dd>
<dt><span class="coqdoc-keyword">Proof</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt><span class="coqdoc-tactic">elim</span><span>/</span><span class="coqdoc-var">big_prop</span><span>: </span><span class="coqdoc-var">_</span><span> =&gt; [| </span><span class="coqdoc-var">u</span><span> </span><span class="coqdoc-var">v</span><span> </span><span class="coqdoc-var">IHu</span><span> </span><span class="coqdoc-var">IHv</span><span> | [</span><span class="coqdoc-var">q</span><span> </span><span class="coqdoc-var">e</span><span>] /=].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-47:
&gt; elim/big_prop: _ =&gt; [| u v IHu IHv | [q e] /=].
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> No focused proof (No proof-editing in progress).</span></dd>
</dl>
</div>
<p>where the type of the <code class="docutils literal notranslate"><span class="pre">big_prop</span></code> eliminator is</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-var">big_prop</span><span>: </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">Pb</span><span> : </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span>)</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-var">idx</span><span> : </span><span class="coqdoc-var">R</span><span>) (</span><span class="coqdoc-var">op1</span><span> : </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">R</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>), </span><span class="coqdoc-var">Pb</span><span> </span><span class="coqdoc-var">idx</span><span> -&gt;</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span> : </span><span class="coqdoc-var">R</span><span>, </span><span class="coqdoc-var">Pb</span><span> </span><span class="coqdoc-var">x</span><span> -&gt; </span><span class="coqdoc-var">Pb</span><span> </span><span class="coqdoc-var">y</span><span> -&gt; </span><span class="coqdoc-var">Pb</span><span> (</span><span class="coqdoc-var">op1</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>)) -&gt;</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">I</span><span> : </span><span class="coqdoc-keyword">Type</span><span>) (</span><span class="coqdoc-var">r</span><span> : </span><span class="coqdoc-var">seq</span><span> </span><span class="coqdoc-var">I</span><span>) (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-var">pred</span><span> </span><span class="coqdoc-var">I</span><span>) (</span><span class="coqdoc-var">F</span><span> : </span><span class="coqdoc-var">I</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>),</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">i</span><span> : </span><span class="coqdoc-var">I</span><span>, </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">i</span><span> -&gt; </span><span class="coqdoc-var">Pb</span><span> (</span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-var">i</span><span>)) -&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">Pb</span><span> (\</span><span class="coqdoc-var">big</span><span>[</span><span class="coqdoc-var">op1</span><span>/</span><span class="coqdoc-var">idx</span><span>]</span><span class="coqdoc-var">_</span><span>(</span><span class="coqdoc-var">i</span><span> &lt;- </span><span class="coqdoc-var">r</span><span> | </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">i</span><span>) </span><span class="coqdoc-var">F</span><span> </span><span class="coqdoc-var">i</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 8-9:
&gt; big_prop: forall (R : Type) (Pb : R -&gt; Type)   (idx : R) (op1 : R -&gt; R -&gt; R), Pb idx -&gt;   (forall x y : R, Pb x -&gt; Pb y -&gt; Pb (op1 x y)) -&gt;   forall (I : Type) (r : seq I) (P : pred I) (F : I -&gt; R),   (forall i : I, P i -&gt; Pb (F i)) -&gt;     Pb (\big[op1/idx]_(i &lt;- r | P i) F i).
&gt;         ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [tactic:ltac_use_default] expected after [tactic:tactic] (in [vernac:tactic_command]).</span></dd>
</dl>
</div>
<p>Since the pattern for the argument of Pb is not specified, the
inferred one is used instead: <code class="docutils literal notranslate"><span class="pre">big[_/_]_(i</span> <span class="pre">&lt;-</span> <span class="pre">_</span> <span class="pre">|</span> <span class="pre">_</span> <span class="pre">i)</span> <span class="pre">_</span> <span class="pre">i</span></code>,
and after the introductions, the following goals are generated:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">subgoal</span><span> 1 </span><span class="coqdoc-keyword">is</span><span>:</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">p</span><span> %| 1 -&gt; </span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1</span><span>
</span><span class="coqdoc-keyword">subgoal</span><span> 2 </span><span class="coqdoc-keyword">is</span><span>:</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">p</span><span> %| </span><span class="coqdoc-var">u</span><span> * </span><span class="coqdoc-var">v</span><span> -&gt; </span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1</span><span>
</span><span class="coqdoc-keyword">subgoal</span><span> 3 </span><span class="coqdoc-keyword">is</span><span>:</span><span>
&nbsp;&nbsp;(</span><span class="coqdoc-var">q</span><span>, </span><span class="coqdoc-var">e</span><span>) \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> -&gt; </span><span class="coqdoc-var">p</span><span> %| </span><span class="coqdoc-var">q</span><span> ^ </span><span class="coqdoc-var">e</span><span> -&gt;</span><span>
&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="coqdoc-var">exists2</span><span> </span><span class="coqdoc-var">x</span><span> : </span><span class="coqdoc-var">nat</span><span> * </span><span class="coqdoc-var">nat</span><span>, </span><span class="coqdoc-var">x</span><span> \</span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">prime_decomp</span><span> </span><span class="coqdoc-var">n</span><span> &amp; </span><span class="coqdoc-var">p</span><span> = </span><span class="coqdoc-var">x</span><span>.1.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 10-12:
&gt; subgoal 1 is:   p %| 1 -&gt; exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1 subgoal 2 is:   p %| u * v -&gt; exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1 subgoal 3 is:   (q, e) \in prime_decomp n -&gt; p %| q ^ e -&gt;     exists2 x : nat * nat, x \in prime_decomp n &amp; p = x.1.
&gt;           ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">
Syntax error: [tactic:ltac_use_default] expected after [tactic:tactic] (in [vernac:tactic_command]).</span></dd>
</dl>
</div>
<p class="last">Note that the pattern matching algorithm instantiated all the
variables occurring in the pattern.</p>
</div>
</div>
<div class="section" id="interpreting-assumptions">
<span id="interpreting-assumptions-ssr"></span><h3>Interpreting assumptions<a class="headerlink" href="#interpreting-assumptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Interpreting an assumption in the context of a proof consists in
applying to it a lemma before generalizing, and/or decomposing this
assumption. For instance, with the extensive use of boolean reflection
(see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>.4), it is quite frequent
to need to decompose the logical interpretation of (the boolean
expression of) a fact, rather than the fact itself. This can be
achieved by a combination of <code class="docutils literal notranslate"><span class="pre">move</span> <span class="pre">:</span> <span class="pre">_</span> <span class="pre">=&gt;</span> <span class="pre">_</span></code> switches, like in the
following example, where <code class="docutils literal notranslate"><span class="pre">||</span></code> is a notation for the boolean
disjunction.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">P is declared
Q is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">P2Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first last">P2Q is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">a</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P2Q : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">HPa</span><span>; </span><span class="coqdoc-tactic">move</span><span>: {</span><span class="coqdoc-var">HPa</span><span>}(</span><span class="coqdoc-var">P2Q</span><span> </span><span class="coqdoc-var">HPa</span><span>) =&gt; </span><span class="coqdoc-var">HQa</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P2Q : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  HQa : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>which transforms the hypothesis <code class="docutils literal notranslate"><span class="pre">HPa</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">a</span></code> which has been introduced
from the initial statement into <code class="docutils literal notranslate"><span class="pre">HQa</span> <span class="pre">:</span> <span class="pre">Q</span> <span class="pre">a</span></code>.
This operation is so common that the tactic shell has specific
syntax for it. The following scripts:</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> : </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">P is declared
Q is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">P2Q</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">P2Q is declared</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">a</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P2Q : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">HPa</span><span>; </span><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">P2Q</span><span>: </span><span class="coqdoc-var">HPa</span><span> =&gt; </span><span class="coqdoc-var">HQa</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P2Q : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  HQa : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>or more directly:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">P2Q</span><span>=&gt; </span><span class="coqdoc-var">HQa</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P2Q : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  HQa : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">are equivalent to the former one. The former script shows how to
interpret a fact (already in the context), thanks to the discharge
tactical (see section <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a>) and the latter, how to interpret the top
assumption of a goal. Note that the number of wildcards to be inserted
to find the correct application of the view lemma to the hypothesis
has been automatically inferred.</p>
</div>
<p>The view mechanism is compatible with the <code class="docutils literal notranslate"><span class="pre">case</span></code> tactic and with the
equation name generation mechanism (see section <a class="reference internal" href="#generation-of-equations-ssr"><span class="std std-ref">Generation of equations</span></a>):</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>: </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">P is declared
Q is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">Q2P</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">Q</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">a</span><span> \/ </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first last">Q2P is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">Q</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Q2P : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">case</span><span>/</span><span class="coqdoc-var">Q2P</span><span>=&gt; [</span><span class="coqdoc-var">HPa</span><span> | </span><span class="coqdoc-var">HPb</span><span>].</span></dt>
<dd><span class="first">2 subgoals
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Q2P : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> \/</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  HPa : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>This view tactic performs:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>=&gt; </span><span class="coqdoc-var">HQ</span><span>; </span><span class="coqdoc-tactic">case</span><span>: {</span><span class="coqdoc-var">HQ</span><span>}(</span><span class="coqdoc-var">Q2P</span><span> </span><span class="coqdoc-var">HQ</span><span>) =&gt; [</span><span class="coqdoc-var">HPa</span><span> | </span><span class="coqdoc-var">HPb</span><span>].</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-9:
&gt; move=&gt; HQ; case: {HQ}(Q2P HQ) =&gt; [HPa | HPb].
&gt; ^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">move</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (ssrmovearg) (ssrclauses)&quot; failed.
No assumption in </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>The term on the right of the <code class="docutils literal notranslate"><span class="pre">/</span></code> view switch is called a <em>view lemma</em>.
Any <span class="smallcaps">SSReflect</span> term coercing to a product type can be used as a view
lemma.</p>
<p>The examples we have given so far explicitly provide the direction of
the translation to be performed. In fact, view lemmas need not to be
oriented. The view mechanism is able to detect which application is
relevant for the current goal.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>: </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">P is declared
Q is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">PQequiv</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) &lt;-&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first last">PQequiv is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  PQequiv : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">PQequiv</span><span>=&gt; </span><span class="coqdoc-var">HQab</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  PQequiv : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  HQab : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>has the same behavior as the first example above.</p>
<p>The view mechanism can insert automatically a <em>view hint</em> to transform
the double implication into the expected simple implication. The last
script is in fact equivalent to:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) -&gt; </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  PQequiv : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>/(</span><span class="coqdoc-var">iffLR</span><span> (</span><span class="coqdoc-var">PQequiv</span><span> </span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">_</span><span>)).</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  PQequiv : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>where:</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">iffLR</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> : (</span><span class="coqdoc-var">P</span><span> &lt;-&gt; </span><span class="coqdoc-var">Q</span><span>) -&gt; </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">Q</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 0-38:
&gt; Lemma iffLR P Q : (P &lt;-&gt; Q) -&gt; P -&gt; Q.
&gt; ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> P is already used.</span></dd>
</dl>
</div>
</div>
<div class="section" id="specializing-assumptions">
<h4>Specializing assumptions<a class="headerlink" href="#specializing-assumptions" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The special case when the <em>head symbol</em> of the view lemma is a
wildcard is used to interpret an assumption by <em>specializing</em> it. The
view mechanism hence offers the possibility to apply a higher-order
assumption to some given arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">z</span><span> : (</span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">x</span><span> </span><span class="coqdoc-var">y</span><span>, </span><span class="coqdoc-var">x</span><span> + </span><span class="coqdoc-var">y</span><span> = </span><span class="coqdoc-var">z</span><span> -&gt; </span><span class="coqdoc-var">z</span><span> = </span><span class="coqdoc-var">x</span><span>) -&gt; </span><span class="coqdoc-var">z</span><span> = 0.</span></dt>
<dd><span class="first">1 subgoal
  
  z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> x y : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">y</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">x</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
<dt><span class="coqdoc-tactic">move</span><span>/(</span><span class="coqdoc-var">_</span><span> 0 </span><span class="coqdoc-var">z</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  z : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">nat</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (0</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> +</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> 0)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">z</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> 0</span></dd>
</dl>
</div>
</div>
</div>
</div>
<div class="section" id="interpreting-goals">
<h3>Interpreting goals<a class="headerlink" href="#interpreting-goals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In a similar way, it is also often convenient to
changing a goal by turning it into an equivalent proposition. The view
mechanism of <span class="smallcaps">SSReflect</span> has a special syntax <code class="docutils literal notranslate"><span class="pre">apply/</span></code> for combining  in a
single tactic simultaneous goal interpretation operations and
bookkeeping steps.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<blockquote>
<div>The following example use the <code class="docutils literal notranslate"><span class="pre">~~</span></code> prenex notation for boolean negation:</div></blockquote>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>: </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd><span class="first last">P is declared
Q is declared</span></dd>
<dt><span class="coqdoc-keyword">Hypothesis</span><span> </span><span class="coqdoc-var">PQequiv</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span>, </span><span class="coqdoc-var">P</span><span> (</span><span class="coqdoc-var">a</span><span> || </span><span class="coqdoc-var">b</span><span>) &lt;-&gt; </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first last">PQequiv is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">a</span><span> : </span><span class="coqdoc-var">P</span><span> ((~~ </span><span class="coqdoc-var">a</span><span>) || </span><span class="coqdoc-var">a</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  PQequiv : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">PQequiv</span><span>.</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  P, Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  PQequiv : </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> a b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  a : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p class="last">thus in this case, the tactic <code class="docutils literal notranslate"><span class="pre">apply/PQequiv</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">(iffRL</span> <span class="pre">(PQequiv</span> <span class="pre">_</span> <span class="pre">_))</span></code>, where <code class="docutils literal notranslate"><span class="pre">iffRL</span></code> is tha analogue of
<code class="docutils literal notranslate"><span class="pre">iffRL</span></code> for the converse implication.</p>
</div>
<p>Any <span class="smallcaps">SSReflect</span> term whose type coerces to a double implication can be
used as a view for goal interpretation.</p>
<p>Note that the goal interpretation view mechanism supports both <code class="docutils literal notranslate"><span class="pre">apply</span></code>
and <code class="docutils literal notranslate"><span class="pre">exact</span></code> tactics. As expected, a goal interpretation view command
exact/term should solve the current goal or it will fail.</p>
<div class="admonition warning">
<p class="first admonition-title">警告</p>
<p class="last">Goal interpretation view tactics are <em>not</em> compatible with
the bookkeeping tactical <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> since this would be redundant with the
<code class="docutils literal notranslate"><span class="pre">apply:</span> <span class="pre">term</span> <span class="pre">=&gt;</span> <span class="pre">_</span></code> construction.</p>
</div>
</div>
<div class="section" id="boolean-reflection">
<h3>Boolean reflection<a class="headerlink" href="#boolean-reflection" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>In the Calculus of Inductive Constructions, there is an obvious
distinction between logical propositions and boolean values. On the
one hand, logical propositions are objects of <em>sort</em> <code class="docutils literal notranslate"><span class="pre">Prop</span></code> which is
the carrier of intuitionistic reasoning. Logical connectives in
<code class="docutils literal notranslate"><span class="pre">Prop</span></code> are <em>types</em>, which give precise information on the structure
of their proofs; this information is automatically exploited by <span class="smallcaps">Coq</span>
tactics.  For example, <span class="smallcaps">Coq</span> knows that a proof of <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span></code> is
either a proof of <code class="docutils literal notranslate"><span class="pre">A</span></code> or a proof of <code class="docutils literal notranslate"><span class="pre">B</span></code>.  The tactics <code class="docutils literal notranslate"><span class="pre">left</span></code> and
<code class="docutils literal notranslate"><span class="pre">right</span></code> change the goal <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span></code> to <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, respectively;
dually, the tactic <code class="docutils literal notranslate"><span class="pre">case</span></code> reduces the goal <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">\/</span> <span class="pre">B</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code> to two
subgoals <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=&gt;</span> <span class="pre">G</span></code>.</p>
<p>On the other hand, bool is an inductive <em>datatype</em> with two
constructors true and false. Logical connectives on bool are
<em>computable functions</em>, defined by their truth tables, using case
analysis:</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">orb</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>) := </span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">true</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">b2</span><span>.</span></dt>
<dd><span class="first last">orb is defined</span></dd>
</dl>
</div>
</div>
<p>Properties of such connectives are also established using case
analysis</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">b</span><span> || ~~ </span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">true</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">case</span><span>: </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first last">No more subgoals.</span></dd>
</dl>
</div>
<p class="last">Once <code class="docutils literal notranslate"><span class="pre">b</span></code> is replaced by <code class="docutils literal notranslate"><span class="pre">true</span></code> in the first goal and by <code class="docutils literal notranslate"><span class="pre">false</span></code> in the
second one, the goals reduce by computations to the trivial <code class="docutils literal notranslate"><span class="pre">true</span> <span class="pre">=</span> <span class="pre">true</span></code>.</p>
</div>
<p>Thus, <code class="docutils literal notranslate"><span class="pre">Prop</span></code> and <code class="docutils literal notranslate"><span class="pre">bool</span></code> are truly complementary: the former supports
robust natural deduction, the latter allows brute-force
evaluation. <span class="smallcaps">SSReflect</span> supplies a generic mechanism to have the best of
the two worlds and move freely from a propositional version of a
decidable predicate to its boolean version.</p>
<p>First, booleans are injected into propositions using the coercion
mechanism:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Coercion</span><span> </span><span class="coqdoc-var">is_true</span><span> (</span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) := </span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">true</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">is_true is defined
Ambiguous paths: [</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">is_true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : bool &gt;-&gt; Sortclass
is_true is now a coercion</span></dd>
</dl>
</div>
<p>This allows any boolean formula <code class="docutils literal notranslate"><span class="pre">b</span></code> to be used in a context where <span class="smallcaps">Coq</span>
would expect a proposition, e.g., after <code class="docutils literal notranslate"><span class="pre">Lemma</span> <span class="pre">…</span> <span class="pre">:</span> <span class="pre">``.</span> <span class="pre">It</span> <span class="pre">is</span> <span class="pre">then</span>
<span class="pre">interpreted</span> <span class="pre">as</span> <span class="pre">``(is_true</span> <span class="pre">b)</span></code>, i.e., the proposition <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">=</span> <span class="pre">true</span></code>. Coercions
are elided by the pretty-printer, so they are essentially transparent
to the user.</p>
</div>
<div class="section" id="the-reflect-predicate">
<h3>The reflect predicate<a class="headerlink" href="#the-reflect-predicate" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>To get all the benefits of the boolean reflection, it is in fact
convenient to introduce the following inductive predicate <code class="docutils literal notranslate"><span class="pre">reflect</span></code> to
relate propositions and booleans:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">reflect</span><span> (</span><span class="coqdoc-var">P</span><span>: </span><span class="coqdoc-keyword">Prop</span><span>): </span><span class="coqdoc-var">bool</span><span> -&gt; </span><span class="coqdoc-keyword">Type</span><span> :=</span><span>
| </span><span class="coqdoc-var">Reflect_true</span><span> : </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">true</span><span>
| </span><span class="coqdoc-var">Reflect_false</span><span> : ~</span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">false</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">reflect is defined
reflect_rect is defined
reflect_ind is defined
reflect_rec is defined</span></dd>
</dl>
</div>
<p>The statement <code class="docutils literal notranslate"><span class="pre">(reflect</span> <span class="pre">P</span> <span class="pre">b)</span></code> asserts that <code class="docutils literal notranslate"><span class="pre">(is_true</span> <span class="pre">b)</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span></code> are
logically equivalent propositions.</p>
<p>For instance, the following lemma:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">andP</span><span>: </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span>, </span><span class="coqdoc-var">reflect</span><span> (</span><span class="coqdoc-var">b1</span><span> /\ </span><span class="coqdoc-var">b2</span><span>) (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">reflect is defined
reflect_rect is defined
reflect_ind is defined
reflect_rec is defined
Toplevel input, characters 46-48:
&gt; Lemma andP: forall b1 b2, reflect (b1 /\ b2) (b1 &amp;&amp; b2).
&gt;                                               ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
In environment
b1 : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
b2 : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
The term &quot;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; has type &quot;</span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">&quot; while it is expected to have type &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">&quot;.</span></dd>
</dl>
</div>
<p>relates the boolean conjunction to the logical one <code class="docutils literal notranslate"><span class="pre">/\</span></code>. Note that in
<code class="docutils literal notranslate"><span class="pre">andP</span></code>, <code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> are two boolean variables and the
proposition <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">/\</span> <span class="pre">b2</span></code> hides two coercions. The conjunction of
<code class="docutils literal notranslate"><span class="pre">b1</span></code> and <code class="docutils literal notranslate"><span class="pre">b2</span></code> can then be viewed as <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">/\</span> <span class="pre">b2</span></code> or as <code class="docutils literal notranslate"><span class="pre">b1</span> <span class="pre">&amp;&amp;</span> <span class="pre">b2</span></code>.</p>
<p>Expressing logical equivalences through this family of inductive types
makes possible to take benefit from <em>rewritable equations</em> associated
to the case analysis of <span class="smallcaps">Coq</span>’s inductive types.</p>
<p>Since the equivalence predicate is defined in <span class="smallcaps">Coq</span> as:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Definition</span><span> </span><span class="coqdoc-var">iff</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) := (</span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span>) /\ (</span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">A</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">iff is defined</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">/\</span></code> is a notation for <code class="docutils literal notranslate"><span class="pre">and</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Inductive</span><span> </span><span class="coqdoc-var">and</span><span> (</span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>:</span><span class="coqdoc-keyword">Prop</span><span>) : </span><span class="coqdoc-keyword">Prop</span><span> := </span><span class="coqdoc-var">conj</span><span> : </span><span class="coqdoc-var">A</span><span> -&gt; </span><span class="coqdoc-var">B</span><span> -&gt; </span><span class="coqdoc-var">and</span><span> </span><span class="coqdoc-var">A</span><span> </span><span class="coqdoc-var">B</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">and is defined
and_rect is defined
and_ind is defined
and_rec is defined</span></dd>
</dl>
</div>
<p>This make case analysis very different according to the way an
equivalence property has been defined.</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">andE</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>) : (</span><span class="coqdoc-var">b1</span><span> /\ </span><span class="coqdoc-var">b2</span><span>) &lt;-&gt; (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">and is defined
and_rect is defined
and_ind is defined
and_rec is defined
1 subgoal
  
  b1, b2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Let us compare the respective behaviors of <code class="docutils literal notranslate"><span class="pre">andE</span></code> and <code class="docutils literal notranslate"><span class="pre">andP</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Axiom</span><span> </span><span class="coqdoc-var">andE</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>), (</span><span class="coqdoc-var">b1</span><span> /\ </span><span class="coqdoc-var">b2</span><span>) &lt;-&gt; (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first last">andE is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> : </span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-keyword">if</span><span> (</span><span class="coqdoc-var">b1</span><span> &amp;&amp; </span><span class="coqdoc-var">b2</span><span>) </span><span class="coqdoc-keyword">then</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-keyword">else</span><span> ~~(</span><span class="coqdoc-var">b1</span><span>||</span><span class="coqdoc-var">b2</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  b1, b2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">if</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">then</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">else</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">case</span><span>: (&#64;</span><span class="coqdoc-var">andE</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  b1, b2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">if</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">then</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">else</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">case</span><span>: (&#64;</span><span class="coqdoc-var">andP</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span>).</span></dt>
<dd><span class="first">2 subgoals
  
  b1, b2 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
</div>
<p>Expressing reflection relation through the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate is hence
a very convenient way to deal with classical reasoning, by case
analysis. Using the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate allows moreover to program rich
specifications inside its two constructors, which will be
automatically taken into account during destruction. This
formalisation style gives far more efficient specifications than
quantified (double) implications.</p>
<p>A naming convention in <span class="smallcaps">SSReflect</span> is to postfix the name of view lemmas
with <code class="docutils literal notranslate"><span class="pre">P</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">orP</span></code> relates <code class="docutils literal notranslate"><span class="pre">||</span></code> and <code class="docutils literal notranslate"><span class="pre">\/</span></code>,
<code class="docutils literal notranslate"><span class="pre">negP</span></code> relates <code class="docutils literal notranslate"><span class="pre">~~</span></code> and <code class="docutils literal notranslate"><span class="pre">~</span></code>.</p>
<p>The view mechanism is compatible with reflect predicates.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">Ha</span><span> : </span><span class="coqdoc-var">a</span><span>) (</span><span class="coqdoc-var">Hb</span><span> : </span><span class="coqdoc-var">b</span><span>) : </span><span class="coqdoc-var">a</span><span> /\ </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Ha : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hb : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">andP</span><span>.</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Ha : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hb : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>Conversely</p>
<div class="coqtop literal-block last docutils container">
<span></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Abort</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) : </span><span class="coqdoc-var">a</span><span> /\ </span><span class="coqdoc-var">b</span><span> -&gt; </span><span class="coqdoc-var">a</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">andP</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>The same tactics can also be used to perform the converse operation,
changing a boolean conjunction into a logical one. The view mechanism
guesses the direction of the transformation to be used i.e., the
constructor of the reflect predicate which should be chosen.</p>
</div>
<div class="section" id="general-mechanism-for-interpreting-goals-and-assumptions">
<h3>General mechanism for interpreting goals and assumptions<a class="headerlink" href="#general-mechanism-for-interpreting-goals-and-assumptions" title="このヘッドラインへのパーマリンク">¶</a></h3>
<div class="section" id="id10">
<h4>Specializing assumptions<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The <span class="smallcaps">SSReflect</span> tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>/(</span><span class="coqdoc-var">_</span><span> </span><span class="coqdoc-var">term1</span><span> … </span><span class="coqdoc-var">termn</span><span>).</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 14-17:
&gt; move/(_ term1 … termn).
&gt;               ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax Error: Lexer: Undefined token</span></dd>
</dl>
</div>
<p>is equivalent to the tactic:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">intro</span><span> </span><span class="coqdoc-var">top</span><span>; </span><span class="coqdoc-tactic">generalize</span><span> (</span><span class="coqdoc-var">top</span><span> </span><span class="coqdoc-var">term1</span><span> … </span><span class="coqdoc-var">termn</span><span>); </span><span class="coqdoc-tactic">clear</span><span> </span><span class="coqdoc-var">top</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 33-36:
&gt; intro top; generalize (top term1 … termn); clear top.
&gt;                                  ^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> Syntax Error: Lexer: Undefined token</span></dd>
</dl>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">top</span></code> is a fresh name for introducing the top assumption of the
current goal.</p>
</div>
<div class="section" id="id11">
<h4>Interpreting assumptions<a class="headerlink" href="#id11" title="このヘッドラインへのパーマリンク">¶</a></h4>
<p>The general form of an assumption view tactic is:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>[move</span> <span>|</span> <span>case]</span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>The term , called the <em>view lemma</em> can be:</p>
<ul class="simple">
<li>a (term coercible to a) function;</li>
<li>a (possibly quantified) implication;</li>
<li>a (possibly quantified) double implication;</li>
<li>a (possibly quantified) instance of the reflect predicate (see
section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>).</li>
</ul>
<p>Let <code class="docutils literal notranslate"><span class="pre">top</span></code> be the top assumption in the goal.</p>
<p>There are three steps in the behavior of an assumption view tactic:</p>
<ul class="simple">
<li>It first introduces <code class="docutils literal notranslate"><span class="pre">top</span></code>.</li>
<li>If the type of <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><code class="xref std std-token docutils literal notranslate"><span class="pre">term</span></code></a> is neither a double implication nor an
instance of the reflect predicate, then the tactic automatically
generalises a term of the form: <code class="docutils literal notranslate"><span class="pre">term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span></code> where the
terms <code class="docutils literal notranslate"><span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span></code> instantiate the possible quantified variables of
<code class="docutils literal notranslate"><span class="pre">term</span></code> , in order for <code class="docutils literal notranslate"><span class="pre">(term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span> <span class="pre">top)</span></code> to be well typed.</li>
<li>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is an equivalence, or an instance of the
reflect predicate, it generalises a term of the form:
<code class="docutils literal notranslate"><span class="pre">(termvh</span> <span class="pre">(term</span> <span class="pre">term1</span> <span class="pre">…</span> <span class="pre">termn</span> <span class="pre">))</span></code> where the term <code class="docutils literal notranslate"><span class="pre">termvh</span></code>
inserted is called an
<em>assumption interpretation view hint</em>.</li>
<li>It finally clears top.</li>
</ul>
<p>For a <code class="docutils literal notranslate"><span class="pre">case/term</span></code> tactic, the generalisation step is replaced by a
case analysis step.</p>
<p><em>View hints</em> are declared by the user (see section:ref:<cite>views_and_reflection_ssr</cite>.8) and are
stored in the Hint View database. The proof engine automatically
detects from the shape of the top assumption <code class="docutils literal notranslate"><span class="pre">top</span></code> and of the view lemma
<code class="docutils literal notranslate"><span class="pre">term</span></code> provided to the tactic the appropriate view hint in the
database to be inserted.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">term</span></code> is a double implication, then the view hint will be one of
the defined view hints for implication. These hints are by default the
ones present in the file <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code>:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">iffLR</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>, (</span><span class="coqdoc-var">P</span><span> &lt;-&gt; </span><span class="coqdoc-var">Q</span><span>) -&gt; </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">Q</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> P Q : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &lt;-&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p>which transforms a double implication into the left-to-right one, or:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">iffRL</span><span> : </span><span class="coqdoc-keyword">forall</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span>, (</span><span class="coqdoc-var">P</span><span> &lt;-&gt; </span><span class="coqdoc-var">Q</span><span>) -&gt; </span><span class="coqdoc-var">Q</span><span> -&gt; </span><span class="coqdoc-var">P</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
</div>
<p>which produces the converse implication. In both cases, the two
first Prop arguments are implicit.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">term</span></code> is an instance of the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate, then <code class="docutils literal notranslate"><span class="pre">A</span></code> will be one
of the defined view hints for the <code class="docutils literal notranslate"><span class="pre">reflec``t</span> <span class="pre">predicate,</span> <span class="pre">which</span> <span class="pre">are</span> <span class="pre">by</span>
<span class="pre">default</span> <span class="pre">the</span> <span class="pre">ones</span> <span class="pre">present</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">file</span> <span class="pre">``ssrbool.v</span></code>. These hints are not
only used for choosing the appropriate direction of the translation,
but they also allow complex transformation, involving negations.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">introN</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>), </span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">b</span><span> -&gt; ~ </span><span class="coqdoc-var">P</span><span> -&gt; ~~</span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (P : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">reflect</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">Ha</span><span> : </span><span class="coqdoc-var">a</span><span>) (</span><span class="coqdoc-var">Hb</span><span> : </span><span class="coqdoc-var">b</span><span>) : ~~ (</span><span class="coqdoc-var">a</span><span> &amp;&amp; </span><span class="coqdoc-var">b</span><span>).</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Ha : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hb : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
<dt><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">andP</span><span>.</span></dt>
<dd><span class="first">1 focused subgoal
(shelved: 1)
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Ha : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Hb : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>In fact this last script does not
exactly use the hint <code class="docutils literal notranslate"><span class="pre">introN</span></code>, but the more general hint:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">introNTF</span><span> : </span><span class="coqdoc-keyword">forall</span><span> (</span><span class="coqdoc-var">P</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>) (</span><span class="coqdoc-var">b</span><span> </span><span class="coqdoc-var">c</span><span> : </span><span class="coqdoc-var">bool</span><span>),</span><span>
&nbsp;&nbsp;</span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">b</span><span> -&gt; (</span><span class="coqdoc-keyword">if</span><span> </span><span class="coqdoc-var">c</span><span> </span><span class="coqdoc-keyword">then</span><span> ~ </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-keyword">else</span><span> </span><span class="coqdoc-var">P</span><span>) -&gt; ~~ </span><span class="coqdoc-var">b</span><span> = </span><span class="coqdoc-var">c</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">1 subgoal
  
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (P : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (b c : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">),
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">reflect</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">if</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">then</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">else</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
<p class="last">The lemma ` <cite>introN`</cite> is an instantiation of introNF using c := true.</p>
</div>
<p>Note that views, being part of <a class="reference internal" href="#grammar-token-i_pattern"><code class="xref std std-token docutils literal notranslate"><span class="pre">i_pattern</span></code></a>, can be used to interpret
assertions too. For example the following script asserts <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span></code> but
actually uses its propositional interpretation.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">a</span><span> </span><span class="coqdoc-var">b</span><span> : </span><span class="coqdoc-var">bool</span><span>) (</span><span class="coqdoc-var">pab</span><span> : </span><span class="coqdoc-var">b</span><span> &amp;&amp; </span><span class="coqdoc-var">a</span><span>) : </span><span class="coqdoc-var">b</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  pab : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-var">have</span><span> /</span><span class="coqdoc-var">andP</span><span> [</span><span class="coqdoc-var">pa</span><span> -&gt;] : (</span><span class="coqdoc-var">a</span><span> &amp;&amp; </span><span class="coqdoc-var">b</span><span>) </span><span class="coqdoc-tactic">by</span><span> </span><span class="coqdoc-tactic">rewrite</span><span> </span><span class="coqdoc-var">andbC</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  a, b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  pab : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> &amp;&amp;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  pa : </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">a</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">true</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>Interpreting goals</p>
<p>A goal interpretation view tactic of the form:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply/</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>applied to a goal <code class="docutils literal notranslate"><span class="pre">top</span></code> is interpreted in the following way:</p>
<ul class="simple">
<li>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is not an instance of the <code class="docutils literal notranslate"><span class="pre">reflect</span></code> predicate,
nor an equivalence, then the term <code class="docutils literal notranslate"><span class="pre">term</span></code> is applied to the current
goal <code class="docutils literal notranslate"><span class="pre">top</span></code>, possibly inserting implicit arguments.</li>
<li>If the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> is an instance of the reflect predicate or an
equivalence, then a <em>goal interpretation view hint</em> can possibly be
inserted, which corresponds to the application of a term
<code class="docutils literal notranslate"><span class="pre">(termvh</span> <span class="pre">(term</span> <span class="pre">_</span> <span class="pre">…</span> <span class="pre">_))</span></code> to the current goal, possibly inserting implicit arguments.</li>
</ul>
<p>Like assumption interpretation view hints, goal interpretation ones
are user-defined lemmas stored (see section <a class="reference internal" href="#views-and-reflection-ssr"><span class="std std-ref">Views and reflection</span></a>) in the <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">View</span></code>
database bridging the possible gap between the type of <code class="docutils literal notranslate"><span class="pre">term</span></code> and the
type of the goal.</p>
</div>
</div>
<div class="section" id="interpreting-equivalences">
<h3>Interpreting equivalences<a class="headerlink" href="#interpreting-equivalences" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>Equivalent boolean propositions are simply <em>equal</em> boolean terms. A
special construction helps the user to prove boolean equalities by
considering them as logical double implications (between their coerced
versions), while performing at the same time logical operations on
both sides.</p>
<p>The syntax of double views is:</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>apply/</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a><span>/</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>The first term is the view lemma applied to the left hand side of the
equality, while the second term is the one applied to the right hand side.</p>
<p>In this context, the identity view can be used when no view has to be applied:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">idP</span><span> : </span><span class="coqdoc-var">reflect</span><span> </span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b1</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 23-25:
&gt; Lemma idP : reflect b1 b1.
&gt;                        ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> The reference b1 was not found in the current environment.</span></dd>
</dl>
</div>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> </span><span class="coqdoc-var">b3</span><span> : </span><span class="coqdoc-var">bool</span><span>) : ~~ (</span><span class="coqdoc-var">b1</span><span> || </span><span class="coqdoc-var">b2</span><span>) = </span><span class="coqdoc-var">b3</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  b1, b2, b3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">idP</span><span>/</span><span class="coqdoc-var">idP</span><span>.</span></dt>
<dd><span class="first">2 focused subgoals
(shelved: 2)
  
  b1, b2, b3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">)</span></dd>
</dl>
</div>
<p>The same goal can be decomposed in several ways, and the user may
choose the most convenient interpretation.</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">b1</span><span> </span><span class="coqdoc-var">b2</span><span> </span><span class="coqdoc-var">b3</span><span> : </span><span class="coqdoc-var">bool</span><span>) : ~~ (</span><span class="coqdoc-var">b1</span><span> || </span><span class="coqdoc-var">b2</span><span>) = </span><span class="coqdoc-var">b3</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  b1, b2, b3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">|| </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">norP</span><span>/</span><span class="coqdoc-var">idP</span><span>.</span></dt>
<dd><span class="first">2 focused subgoals
(shelved: 2)
  
  b1, b2, b3 : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

subgoal 2 is:
 </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b3</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b1</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> /\</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b2</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</div>
<div class="section" id="declaring-new-hint-views">
<span id="declaring-new-hints-ssr"></span><h3>Declaring new Hint Views<a class="headerlink" href="#declaring-new-hint-views" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The database of hints for the view mechanism is extensible via a
dedicated vernacular command. As library <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> already declares a
corpus of hints, this feature is probably useful only for users who
define their own logical connectives. Users can declare their own
hints following the syntax used in <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code>:</p>
<dl class="cmd">
<dt id="coq:cmd.hint-view-for-move">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>move</span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-view-for-move" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="cmd">
<dt id="coq:cmd.hint-view-for-apply">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>apply</span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-view-for-apply" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>The <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is the name of the lemma to be
declared as a hint. If <cite>move</cite> is used as
tactic, the hint is declared for assumption interpretation tactics,
<cite>apply</cite> declares hints for goal interpretations. Goal interpretation
view hints are declared for both simple views and left hand side
views. The optional natural number is the number of implicit
arguments to be considered for the declared hint view lemma.</p>
<p>The command:</p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>apply//</span><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>with a double slash <code class="docutils literal notranslate"><span class="pre">//</span></code>, declares hint views for right hand sides of
double views.</p>
<p>See the files <code class="docutils literal notranslate"><span class="pre">ssreflect.v</span></code> and <code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> for examples.</p>
</div>
<div class="section" id="multiple-views">
<h3>Multiple views<a class="headerlink" href="#multiple-views" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p>The hypotheses and the goal can be interpreted by applying multiple views
in sequence. Both move and apply can be followed by an arbitrary
number of <code class="docutils literal notranslate"><span class="pre">/term</span></code>. The main difference between the following two
tactics</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v1</span><span>/</span><span class="coqdoc-var">v2</span><span>/</span><span class="coqdoc-var">v3</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 6-8:
&gt; apply/v1/v2/v3.
&gt;       ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">apply</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrapplyarg)&quot; failed.
       The reference v1 was not found in the current environment.</span></dd>
<dt><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v1</span><span>; </span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v2</span><span>; </span><span class="coqdoc-tactic">apply</span><span>/</span><span class="coqdoc-var">v3</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 6-8:
&gt; apply/v1; apply/v2; apply/v3.
&gt;       ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">apply</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrapplyarg)&quot; failed.
       The reference v1 was not found in the current environment.</span></dd>
</dl>
</div>
<p>is that the former applies all the views to the principal goal.
Applying a view with hypotheses generates new goals, and the second
line would apply the view <code class="docutils literal notranslate"><span class="pre">v2</span></code> to all the goals generated by <code class="docutils literal notranslate"><span class="pre">apply/v1</span></code>.</p>
<p>Note that the NO-OP intro pattern <code class="docutils literal notranslate"><span class="pre">-</span></code> can be used to separate two views,
making the two following examples equivalent:</p>
<div class="coqtop literal-block docutils container">
<span></span><dl class="docutils">
<dt><span class="coqdoc-tactic">move</span><span>=&gt; /</span><span class="coqdoc-var">v1</span><span>; </span><span class="coqdoc-tactic">move</span><span>=&gt; /</span><span class="coqdoc-var">v2</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 8-10:
&gt; move=&gt; /v1; move=&gt; /v2.
&gt;         ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">move</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrmovearg) (ssrclauses)&quot; failed.
       The reference v1 was not found in the current environment.</span></dd>
<dt><span class="coqdoc-tactic">move</span><span>=&gt; /</span><span class="coqdoc-var">v1</span><span> - /</span><span class="coqdoc-var">v2</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Toplevel input, characters 8-10:
&gt; move=&gt; /v1 - /v2.
&gt;         ^^
</span><span class="ansi-fg-white ansi-bg-red ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Error:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Ltac call to &quot;</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">move</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"> (ssrmovearg) (ssrclauses)&quot; failed.
       The reference v1 was not found in the current environment.</span></dd>
</dl>
</div>
<p>The tactic <code class="docutils literal notranslate"><span class="pre">move</span></code> can be used together with the <code class="docutils literal notranslate"><span class="pre">in</span></code> tactical to
pass a given hypothesis to a lemma.</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Section</span><span> </span><span class="coqdoc-var">Test</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Variables</span><span> </span><span class="coqdoc-var">P</span><span> </span><span class="coqdoc-var">Q</span><span> </span><span class="coqdoc-var">R</span><span> : </span><span class="coqdoc-keyword">Prop</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first last">P is declared
Q is declared
R is declared</span></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">P2Q</span><span> : </span><span class="coqdoc-var">P</span><span> -&gt; </span><span class="coqdoc-var">Q</span><span>.</span></dt>
<dd><span class="first last">P2Q is declared</span></dd>
<dt><span class="coqdoc-keyword">Variable</span><span> </span><span class="coqdoc-var">Q2R</span><span> : </span><span class="coqdoc-var">Q</span><span> -&gt; </span><span class="coqdoc-var">R</span><span>.</span></dt>
<dd><span class="first last">Q2R is declared</span></dd>
<dt><span class="coqdoc-keyword">Lemma</span><span> </span><span class="coqdoc-var">test</span><span> (</span><span class="coqdoc-var">p</span><span> : </span><span class="coqdoc-var">P</span><span>) : </span><span class="coqdoc-var">True</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q, R : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P2Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Q2R : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
<dt><span class="coqdoc-tactic">move</span><span>/</span><span class="coqdoc-var">P2Q</span><span>/</span><span class="coqdoc-var">Q2R</span><span> </span><span class="coqdoc-tactic">in</span><span> </span><span class="coqdoc-var">p</span><span>.</span></dt>
<dd><span class="first">1 subgoal
  
  P, Q, R : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  P2Q : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  Q2R : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">Q</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  p : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">R</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
  ============================
  </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">True</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
<p>If the list of views is of length two, <code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Views</span></code> for interpreting
equivalences are indeed taken into account, otherwise only single
<code class="docutils literal notranslate"><span class="pre">Hint</span> <span class="pre">Views</span></code> are used.</p>
</div>
</div>
<div class="section" id="ssr-searching-tool">
<h2><span class="smallcaps">SSReflect</span> searching tool<a class="headerlink" href="#ssr-searching-tool" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><span class="smallcaps">SSReflect</span> proposes an extension of the Search command. Its syntax is:</p>
<dl class="cmd">
<dt id="coq:cmd.search-ssreflect">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Search</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="meta">(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-string"><span class="hole">string</span></a> <span class="meta">|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-pattern"><span class="hole">pattern</span></a> <span class="meta">)</span> <span class="repeat-wrapper"><span class="repeat"><span>%</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><span>in</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.search-ssreflect" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><code class="xref std std-token docutils literal notranslate"><span class="pre">qualid</span></code></a> is the name of an open module. This command returns
the list of lemmas:</p>
<ul class="simple">
<li>whose <em>conclusion</em> contains a subterm matching the optional first
pattern. A - reverses the test, producing the list of lemmas whose
conclusion does not contain any subterm matching the pattern;</li>
<li>whose name contains the given string. A <code class="docutils literal notranslate"><span class="pre">-</span></code> prefix reverses the test,
producing the list of lemmas whose name does not contain the string. A
string that contains symbols or is followed by a scope key, is
interpreted as the constant whose notation involves that string (e.g.,
<cite>+</cite> for <cite>addn</cite>), if this is unambiguous; otherwise the diagnostic
includes the output of the <code class="docutils literal notranslate"><span class="pre">Locate</span></code> vernacular command.</li>
<li>whose statement, including assumptions and types, contains a subterm
matching the next patterns. If a pattern is prefixed by <code class="docutils literal notranslate"><span class="pre">-</span></code>, the test is
reversed;</li>
<li>contained in the given list of modules, except the ones in the
modules prefixed by a <code class="docutils literal notranslate"><span class="pre">-</span></code>.</li>
</ul>
<p>Note that:</p>
<ul>
<li><p class="first">As for regular terms, patterns can feature scope indications. For
instance, the command: <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">_</span> <span class="pre">(_</span> <span class="pre">+</span> <span class="pre">_)%N.</span></code> lists all the lemmas whose
statement (conclusion or hypotheses) involves an application of the
binary operation denoted by the infix <code class="docutils literal notranslate"><span class="pre">+</span></code> symbol in the <code class="docutils literal notranslate"><span class="pre">N</span></code> scope (which is
<span class="smallcaps">SSReflect</span> scope for natural numbers).</p>
</li>
<li><p class="first">Patterns with holes should be surrounded by parentheses.</p>
</li>
<li><p class="first">Search always volunteers the expansion of the notation, avoiding the
need to execute Locate independently. Moreover, a string fragment
looks for any notation that contains fragment as a substring. If the
<code class="docutils literal notranslate"><span class="pre">ssrbool.v</span></code> library is imported, the command: <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">&quot;~~&quot;.</span></code> answers :</p>
<div class="admonition note">
<p class="first admonition-title">Example</p>
<div class="coqtop literal-block last docutils container">
<span class="coqtop-reset"></span><dl class="docutils">
<dt class="coqtop-hidden"><span class="coqdoc-var">From</span><span> </span><span class="coqdoc-var">Coq</span><span> </span><span class="coqdoc-keyword">Require</span><span> </span><span class="coqdoc-keyword">Import</span><span> </span><span class="coqdoc-var">ssreflect</span><span> </span><span class="coqdoc-var">ssrbool</span><span>.</span></dt>
<dd class="coqtop-hidden"><span class="first">Overwriting previous delimiting key bool in scope bool_scope
Ambiguous paths:
[</span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">pred_of_mem_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">; </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">sort_of_simpl_pred</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last">] : mem_pred &gt;-&gt; pred_sort</span></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Set Implicit Arguments</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Strict</span><span> </span><span class="coqdoc-keyword">Implicit</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
<dt class="coqtop-hidden"><span class="coqdoc-keyword">Unset</span><span> </span><span class="coqdoc-keyword">Printing</span><span> </span><span class="coqdoc-keyword">Implicit</span><span> </span><span class="coqdoc-var">Defensive</span><span>.</span></dt>
<dd class="coqtop-hidden"></dd>
</dl>
<span></span><dl class="docutils">
<dt><span class="coqdoc-keyword">Search</span><span> &quot;~~&quot;.</span></dt>
<dd><span class="first">&quot;~~&quot; is part of notation (~~ _)
In bool_scope, (~~ b) denotes </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">negb</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">
Toplevel input, characters 0-12:
&gt; Search &quot;~~&quot;.
&gt; ^^^^^^^^^^^^
</span><span class="ansi-fg-white ansi-bg-yellow ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Warning:</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> Listing only lemmas with conclusion matching (</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-blue ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">?b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)
negbT  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">false</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

contra  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> c b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

contraNN  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> c b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

contraL  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> c b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

contraTN  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> c b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

contraFN  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> c b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">, (</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">)</span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> =</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">false</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">c</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">

introN  </span><span class="ansi-fg-default ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">forall</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> (P : </span><span class="ansi-fg-yellow ansi-bg-default ansi-bold ansi-no-italic ansi-no-underline ansi-no-negative">Prop</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">) (b : </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">bool</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">), </span><span class="ansi-fg-light-green ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">reflect</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">P</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"></span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> -&gt;</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-white ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">~~</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative"> </span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative">b</span><span class="ansi-fg-default ansi-bg-default ansi-no-bold ansi-no-italic ansi-no-underline ansi-no-negative last"></span></dd>
</dl>
</div>
</div>
</li>
<li><p class="first">A diagnostic is issued if there are different matching notations; it
is an error if all matches are partial.</p>
</li>
<li><p class="first">Similarly, a diagnostic warns about multiple interpretations, and
signals an error if there is no default one.</p>
</li>
<li><p class="first">The command <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">in</span> <span class="pre">M.</span></code> is a way of obtaining the complete
signature of the module <code class="docutils literal notranslate"><span class="pre">M</span></code>.</p>
</li>
<li><p class="first">Strings and pattern indications can be interleaved, but the first
indication has a special status if it is a pattern, and only filters
the conclusion of lemmas:</p>
<blockquote>
<div><ul class="simple">
<li>The command : <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">(_</span> <span class="pre">=1</span> <span class="pre">_)</span> <span class="pre">&quot;bij&quot;.</span></code> lists all the lemmas whose
conclusion features a <code class="docutils literal notranslate"><span class="pre">=1</span></code> and whose name contains the string <code class="docutils literal notranslate"><span class="pre">bij</span></code>.</li>
<li>The command : <code class="docutils literal notranslate"><span class="pre">Search</span> <span class="pre">&quot;bij&quot;</span> <span class="pre">(_</span> <span class="pre">=1</span> <span class="pre">_).</span></code> lists all the lemmas whose
statement, including hypotheses, features a <code class="docutils literal notranslate"><span class="pre">=1</span></code> and whose name
contains the string <code class="docutils literal notranslate"><span class="pre">bij</span></code>.</li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<div class="section" id="synopsis-and-index">
<h2>Synopsis and Index<a class="headerlink" href="#synopsis-and-index" title="このヘッドラインへのパーマリンク">¶</a></h2>
<div class="section" id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><span class="smallcaps">SSReflect</span> tactics</p>
<dl class="prodn">
<dt id="grammar-token-d_tactic">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">d_tactic</span> <span class="pre">::=</span> </code><span class="notation"><span>elim</span> <span class="meta">|</span> <span>case</span> <span class="meta">|</span> <span>congr</span> <span class="meta">|</span> <span>apply</span> <span class="meta">|</span> <span>exact</span> <span class="meta">|</span> <span>move</span></span></code><a class="headerlink" href="#grammar-token-d_tactic" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>Notation scope</p>
<dl class="prodn">
<dt id="grammar-token-key">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">key</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#grammar-token-key" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>Module name</p>
<dl class="prodn">
<dt id="grammar-token-modname">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">modname</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-qualid"><span class="hole">qualid</span></a></span></code><a class="headerlink" href="#grammar-token-modname" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>Natural number</p>
<dl class="prodn">
<dt id="grammar-token-natural">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">natural</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a> <span class="meta">|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span></code><a class="headerlink" href="#grammar-token-natural" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>where <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><code class="xref std std-token docutils literal notranslate"><span class="pre">ident</span></code></a> is an Ltac variable denoting a standard <span class="smallcaps">Coq</span> numeral
(should not be the name of a tactic which can be followed by a
bracket <code class="docutils literal notranslate"><span class="pre">[</span></code>, like <code class="docutils literal notranslate"><span class="pre">do</span></code>, <code class="docutils literal notranslate"><span class="pre">have</span></code>,…)</p>
</div>
<div class="section" id="items-and-switches">
<h3>Items and switches<a class="headerlink" href="#items-and-switches" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="prodn">
<dt id="grammar-token-ssr_binder">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">ssr_binder</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="meta">|</span> <span>(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>)</span></span></code><a class="headerlink" href="#grammar-token-ssr_binder" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>binder see <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a>.</p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">clear_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> }</span></span></code></dt>
<dd></dd></dl>

<p>clear switch see <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a></p>
<dl class="prodn">
<dt id="grammar-token-c_pattern">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">c_pattern</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>in</span> <span class="meta">|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span>as</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code><a class="headerlink" href="#grammar-token-c_pattern" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>context pattern see <a class="reference internal" href="#contextual-patterns-ssr"><span class="std std-ref">Contextual patterns</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">d_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="meta">|</span> <span>(</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span>)</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>discharge item see <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a></p>
<dl class="prodn">
<dt id="grammar-token-gen_item">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">gen_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="meta">|</span> <span>(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>)</span> <span class="meta">|</span> <span>(</span> <span class="repeat-wrapper"><span class="repeat"><span>&#64;</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span>)</span></span></code><a class="headerlink" href="#grammar-token-gen_item" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>generalization item see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">i_pattern</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="meta">|</span> <span>_</span> <span class="meta">|</span> <span>?</span> <span class="meta">|</span> <span>*</span> <span class="meta">|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span>-&gt;</span> <span class="meta">|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span>&lt;-</span> <span class="meta">|</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span class="meta">|</span> <span>-</span> <span class="meta">|</span> <span>[:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span> <span>]</span></span></code></dt>
<dd></dd></dl>

<p>intro pattern <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">i_item</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a> <span class="meta">|</span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>intro item  see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="prodn">
<dt id="grammar-token-int_mult">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">int_mult</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-mult_mark"><span class="hole">mult_mark</span></a></span></code><a class="headerlink" href="#grammar-token-int_mult" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>multiplier  see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">occ_switch</span> <span class="pre">::=</span> </code><span class="notation"><span class="curlies">{ <span class="repeat-wrapper"><span class="repeat"><span>+</span> <span class="meta">|</span> <span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">*</span></span> }</span></span></code></dt>
<dd></dd></dl>

<p>occur. switch see <a class="reference internal" href="#occurrence-selection-ssr"><span class="std std-ref">Occurrence selection</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">mult</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-mult_mark"><span class="hole">mult_mark</span></a></span></code></dt>
<dd></dd></dl>

<p>multiplier see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="prodn">
<dt id="grammar-token-mult_mark">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">mult_mark</span> <span class="pre">::=</span> </code><span class="notation"><span>?</span> <span class="meta">|</span> <span>!</span></span></code><a class="headerlink" href="#grammar-token-mult_mark" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>multiplier mark see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">r_item</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>/</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a></span></code></dt>
<dd></dd></dl>

<p>rewrite item see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">r_prefix</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><span>-</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-int_mult"><span class="hole">int_mult</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>[</span> <a class="reference internal" href="#grammar-token-r_pattern"><span class="hole">r_pattern</span></a> <span>]</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>rewrite prefix see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">r_pattern</span> <span class="pre">::=</span> </code><span class="notation"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a> <span class="meta">|</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>in</span></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>rewrite pattern see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="prodn">
<dt id="grammar-token-r_step">
<code class="descname"><code class="docutils literal notranslate"><span class="pre">r_step</span> <span class="pre">::=</span> </code><span class="notation"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="#grammar-token-r_item"><span class="hole">r_item</span></a></span></code><a class="headerlink" href="#grammar-token-r_step" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>rewrite step see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">s_item</span> <span class="pre">::=</span> </code><span class="notation"><span>/=</span> <span class="meta">|</span> <span>//</span> <span class="meta">|</span> <span>//=</span></span></code></dt>
<dd></dd></dl>

<p>simplify switch see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
</div>
<div class="section" id="tactics">
<h3>Tactics<a class="headerlink" href="#tactics" title="このヘッドラインへのパーマリンク">¶</a></h3>
<p><em>Note</em>: <code class="docutils literal notranslate"><span class="pre">without</span> <span class="pre">loss</span></code> and <code class="docutils literal notranslate"><span class="pre">suffices</span></code> are synonyms for <code class="docutils literal notranslate"><span class="pre">wlog</span></code> and <code class="docutils literal notranslate"><span class="pre">suff</span></code>
respectively.</p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>move</span></span></code></dt>
<dd></dd></dl>

<p>idtac or hnf see  <a class="reference internal" href="#bookkeeping-ssr"><span class="std std-ref">Bookkeeping</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>apply</span></span></code></dt>
<dd></dd></dl>

<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>exact</span></span></code></dt>
<dd></dd></dl>

<p>application see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>abstract</span></span></code></dt>
<dd><p>see <a class="reference internal" href="#abstract-ssr"><span class="std std-ref">The abstract tactic</span></a> and <a class="reference internal" href="#generating-let-ssr"><span class="std std-ref">Generating let in context entries with have</span></a></p>
</dd></dl>

<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>elim</span></span></code></dt>
<dd></dd></dl>

<p>induction see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>case</span></span></code></dt>
<dd></dd></dl>

<p>case analysis see <a class="reference internal" href="#the-defective-tactics-ssr"><span class="std std-ref">The defective tactics</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>rewrite</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_step"><span class="hole">r_step</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<p>rewrite  see <a class="reference internal" href="#rewriting-ssr"><span class="std std-ref">Rewriting</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a> <span class="meta">|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-s_item"><span class="hole">s_item</span></a> <span class="meta">|</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>have</span> <span>suff</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>have</span> <span>suff</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>gen</span> <span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>,</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.generally-have">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>generally</span> <span>have</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>,</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a></span><span class="notation-sup">+</span></span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.generally-have" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>forward  chaining see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>wlog</span> <span class="repeat-wrapper"><span class="repeat"><span>suff</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">*</span></span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>specializing see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a></p>
<dl class="tacn">
<dt id="coq:tacn.suff">
<code class="descname"><span class="notation"><span>suff</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacn.suff" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt id="coq:tacv.suffices">
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>suffices</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">*</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:tacv.suffices" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>suff</span> <span class="repeat-wrapper"><span class="repeat"><span>have</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>suffices</span> <span class="repeat-wrapper"><span class="repeat"><span>have</span></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_pattern"><span class="hole">i_pattern</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="repeat-wrapper"><span class="repeat"><span>by</span> <span class="hole">tactic</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>backchaining see <a class="reference internal" href="#structure-ssr"><span class="std std-ref">Structure</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>pose</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>local definition <a class="reference internal" href="#definitions-ssr"><span class="std std-ref">Definitions</span></a></p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pose</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-ssr_binder"><span class="hole">ssr_binder</span></a></span><span class="notation-sup">+</span></span> <span>:=</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>local function definition</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pose</span> <span>fix</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-fix_body"><span class="hole">fix_body</span></a></span></code></dt>
<dd></dd></dl>

<p>local fix definition</p>
<dl class="tacv">
<dt>
<em class="property"><span class="sigannot">Variant</span></em> <code class="descname"><span class="notation"><span>pose</span> <span>cofix</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-fix_body"><span class="hole">fix_body</span></a></span></code></dt>
<dd></dd></dl>

<p>local cofix definition</p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>set</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>:</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span><span class="notation-sup">?</span></span> <span>:=</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-occ_switch"><span class="hole">occ_switch</span></a></span><span class="notation-sup">?</span></span> <span class="meta">(</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a> <span class="meta">|</span> <span>(</span> <a class="reference internal" href="#grammar-token-c_pattern"><span class="hole">c_pattern</span></a><span>)</span> <span class="meta">)</span></span></code></dt>
<dd></dd></dl>

<p>abbreviation see <a class="reference internal" href="#abbreviations-ssr"><span class="std std-ref">Abbreviations</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>unlock</span> <span class="repeat-wrapper"><span class="repeat"><span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-r_prefix"><span class="hole">r_prefix</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">*</span></span></span></code></dt>
<dd></dd></dl>

<p>unlock see <a class="reference internal" href="#locking-ssr"><span class="std std-ref">Locking, unlocking</span></a></p>
<dl class="tacn">
<dt>
<code class="descname"><span class="notation"><span>congr</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-term"><span class="hole">term</span></a></span></code></dt>
<dd></dd></dl>

<p>congruence <a class="reference internal" href="#congruence-ssr"><span class="std std-ref">Congruence</span></a></p>
</div>
<div class="section" id="tacticals">
<h3>Tacticals<a class="headerlink" href="#tacticals" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><a class="reference internal" href="#grammar-token-d_tactic"><span class="hole">d_tactic</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">?</span></span> <span>:</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-d_item"><span class="hole">d_item</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>discharge <a class="reference internal" href="#discharge-ssr"><span class="std std-ref">Discharge</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>=&gt;</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-i_item"><span class="hole">i_item</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<p>introduction see <a class="reference internal" href="#introduction-ssr"><span class="std std-ref">Introduction in the context</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>in</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-gen_item"><span class="hole">gen_item</span></a> <span class="meta">|</span> <a class="reference internal" href="#grammar-token-clear_switch"><span class="hole">clear_switch</span></a></span><span class="notation-sup">+</span></span> <span class="repeat-wrapper"><span class="repeat"><span>*</span></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>localization see <a class="reference internal" href="#localization-ssr"><span class="std std-ref">Localization</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span>do</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="#grammar-token-mult"><span class="hole">mult</span></a></span><span class="notation-sup">?</span></span> <span class="meta">(</span> <span class="hole">tactic</span> <span class="meta">|</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>]</span> <span class="meta">)</span></span></code></dt>
<dd></dd></dl>

<p>iteration  see <a class="reference internal" href="#iteration-ssr"><span class="std std-ref">Iteration</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>;</span> <span class="meta">(</span> <span>first</span> <span class="meta">|</span> <span>last</span> <span class="meta">)</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span> <span class="meta">(</span> <span class="hole">tactic</span> <span class="meta">|</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">+</span><span class="notation-sub">|</span></span> <span>]</span> <span class="meta">)</span></span></code></dt>
<dd></dd></dl>

<p>selector  see <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span class="hole">tactic</span> <span>;</span> <span class="meta">(</span> <span>first</span> <span class="meta">|</span> <span>last</span> <span class="meta">)</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>rotation see <a class="reference internal" href="#selectors-ssr"><span class="std std-ref">Selectors</span></a></p>
<dl class="prodn">
<dt>
<code class="descname"><code class="docutils literal notranslate"><span class="pre">tactic</span> <span class="pre">+=</span> </code><span class="notation"><span>by</span> <span class="meta">(</span> <span class="hole">tactic</span> <span class="meta">|</span> <span>[</span> <span class="repeat-wrapper"><span class="repeat"><span class="hole">tactic</span></span><span class="notation-sup">*</span><span class="notation-sub">|</span></span> <span>]</span> <span class="meta">)</span></span></code></dt>
<dd></dd></dl>

<p>closing see <a class="reference internal" href="#terminators-ssr"><span class="std std-ref">Terminators</span></a></p>
</div>
<div class="section" id="commands">
<h3>Commands<a class="headerlink" href="#commands" title="このヘッドラインへのパーマリンク">¶</a></h3>
<dl class="cmd">
<dt id="coq:cmd.hint-view-for">
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span class="meta">(</span> <span>move</span> <span class="meta">|</span> <span>apply</span> <span class="meta">)</span> <span>/</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><span>|</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span></span></code><a class="headerlink" href="#coq:cmd.hint-view-for" title="この定義へのパーマリンク">¶</a></dt>
<dd></dd></dl>

<p>view hint declaration see <a class="reference internal" href="#declaring-new-hints-ssr"><span class="std std-ref">Declaring new Hint Views</span></a></p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Hint</span> <span>View</span> <span>for</span> <span>apply</span> <span>//</span> <a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-num"><span class="hole">num</span></a></span><span class="notation-sup">?</span></span></span></code></dt>
<dd></dd></dl>

<p>right hand side double , view hint declaration see <a class="reference internal" href="#declaring-new-hints-ssr"><span class="std std-ref">Declaring new Hint Views</span></a></p>
<dl class="cmd">
<dt>
<em class="property"><span class="sigannot">Command</span></em> <code class="descname"><span class="notation"><span>Prenex</span> <span>Implicits</span> <span class="repeat-wrapper"><span class="repeat"><a class="reference internal" href="../language/gallina-specification-language.html#grammar-token-ident"><span class="hole">ident</span></a></span><span class="notation-sup">+</span></span></span></code></dt>
<dd></dd></dl>

<p>prenex implicits declaration see <a class="reference internal" href="#parametric-polymorphism-ssr"><span class="std std-ref">Parametric polymorphism</span></a></p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[10]</a></td><td>Unfortunately, even after a call to the Set Printing All command,
some occurrences are still not displayed to the user, essentially the
ones possibly hidden in the predicate of a dependent match structure.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[11]</a></td><td>Thus scripts that depend on bound variable names, e.g., via intros
or with, are inherently fragile.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[12]</a></td><td>The name <code class="docutils literal notranslate"><span class="pre">subnK</span></code> reads as “right cancellation rule for nat
subtraction”.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[13]</a></td><td>Also, a slightly different variant may be used for the first <a class="reference internal" href="#grammar-token-d_item"><code class="xref std std-token docutils literal notranslate"><span class="pre">d_item</span></code></a>
of case and elim; see section <a class="reference internal" href="#type-families-ssr"><span class="std std-ref">Type families</span></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[14]</a></td><td>Except /= does not expand the local definitions created by the
<span class="smallcaps">SSReflect</span> in tactical.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[15]</a></td><td><span class="smallcaps">SSReflect</span> reserves all identifiers of the form “_x_”, which is
used for such generated names.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[16]</a></td><td>More precisely, it should have a quantified inductive type with a
assumptions and m − a constructors.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[17]</a></td><td>This is an implementation feature: there is no such obstruction
in the metatheory</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[18]</a></td><td>The current state of the proof shall be displayed by the Show
Proof command of <span class="smallcaps">Coq</span> proof mode.</td></tr>
</tbody>
</table>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../user-extensions/syntax-extensions.html" class="btn btn-neutral float-right" title="Syntax extensions and interpretation scopes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="detailed-tactic-examples.html" class="btn btn-neutral" title="Detailed examples of tactics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 1999-2018, Inria.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'8.8.2',
            LANGUAGE:'ja',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/notations.js"></script>
      <script type="text/javascript" src="../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  <script type="text/javascript" src="../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>